
garage_project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006c14  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000156  00800060  00006c14  00006ca8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000068c  008001b6  008001b6  00006dfe  2**0
                  ALLOC
  3 .stab         00003480  00000000  00000000  00006e00  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009be  00000000  00000000  0000a280  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  0000ac3e  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000009c8  00000000  00000000  0000ac6d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000104d0  00000000  00000000  0000b635  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003746  00000000  00000000  0001bb05  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000429c  00000000  00000000  0001f24b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001b08  00000000  00000000  000234e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000377b  00000000  00000000  00024ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00008459  00000000  00000000  0002876b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000928  00000000  00000000  00030bc4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 04 05 	jmp	0xa08	; 0xa08 <__ctors_end>
       4:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
       8:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
       c:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      10:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      14:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      18:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      1c:	0c 94 ea 29 	jmp	0x53d4	; 0x53d4 <__vector_7>
      20:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      24:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      28:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      2c:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      30:	0c 94 3a 26 	jmp	0x4c74	; 0x4c74 <__vector_12>
      34:	0c 94 17 27 	jmp	0x4e2e	; 0x4e2e <__vector_13>
      38:	0c 94 69 27 	jmp	0x4ed2	; 0x4ed2 <__vector_14>
      3c:	0c 94 40 27 	jmp	0x4e80	; 0x4e80 <__vector_15>
      40:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      44:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      48:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      4c:	0c 94 37 24 	jmp	0x486e	; 0x486e <__vector_19>
      50:	0c 94 21 05 	jmp	0xa42	; 0xa42 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	std	Y+40, r29	; 0x28
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	std	Y+56, r1	; 0x38
      62:	ba ab       	std	Y+50, r27	; 0x32
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	std	Y+51, r10	; 0x33
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	std	Y+54, r27	; 0x36
      96:	aa aa       	std	Y+50, r10	; 0x32
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	ldd	r30, Z+49	; 0x31
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <__c.3087+0x7>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__c.2941>:
      d6:	53 4f 4d 45 20 4f 4e 45 20 57 49 54 48 20 50 41     SOME ONE WITH PA
      e6:	53 53 57 4f 52 44 20 00                             SSWORD .

000000ee <__c.2943>:
      ee:	20 54 52 59 20 54 4f 20 45 4e 54 45 52 20 61 74      TRY TO ENTER at
      fe:	20 00                                                .

00000100 <__c.2948>:
     100:	20 45 4e 54 45 52 20 61 74 20 00                     ENTER at .

0000010b <__c.3000>:
     10b:	53 59 53 54 45 4d 20 4c 4f 43 4b 45 44 20 50 4c     SYSTEM LOCKED PL
     11b:	45 41 53 45 20 43 4f 4e 54 41 43 54 20 54 48 45     EASE CONTACT THE
     12b:	20 44 45 56 45 4c 4f 50 45 52 20 00                  DEVELOPER .

00000137 <__c.2934>:
     137:	54 48 45 20 53 59 53 54 45 4d 20 49 53 20 4e 4f     THE SYSTEM IS NO
     147:	54 20 4c 4f 43 4b 45 44 20 2e 2e 2e 2e 2e 2e 00     T LOCKED .......

00000157 <__c.2936>:
     157:	55 4e 4c 4f 43 4b 49 4e 47 20 54 48 45 20 53 59     UNLOCKING THE SY
     167:	53 54 45 4d 20 2e 2e 2e 2e 2e 2e 00                 STEM .......

00000173 <__c.2943>:
     173:	4f 50 45 4e 49 4e 47 20 54 48 45 20 47 41 52 41     OPENING THE GARA
     183:	47 45 20 2e 2e 2e 2e 2e 2e 00                       GE .......

0000018d <__c.2945>:
     18d:	47 41 52 41 47 45 20 48 41 53 20 41 4c 52 45 41     GARAGE HAS ALREA
     19d:	44 59 20 42 45 45 4e 20 4f 50 45 4e 45 44 20 2e     DY BEEN OPENED .
     1ad:	2e 2e 2e 2e 2e 00                                   ......

000001b3 <__c.2952>:
     1b3:	43 4c 4f 53 49 4e 47 20 54 48 45 20 47 41 52 41     CLOSING THE GARA
     1c3:	47 45 20 2e 2e 2e 2e 2e 2e 00                       GE .......

000001cd <__c.2954>:
     1cd:	47 41 52 41 47 45 20 49 53 20 43 4c 4f 53 45 44     GARAGE IS CLOSED
     1dd:	2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 2e 00     ................

000001ed <__c.2982>:
     1ed:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     1fd:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
	...

0000020e <__c.2985>:
     20e:	45 4e 54 45 52 20 48 4f 55 52 20 20 3a 20 00        ENTER HOUR  : .

0000021d <__c.2989>:
     21d:	45 4e 54 45 52 20 4d 49 4e 55 54 45 20 20 3a 20     ENTER MINUTE  : 
	...

0000022e <__c.2992>:
     22e:	45 4e 54 45 52 20 28 31 20 2d 3e 20 41 4d 20 29     ENTER (1 -> AM )
     23e:	20 28 32 20 2d 3e 20 50 4d 29 20 20 3a 20 00         (2 -> PM)  : .

0000024d <__c.2995>:
     24d:	45 4e 54 45 52 20 44 41 54 45 20 20 3a 20 00        ENTER DATE  : .

0000025c <__c.2998>:
     25c:	45 4e 54 45 52 20 4d 4f 4e 54 48 20 20 3a 20 00     ENTER MONTH  : .

0000026c <__c.3001>:
     26c:	45 4e 54 45 52 20 59 45 41 52 20 20 3a 20 00        ENTER YEAR  : .

0000027b <__c.3004>:
     27b:	44 4f 4e 45 20 54 49 4d 45 20 49 53 20 53 45 54     DONE TIME IS SET
     28b:	20 2e 2e 2e 2e 2e 2e 2e 20 00                        ....... .

00000295 <__c.3015>:
     295:	49 4e 56 41 4c 49 44 20 49 4e 50 55 54 20 2e 2e     INVALID INPUT ..
     2a5:	2e 2e 2e 2e 2e 20 00                                ..... .

000002ac <__c.3156>:
     2ac:	45 4e 54 45 52 20 52 4f 4f 54 20 50 41 53 53 57     ENTER ROOT PASSW
     2bc:	4f 52 44 20 3a 20 00                                ORD : .

000002c3 <__c.3158>:
     2c3:	4c 4f 47 47 49 4e 47 20 49 4e 20 2e 2e 2e 2e 2e     LOGGING IN .....
     2d3:	2e 2e 20 00                                         .. .

000002d7 <__c.3160>:
     2d7:	43 48 41 4e 47 45 20 52 4f 4f 54 20 50 41 53 53     CHANGE ROOT PASS
     2e7:	57 4f 52 44 20 3a 20 00                             WORD : .

000002ef <__c.3162>:
     2ef:	50 4c 45 41 53 45 20 53 45 54 20 54 48 45 20 54     PLEASE SET THE T
     2ff:	49 4d 45 20 2e 2e 2e 2e 2e 2e 2e 20 00              IME ....... .

0000030c <__c.3164>:
     30c:	49 4e 56 41 4c 49 44 20 50 41 53 53 57 4f 52 44     INVALID PASSWORD
     31c:	20 2e 2e 2e 2e 2e 2e 00                              .......

00000324 <__c.3166>:
     324:	49 4e 56 41 4c 49 44 20 50 41 53 53 57 4f 52 44     INVALID PASSWORD
     334:	20 2e 2e 2e 2e 2e 2e 00                              .......

0000033c <__c.3172>:
     33c:	23 23 23 00                                         ###.

00000340 <__c.3180>:
     340:	45 4e 54 45 52 20 41 44 4d 49 4e 20 50 41 53 53     ENTER ADMIN PASS
     350:	57 4f 52 44 20 3a 20 00                             WORD : .

00000358 <__c.3182>:
     358:	4c 4f 47 47 49 4e 47 20 49 4e 20 2e 2e 2e 2e 2e     LOGGING IN .....
     368:	2e 2e 20 00                                         .. .

0000036c <__c.3117>:
     36c:	57 72 6f 6e 67 20 65 6e 74 72 79 20 00              Wrong entry .

00000379 <__c.3063>:
     379:	45 4e 54 45 52 20 31 20 54 4f 20 55 4e 4c 4f 43     ENTER 1 TO UNLOC
     389:	4b 20 54 48 45 20 53 59 53 54 45 4d 00              K THE SYSTEM.

00000396 <__c.3065>:
     396:	45 4e 54 45 52 20 32 20 54 4f 20 4f 50 45 4e 20     ENTER 2 TO OPEN 
     3a6:	47 41 52 41 47 45 00                                GARAGE.

000003ad <__c.3067>:
     3ad:	45 4e 54 45 52 20 33 20 54 4f 20 43 4c 4f 53 45     ENTER 3 TO CLOSE
     3bd:	20 47 41 52 41 47 45 00                              GARAGE.

000003c5 <__c.3069>:
     3c5:	45 4e 54 45 52 20 34 20 54 4f 20 53 45 54 20 54     ENTER 4 TO SET T
     3d5:	48 45 20 54 49 4d 45 00                             HE TIME.

000003dd <__c.3071>:
     3dd:	45 4e 54 45 52 20 35 20 54 4f 20 41 44 44 2f 52     ENTER 5 TO ADD/R
     3ed:	45 4d 4f 56 45 20 55 53 45 52 53 00                 EMOVE USERS.

000003f9 <__c.3073>:
     3f9:	45 4e 54 45 52 20 36 20 54 4f 20 4c 4f 47 4f 55     ENTER 6 TO LOGOU
     409:	54 00                                               T.

0000040b <__c.3129>:
     40b:	3e 3e 3e 00                                         >>>.

0000040f <__c.3188>:
     40f:	45 4e 54 45 52 20 52 4f 4f 54 20 55 53 45 52 20     ENTER ROOT USER 
     41f:	50 41 53 53 57 4f 52 44 20 3a 20 00                 PASSWORD : .

0000042b <__c.3190>:
     42b:	4e 4f 54 20 52 4f 4f 54 20 50 41 53 53 57 4f 52     NOT ROOT PASSWOR
     43b:	44 20 2e 2e 2e 2e 20 00                             D .... .

00000443 <__c.3192>:
     443:	57 52 4f 4e 47 20 52 4f 4f 54 20 50 41 53 53 57     WRONG ROOT PASSW
     453:	4f 52 44 20 2e 2e 2e 2e 20 00                       ORD .... .

0000045d <__c.3078>:
     45d:	45 4e 54 45 52 20 31 20 54 4f 20 4c 49 53 54 20     ENTER 1 TO LIST 
     46d:	41 4c 4c 20 55 53 45 52 53 00                       ALL USERS.

00000477 <__c.3080>:
     477:	45 4e 54 45 52 20 32 20 54 4f 20 41 44 44 20 4e     ENTER 2 TO ADD N
     487:	45 57 20 55 53 45 52 00                             EW USER.

0000048f <__c.3082>:
     48f:	45 4e 54 45 52 20 33 20 54 4f 20 45 44 49 54 20     ENTER 3 TO EDIT 
     49f:	55 53 45 52 00                                      USER.

000004a4 <__c.3084>:
     4a4:	45 4e 54 45 52 20 34 20 54 4f 20 44 45 4c 45 54     ENTER 4 TO DELET
     4b4:	45 20 55 53 45 52 00                                E USER.

000004bb <__c.3086>:
     4bb:	45 4e 54 45 52 20 35 20 54 4f 20 52 45 53 45 54     ENTER 5 TO RESET
     4cb:	20 46 41 43 54 4f 52 59 20 44 45 46 41 55 4c 54      FACTORY DEFAULT
	...

000004dc <__c.3088>:
     4dc:	45 4e 54 45 52 20 36 20 54 4f 20 42 41 43 4b 20     ENTER 6 TO BACK 
     4ec:	54 4f 20 4d 45 4e 55 00                             TO MENU.

000004f4 <__c.3123>:
     4f4:	3e 3e 3e 00                                         >>>.

000004f8 <__c.3199>:
     4f8:	54 45 52 4d 49 4e 41 4c 20 4c 4f 43 4b 45 44 20     TERMINAL LOCKED 
     508:	2e 2e 2e 2e 20 00                                   .... .

0000050e <__c.3201>:
     50e:	45 4e 54 45 52 20 52 4f 4f 54 20 50 41 53 53 57     ENTER ROOT PASSW
     51e:	4f 52 44 20 54 4f 20 55 4e 4c 4f 43 4b 20 3a 20     ORD TO UNLOCK : 
	...

0000052f <__c.3203>:
     52f:	53 59 53 54 45 4d 20 4c 4f 43 4b 45 44 20 50 4c     SYSTEM LOCKED PL
     53f:	45 41 53 45 20 43 4f 4e 54 41 43 54 20 54 48 45     EASE CONTACT THE
     54f:	20 44 45 56 45 4c 4f 50 45 52 20 00                  DEVELOPER .

0000055b <__c.2937>:
     55b:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     56b:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     57b:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     58b:	2d 2d 00                                            --.

0000058e <__c.2939>:
     58e:	43 55 52 52 45 4e 54 20 55 53 45 52 53 20 4f 46     CURRENT USERS OF
     59e:	20 54 48 45 20 53 59 53 54 45 4d 00                  THE SYSTEM.

000005aa <__c.2941>:
     5aa:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     5ba:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                    ----------.

000005c5 <__c.2943>:
     5c5:	20 2d 20 00                                          - .

000005c9 <__c.2948>:
     5c9:	20 20 20 2d 3e 20 00                                   -> .

000005d0 <__c.2950>:
     5d0:	52 4f 4f 54 20 55 53 45 52 20 00                    ROOT USER .

000005db <__c.2952>:
     5db:	41 44 4d 49 4e 20 55 53 45 52 20 00                 ADMIN USER .

000005e7 <__c.2954>:
     5e7:	4e 4f 52 4d 41 4c 20 55 53 45 52 20 00              NORMAL USER .

000005f4 <__c.2956>:
     5f4:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     604:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     614:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                    ----------.

0000061f <__c.2984>:
     61f:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     62f:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
	...

00000640 <__c.2987>:
     640:	45 4e 54 45 52 20 55 53 45 52 20 4e 41 4d 45 20     ENTER USER NAME 
     650:	28 4d 41 58 20 39 20 43 48 41 52 29 20 3a 20 00     (MAX 9 CHAR) : .

00000660 <__c.2991>:
     660:	45 4e 54 45 52 20 55 53 45 52 20 50 41 53 53 57     ENTER USER PASSW
     670:	4f 52 44 20 28 34 20 44 49 47 49 54 29 20 3a 20     ORD (4 DIGIT) : 
	...

00000681 <__c.2994>:
     681:	45 4e 54 45 52 20 55 53 45 52 20 54 59 50 45 20     ENTER USER TYPE 
     691:	28 52 4f 4f 54 20 3d 20 30 29 20 7c 20 28 61 64     (ROOT = 0) | (ad
     6a1:	6d 69 6e 20 3d 20 31 29 20 7c 20 28 75 73 65 72     min = 1) | (user
     6b1:	20 3d 20 32 29 20 20 3a 20 00                        = 2)  : .

000006bb <__c.2997>:
     6bb:	55 53 45 52 20 41 44 44 45 44 20 53 55 43 45 53     USER ADDED SUCES
     6cb:	53 46 55 4c 59 20 2e 2e 2e 2e 2e 2e 2e 2e 20 00     SFULY ........ .

000006db <__c.2999>:
     6db:	46 41 49 4c 45 44 20 54 4f 20 41 44 44 20 4e 45     FAILED TO ADD NE
     6eb:	57 20 55 53 45 52 20 59 4f 55 20 52 45 41 43 48     W USER YOU REACH
     6fb:	20 4d 41 58 20 4e 55 4d 42 45 52 20 4f 46 20 55      MAX NUMBER OF U
     70b:	53 45 52 20 2e 2e 2e 2e 2e 2e 2e 2e 2e 20 00        SER ......... .

0000071a <__c.3005>:
     71a:	55 53 45 52 20 4e 41 4d 45 20 4d 55 53 54 20 42     USER NAME MUST B
     72a:	45 20 3c 20 39 20 44 49 47 49 54 20 2e 2e 2e 2e     E < 9 DIGIT ....
     73a:	2e 2e 2e 2e 2e 20 00                                ..... .

00000741 <__c.3008>:
     741:	54 48 49 53 20 55 53 45 52 20 4e 41 4d 45 20 41     THIS USER NAME A
     751:	4c 52 45 41 44 59 20 55 53 45 44 20 00              LREADY USED .

0000075e <__c.3011>:
     75e:	50 41 53 53 57 4f 52 44 20 4d 55 53 54 20 42 45     PASSWORD MUST BE
     76e:	20 34 20 44 49 47 49 54 20 2e 2e 2e 2e 2e 2e 2e      4 DIGIT .......
     77e:	2e 2e 20 00                                         .. .

00000782 <__c.3014>:
     782:	54 48 49 53 20 50 41 53 53 57 4f 52 44 20 41 4c     THIS PASSWORD AL
     792:	52 45 41 44 59 20 55 53 45 44 20 00                 READY USED .

0000079e <__c.3017>:
     79e:	57 52 4f 4e 47 20 55 53 45 52 20 54 59 50 45 20     WRONG USER TYPE 
     7ae:	2e 2e 2e 2e 2e 2e 2e 2e 2e 20 00                    ......... .

000007b9 <__c.3053>:
     7b9:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     7c9:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
	...

000007da <__c.3056>:
     7da:	45 4e 54 45 52 20 55 53 45 52 20 49 44 20 3a 20     ENTER USER ID : 
	...

000007eb <__c.3060>:
     7eb:	53 45 4c 45 43 54 20 46 49 45 4c 44 20 20 28 31     SELECT FIELD  (1
     7fb:	20 2d 3e 20 4e 41 4d 45 29 20 28 32 20 2d 3e 20      -> NAME) (2 -> 
     80b:	50 41 53 53 29 20 28 33 20 2d 3e 20 54 59 50 45     PASS) (3 -> TYPE
     81b:	29 20 3a 20 00                                      ) : .

00000820 <__c.3063>:
     820:	45 4e 54 45 52 20 55 53 45 52 20 4e 41 4d 45 20     ENTER USER NAME 
     830:	28 4d 41 58 20 39 20 43 48 41 52 29 20 3a 20 00     (MAX 9 CHAR) : .

00000840 <__c.3066>:
     840:	45 4e 54 45 52 20 55 53 45 52 20 50 41 53 53 57     ENTER USER PASSW
     850:	4f 52 44 20 28 34 20 44 49 47 49 54 29 20 3a 20     ORD (4 DIGIT) : 
	...

00000861 <__c.3069>:
     861:	45 4e 54 45 52 20 55 53 45 52 20 54 59 50 45 20     ENTER USER TYPE 
     871:	28 52 4f 4f 54 20 3d 20 30 29 20 7c 20 28 61 64     (ROOT = 0) | (ad
     881:	6d 69 6e 20 3d 20 31 29 20 7c 20 28 75 73 65 72     min = 1) | (user
     891:	20 3d 20 32 29 20 20 3a 20 00                        = 2)  : .

0000089b <__c.3078>:
     89b:	44 4f 4e 45 20 45 44 49 54 49 4e 47 20 2e 2e 2e     DONE EDITING ...
     8ab:	2e 2e 2e 2e 2e 2e 20 00                             ...... .

000008b3 <__c.3084>:
     8b3:	49 4e 56 41 4c 49 44 20 49 44 20 2e 2e 2e 2e 2e     INVALID ID .....
     8c3:	2e 2e 2e 2e 20 00                                   .... .

000008c9 <__c.3087>:
     8c9:	49 4e 56 41 4c 49 44 20 4f 50 54 49 4f 4e 20 2e     INVALID OPTION .
     8d9:	2e 2e 2e 2e 2e 2e 2e 2e 20 00                       ........ .

000008e3 <__c.3090>:
     8e3:	49 4e 56 41 4c 49 44 20 55 53 45 52 20 4e 41 4d     INVALID USER NAM
     8f3:	45 20 2e 2e 2e 2e 2e 2e 2e 2e 2e 20 00              E ......... .

00000900 <__c.3093>:
     900:	55 53 45 52 20 4e 41 4d 45 20 55 53 45 44 20 20     USER NAME USED  
     910:	2e 2e 2e 2e 2e 2e 2e 2e 2e 20 00                    ......... .

0000091b <__c.3096>:
     91b:	49 4e 56 41 4c 49 44 20 50 41 53 53 57 4f 52 44     INVALID PASSWORD
     92b:	20 2e 2e 2e 2e 2e 2e 2e 2e 2e 20 00                  ......... .

00000937 <__c.3099>:
     937:	50 41 53 53 57 4f 52 44 20 55 53 45 44 20 20 2e     PASSWORD USED  .
     947:	2e 2e 2e 2e 2e 2e 2e 2e 20 00                       ........ .

00000951 <__c.3102>:
     951:	57 52 4f 4e 47 20 55 53 45 52 20 54 59 50 45 20     WRONG USER TYPE 
     961:	2e 2e 2e 2e 2e 2e 2e 2e 2e 20 00                    ......... .

0000096c <__c.3123>:
     96c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     97c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     98c:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     99c:	2d 2d 00                                            --.

0000099f <__c.3126>:
     99f:	45 4e 54 45 52 20 49 44 20 4e 55 4d 42 45 52 20     ENTER ID NUMBER 
     9af:	3a 20 00                                            : .

000009b2 <__c.3130>:
     9b2:	55 53 45 52 20 44 45 4c 45 54 45 44 20 73 75 63     USER DELETED suc
     9c2:	63 65 73 73 66 75 6c 6c 79 20 2e 2e 2e 2e 2e 2e     cessfully ......
     9d2:	2e 2e 2e 2e 00                                      .....

000009d7 <__c.3137>:
     9d7:	49 4e 56 41 4c 49 44 20 55 53 45 52 20 2e 2e 2e     INVALID USER ...
     9e7:	2e 2e 2e 2e 2e 2e 2e 00                             ........

000009ef <__c.3145>:
     9ef:	52 45 53 45 54 20 53 59 53 54 45 4d 20 44 4f 4e     RESET SYSTEM DON
     9ff:	45 20 2e 2e 2e 2e 2e 2e 00                          E .......

00000a08 <__ctors_end>:
     a08:	11 24       	eor	r1, r1
     a0a:	1f be       	out	0x3f, r1	; 63
     a0c:	cf e5       	ldi	r28, 0x5F	; 95
     a0e:	d8 e0       	ldi	r29, 0x08	; 8
     a10:	de bf       	out	0x3e, r29	; 62
     a12:	cd bf       	out	0x3d, r28	; 61

00000a14 <__do_copy_data>:
     a14:	11 e0       	ldi	r17, 0x01	; 1
     a16:	a0 e6       	ldi	r26, 0x60	; 96
     a18:	b0 e0       	ldi	r27, 0x00	; 0
     a1a:	e4 e1       	ldi	r30, 0x14	; 20
     a1c:	fc e6       	ldi	r31, 0x6C	; 108
     a1e:	02 c0       	rjmp	.+4      	; 0xa24 <__do_copy_data+0x10>
     a20:	05 90       	lpm	r0, Z+
     a22:	0d 92       	st	X+, r0
     a24:	a6 3b       	cpi	r26, 0xB6	; 182
     a26:	b1 07       	cpc	r27, r17
     a28:	d9 f7       	brne	.-10     	; 0xa20 <__do_copy_data+0xc>

00000a2a <__do_clear_bss>:
     a2a:	28 e0       	ldi	r18, 0x08	; 8
     a2c:	a6 eb       	ldi	r26, 0xB6	; 182
     a2e:	b1 e0       	ldi	r27, 0x01	; 1
     a30:	01 c0       	rjmp	.+2      	; 0xa34 <.do_clear_bss_start>

00000a32 <.do_clear_bss_loop>:
     a32:	1d 92       	st	X+, r1

00000a34 <.do_clear_bss_start>:
     a34:	a2 34       	cpi	r26, 0x42	; 66
     a36:	b2 07       	cpc	r27, r18
     a38:	e1 f7       	brne	.-8      	; 0xa32 <.do_clear_bss_loop>
     a3a:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <main>
     a3e:	0c 94 08 36 	jmp	0x6c10	; 0x6c10 <_exit>

00000a42 <__bad_interrupt>:
     a42:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a46 <vkeypad_task>:
#include "keypad_task.h"
//---------------------------------------------------------------
static xQueueHandle g_keypad_q;
//--------------------------------------------------------------
void vkeypad_task(void *pvParameters)
{
     a46:	cf 93       	push	r28
     a48:	df 93       	push	r29
     a4a:	1f 92       	push	r1
     a4c:	cd b7       	in	r28, 0x3d	; 61
     a4e:	de b7       	in	r29, 0x3e	; 62
	//init
	portBASE_TYPE que_state;
	u8 button=NO_VALID_INPUT;
     a50:	8f ef       	ldi	r24, 0xFF	; 255
     a52:	89 83       	std	Y+1, r24	; 0x01
	keypad_switch_state_t kp_state=KP_SWITCH_RELEASED_STATE;
	vEcu_KeypadInit(&keypad_param);
     a54:	8d e7       	ldi	r24, 0x7D	; 125
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <vEcu_KeypadInit>
	//do task
	while(1)
	{
		//scan keypad
		kp_state=ucEcu_KeypadScanState(&keypad_param,&button);
     a5c:	be 01       	movw	r22, r28
     a5e:	6f 5f       	subi	r22, 0xFF	; 255
     a60:	7f 4f       	sbci	r23, 0xFF	; 255
     a62:	8d e7       	ldi	r24, 0x7D	; 125
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	0e 94 69 18 	call	0x30d2	; 0x30d2 <ucEcu_KeypadScanState>
		//check valid input
		if(kp_state ==KP_SWITCH_PRE_PRESSED_STATE )
     a6a:	81 30       	cpi	r24, 0x01	; 1
     a6c:	69 f4       	brne	.+26     	; 0xa88 <vkeypad_task+0x42>
		{
			//send to queue
			 que_state=xQueueSendToBack(g_keypad_q,(void*)&button,20);
     a6e:	20 e0       	ldi	r18, 0x00	; 0
     a70:	44 e1       	ldi	r20, 0x14	; 20
     a72:	50 e0       	ldi	r21, 0x00	; 0
     a74:	be 01       	movw	r22, r28
     a76:	6f 5f       	subi	r22, 0xFF	; 255
     a78:	7f 4f       	sbci	r23, 0xFF	; 255
     a7a:	80 91 b6 01 	lds	r24, 0x01B6
     a7e:	90 91 b7 01 	lds	r25, 0x01B7
     a82:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
     a86:	ea cf       	rjmp	.-44     	; 0xa5c <vkeypad_task+0x16>
			 }

		}
		else
		{
			vTaskDelay( 50 );
     a88:	82 e3       	ldi	r24, 0x32	; 50
     a8a:	90 e0       	ldi	r25, 0x00	; 0
     a8c:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
     a90:	e5 cf       	rjmp	.-54     	; 0xa5c <vkeypad_task+0x16>

00000a92 <vkeypad_task_q_set>:
	}
}
//----------------------------------------------------------------
void vkeypad_task_q_set(xQueueHandle key)
{
	g_keypad_q=key;
     a92:	90 93 b7 01 	sts	0x01B7, r25
     a96:	80 93 b6 01 	sts	0x01B6, r24
     a9a:	08 95       	ret

00000a9c <xkeypad_task_q_get>:
}
//----------------------------------------------------------------
xQueueHandle xkeypad_task_q_get(void)
{
	return g_keypad_q;
}
     a9c:	80 91 b6 01 	lds	r24, 0x01B6
     aa0:	90 91 b7 01 	lds	r25, 0x01B7
     aa4:	08 95       	ret

00000aa6 <vlcd_task>:

static xSemaphoreHandle g_lcd_task_resume_semaphore=NULL;
static lcd_task_state_t lcd_state=LCD_TASK_INIT_STATE;
//---------------------------------------------------------------------
void vlcd_task(void *pvParameters)
{
     aa6:	cf 93       	push	r28
     aa8:	df 93       	push	r29
     aaa:	cd b7       	in	r28, 0x3d	; 61
     aac:	de b7       	in	r29, 0x3e	; 62
     aae:	68 97       	sbiw	r28, 0x18	; 24
     ab0:	0f b6       	in	r0, 0x3f	; 63
     ab2:	f8 94       	cli
     ab4:	de bf       	out	0x3e, r29	; 62
     ab6:	0f be       	out	0x3f, r0	; 63
     ab8:	cd bf       	out	0x3d, r28	; 61
	portBASE_TYPE que_state;
	u8 invalid_password_count=0;
	u8 led_state=0;
     aba:	19 82       	std	Y+1, r1	; 0x01
	u8 motor_state=0;
     abc:	1a 82       	std	Y+2, r1	; 0x02
	u8 password_index=0;
	u8 id;
	user_t user;
	u8 password_array[MAX_PASSWORD_CHAR]={0,0,0,0};	
     abe:	1c 8a       	std	Y+20, r1	; 0x14
     ac0:	1d 8a       	std	Y+21, r1	; 0x15
     ac2:	1e 8a       	std	Y+22, r1	; 0x16
     ac4:	1f 8a       	std	Y+23, r1	; 0x17
	unsigned char data,index;
	
	//init
	vEcu_LcdInit(&lcd_param);
     ac6:	8d ea       	ldi	r24, 0xAD	; 173
     ac8:	90 e0       	ldi	r25, 0x00	; 0
     aca:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <vEcu_LcdInit>
	lcd_state=LCD_TASK_WELCOME_STATE;
     ace:	81 e0       	ldi	r24, 0x01	; 1
     ad0:	80 93 b8 01 	sts	0x01B8, r24
{
	portBASE_TYPE que_state;
	u8 invalid_password_count=0;
	u8 led_state=0;
	u8 motor_state=0;
	u8 password_index=0;
     ad4:	b1 2c       	mov	r11, r1
static lcd_task_state_t lcd_state=LCD_TASK_INIT_STATE;
//---------------------------------------------------------------------
void vlcd_task(void *pvParameters)
{
	portBASE_TYPE que_state;
	u8 invalid_password_count=0;
     ad6:	e1 2c       	mov	r14, r1
												}
												else
												{
													//time out finished
													vEcu_LcdClearDisplay();
													lcd_state=LCD_TASK_WELCOME_STATE;
     ad8:	ff 24       	eor	r15, r15
     ada:	f3 94       	inc	r15
														//processing
														for(index=0 ;index<MAX_USER_PASSWORD;index++)
														{
															user.password[index]=password_array[index];
														}
														lcd_state=LCD_TASK_CHECK_PASSWORD_STATE;
     adc:	0f 2e       	mov	r0, r31
     ade:	f3 e0       	ldi	r31, 0x03	; 3
     ae0:	df 2e       	mov	r13, r31
     ae2:	f0 2d       	mov	r31, r0
														//decrement index 
														password_index--;
														//check -1 condition
														if(password_index==255)
														{
															password_index=0;
     ae4:	10 e0       	ldi	r17, 0x00	; 0
													vEcu_LcdSendChar(invalid_password_count+'0');
													vTaskDelay(800/ portTICK_PERIOD_MS);
													if(invalid_password_count==LCD_TASK_MAX_INVALID_PASSWORD_COUNT)
													{
														//change the state of led task
														led_state=LED_TASK_ALERT_STATE;
     ae6:	68 94       	set
     ae8:	aa 24       	eor	r10, r10
     aea:	a1 f8       	bld	r10, 1
														xQueueSendToBack(xLed_task_q_get(),(void*)&led_state,20);
														vEcu_LcdClearDisplay();
														u8Ecu_LcdGoToXy(0,5);
														u8Ecu_LcdSendString("LOCKED");
														lcd_state=LCD_TASK_LOCKED_STATE;
     aec:	68 94       	set
     aee:	99 24       	eor	r9, r9
     af0:	92 f8       	bld	r9, 2
	vEcu_LcdInit(&lcd_param);
	lcd_state=LCD_TASK_WELCOME_STATE;
	//do task
	while (1)
	{
		switch(lcd_state)
     af2:	90 91 b8 01 	lds	r25, 0x01B8
     af6:	92 30       	cpi	r25, 0x02	; 2
     af8:	e9 f1       	breq	.+122    	; 0xb74 <vlcd_task+0xce>
     afa:	20 f4       	brcc	.+8      	; 0xb04 <vlcd_task+0x5e>
     afc:	91 30       	cpi	r25, 0x01	; 1
     afe:	09 f0       	breq	.+2      	; 0xb02 <vlcd_task+0x5c>
     b00:	75 c1       	rjmp	.+746    	; 0xdec <vlcd_task+0x346>
     b02:	07 c0       	rjmp	.+14     	; 0xb12 <vlcd_task+0x6c>
     b04:	93 30       	cpi	r25, 0x03	; 3
     b06:	09 f4       	brne	.+2      	; 0xb0a <vlcd_task+0x64>
     b08:	6d c0       	rjmp	.+218    	; 0xbe4 <vlcd_task+0x13e>
     b0a:	94 30       	cpi	r25, 0x04	; 4
     b0c:	09 f0       	breq	.+2      	; 0xb10 <vlcd_task+0x6a>
     b0e:	6e c1       	rjmp	.+732    	; 0xdec <vlcd_task+0x346>
     b10:	51 c1       	rjmp	.+674    	; 0xdb4 <vlcd_task+0x30e>
		{
			case LCD_TASK_WELCOME_STATE :
										//change the state of led task
										led_state=LED_TASK_IDLE_STATE;
     b12:	19 83       	std	Y+1, r17	; 0x01
										xQueueSendToBack(xLed_task_q_get(),(void*)&led_state,20);
     b14:	0e 94 66 07 	call	0xecc	; 0xecc <xLed_task_q_get>
     b18:	21 2f       	mov	r18, r17
     b1a:	44 e1       	ldi	r20, 0x14	; 20
     b1c:	50 e0       	ldi	r21, 0x00	; 0
     b1e:	be 01       	movw	r22, r28
     b20:	6f 5f       	subi	r22, 0xFF	; 255
     b22:	7f 4f       	sbci	r23, 0xFF	; 255
     b24:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
										//print welcome					
										u8Ecu_LcdGoToXy(0,5);
     b28:	65 e0       	ldi	r22, 0x05	; 5
     b2a:	81 2f       	mov	r24, r17
     b2c:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
										u8Ecu_LcdSendString("WELCOME");
     b30:	8a e3       	ldi	r24, 0x3A	; 58
     b32:	91 e0       	ldi	r25, 0x01	; 1
     b34:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
										//block till * and change state to enter state if *
										que_state= xQueueReceive( xkeypad_task_q_get(),&data,portMAX_DELAY);
     b38:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xkeypad_task_q_get>
     b3c:	4f ef       	ldi	r20, 0xFF	; 255
     b3e:	5f ef       	ldi	r21, 0xFF	; 255
     b40:	be 01       	movw	r22, r28
     b42:	68 5e       	subi	r22, 0xE8	; 232
     b44:	7f 4f       	sbci	r23, 0xFF	; 255
     b46:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
										if(que_state ==pdPASS)
     b4a:	81 30       	cpi	r24, 0x01	; 1
     b4c:	09 f0       	breq	.+2      	; 0xb50 <vlcd_task+0xaa>
     b4e:	4e c1       	rjmp	.+668    	; 0xdec <vlcd_task+0x346>
										{
											//print on lcd
											if(data == '#')
     b50:	88 8d       	ldd	r24, Y+24	; 0x18
     b52:	83 32       	cpi	r24, 0x23	; 35
     b54:	09 f0       	breq	.+2      	; 0xb58 <vlcd_task+0xb2>
     b56:	4a c1       	rjmp	.+660    	; 0xdec <vlcd_task+0x346>
											{
												vEcu_LcdClearDisplay();
     b58:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
												u8Ecu_LcdSendString("ENTER PASSWORD:");
     b5c:	82 e4       	ldi	r24, 0x42	; 66
     b5e:	91 e0       	ldi	r25, 0x01	; 1
     b60:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
												u8Ecu_LcdGoToXy(1,0);
     b64:	61 2f       	mov	r22, r17
     b66:	8f 2d       	mov	r24, r15
     b68:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
												password_index=0;
												lcd_state=LCD_TASK_ENTER_PASSWORD_STATE;
     b6c:	a0 92 b8 01 	sts	0x01B8, r10
											if(data == '#')
											{
												vEcu_LcdClearDisplay();
												u8Ecu_LcdSendString("ENTER PASSWORD:");
												u8Ecu_LcdGoToXy(1,0);
												password_index=0;
     b70:	b1 2e       	mov	r11, r17
     b72:	3c c1       	rjmp	.+632    	; 0xdec <vlcd_task+0x346>
											
										}
										break;
			case LCD_TASK_ENTER_PASSWORD_STATE :
												//receive from que and print to lcd if not reciecved till 5 second reset
												que_state= xQueueReceive( xkeypad_task_q_get(),&data,(5000/ portTICK_PERIOD_MS));//portMAX_DELAY
     b74:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xkeypad_task_q_get>
     b78:	48 e8       	ldi	r20, 0x88	; 136
     b7a:	53 e1       	ldi	r21, 0x13	; 19
     b7c:	be 01       	movw	r22, r28
     b7e:	68 5e       	subi	r22, 0xE8	; 232
     b80:	7f 4f       	sbci	r23, 0xFF	; 255
     b82:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
												if(que_state ==pdPASS)
     b86:	81 30       	cpi	r24, 0x01	; 1
     b88:	41 f5       	brne	.+80     	; 0xbda <vlcd_task+0x134>
												{
												//print on lcd
													if(data == '*')
     b8a:	88 8d       	ldd	r24, Y+24	; 0x18
     b8c:	8a 32       	cpi	r24, 0x2A	; 42
     b8e:	41 f4       	brne	.+16     	; 0xba0 <vlcd_task+0xfa>
													{
														//decrement index 
														password_index--;
     b90:	ba 94       	dec	r11
														//check -1 condition
														if(password_index==255)
     b92:	8f ef       	ldi	r24, 0xFF	; 255
     b94:	b8 16       	cp	r11, r24
     b96:	09 f4       	brne	.+2      	; 0xb9a <vlcd_task+0xf4>
     b98:	28 c1       	rjmp	.+592    	; 0xdea <vlcd_task+0x344>
														{
															password_index=0;
														}
														else
														{	//clear last char if any
															vEcu_LcdRemovePassword();
     b9a:	0e 94 24 1b 	call	0x3648	; 0x3648 <vEcu_LcdRemovePassword>
     b9e:	26 c1       	rjmp	.+588    	; 0xdec <vlcd_task+0x346>
														}
													}
													else if(data == '#')
     ba0:	83 32       	cpi	r24, 0x23	; 35
     ba2:	59 f4       	brne	.+22     	; 0xbba <vlcd_task+0x114>
													{
														//processing
														for(index=0 ;index<MAX_USER_PASSWORD;index++)
														{
															user.password[index]=password_array[index];
     ba4:	8c 89       	ldd	r24, Y+20	; 0x14
     ba6:	8e 87       	std	Y+14, r24	; 0x0e
     ba8:	8d 89       	ldd	r24, Y+21	; 0x15
     baa:	8f 87       	std	Y+15, r24	; 0x0f
     bac:	8e 89       	ldd	r24, Y+22	; 0x16
     bae:	88 8b       	std	Y+16, r24	; 0x10
     bb0:	8f 89       	ldd	r24, Y+23	; 0x17
     bb2:	89 8b       	std	Y+17, r24	; 0x11
														}
														lcd_state=LCD_TASK_CHECK_PASSWORD_STATE;
     bb4:	d0 92 b8 01 	sts	0x01B8, r13
     bb8:	19 c1       	rjmp	.+562    	; 0xdec <vlcd_task+0x346>
													}
													else
													{
														//any char
														if((password_index >=0) && (password_index <MAX_PASSWORD_CHAR))
     bba:	93 e0       	ldi	r25, 0x03	; 3
     bbc:	9b 15       	cp	r25, r11
     bbe:	08 f4       	brcc	.+2      	; 0xbc2 <vlcd_task+0x11c>
     bc0:	15 c1       	rjmp	.+554    	; 0xdec <vlcd_task+0x346>
														{
															vEcu_LcdSendPassword(data);
     bc2:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <vEcu_LcdSendPassword>
															//save pass
															password_array[password_index]=data;
     bc6:	e4 e1       	ldi	r30, 0x14	; 20
     bc8:	f0 e0       	ldi	r31, 0x00	; 0
     bca:	ec 0f       	add	r30, r28
     bcc:	fd 1f       	adc	r31, r29
     bce:	eb 0d       	add	r30, r11
     bd0:	f1 1d       	adc	r31, r1
     bd2:	88 8d       	ldd	r24, Y+24	; 0x18
     bd4:	80 83       	st	Z, r24
															//increment index
															password_index++;
     bd6:	b3 94       	inc	r11
     bd8:	09 c1       	rjmp	.+530    	; 0xdec <vlcd_task+0x346>
													}
												}
												else
												{
													//time out finished
													vEcu_LcdClearDisplay();
     bda:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
													lcd_state=LCD_TASK_WELCOME_STATE;
     bde:	f0 92 b8 01 	sts	0x01B8, r15
     be2:	04 c1       	rjmp	.+520    	; 0xdec <vlcd_task+0x346>
												}
												break;																											
			case LCD_TASK_CHECK_PASSWORD_STATE :
												//que_state= xQueueReceive( xpassword_check_task_q_get(),&password_check,portMAX_DELAY);
												xSemaphoreTake(i2c_mutex,portMAX_DELAY);
     be4:	6f ef       	ldi	r22, 0xFF	; 255
     be6:	7f ef       	ldi	r23, 0xFF	; 255
     be8:	80 91 2d 08 	lds	r24, 0x082D
     bec:	90 91 2e 08 	lds	r25, 0x082E
     bf0:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
												data=u8EXTERNAL_EEPROM_search_by_password(user.password,user.name,&id,&(user.type));
     bf4:	9e 01       	movw	r18, r28
     bf6:	2e 5e       	subi	r18, 0xEE	; 238
     bf8:	3f 4f       	sbci	r19, 0xFF	; 255
     bfa:	ae 01       	movw	r20, r28
     bfc:	4d 5f       	subi	r20, 0xFD	; 253
     bfe:	5f 4f       	sbci	r21, 0xFF	; 255
     c00:	be 01       	movw	r22, r28
     c02:	6c 5f       	subi	r22, 0xFC	; 252
     c04:	7f 4f       	sbci	r23, 0xFF	; 255
     c06:	ce 01       	movw	r24, r28
     c08:	0e 96       	adiw	r24, 0x0e	; 14
     c0a:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <u8EXTERNAL_EEPROM_search_by_password>
     c0e:	88 8f       	std	Y+24, r24	; 0x18
												xSemaphoreGive(i2c_mutex);
     c10:	21 2f       	mov	r18, r17
     c12:	40 e0       	ldi	r20, 0x00	; 0
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	60 e0       	ldi	r22, 0x00	; 0
     c18:	70 e0       	ldi	r23, 0x00	; 0
     c1a:	80 91 2d 08 	lds	r24, 0x082D
     c1e:	90 91 2e 08 	lds	r25, 0x082E
     c22:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
												if(data ==PASSWORD_FOUND)
     c26:	88 8d       	ldd	r24, Y+24	; 0x18
     c28:	81 11       	cpse	r24, r1
     c2a:	6e c0       	rjmp	.+220    	; 0xd08 <vlcd_task+0x262>
												{
													//valid password
													vEcu_LcdClearDisplay();
     c2c:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
													u8Ecu_LcdGoToXy(0,0);
     c30:	61 2f       	mov	r22, r17
     c32:	81 2f       	mov	r24, r17
     c34:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
													u8Ecu_LcdSendString("WELCOME");
     c38:	8a e3       	ldi	r24, 0x3A	; 58
     c3a:	91 e0       	ldi	r25, 0x01	; 1
     c3c:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
													u8Ecu_LcdGoToXy(1,5);
     c40:	65 e0       	ldi	r22, 0x05	; 5
     c42:	8f 2d       	mov	r24, r15
     c44:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
													u8Ecu_LcdSendString((char * )user.name);
     c48:	ce 01       	movw	r24, r28
     c4a:	04 96       	adiw	r24, 0x04	; 4
     c4c:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
													vTaskDelay(1500 / portTICK_PERIOD_MS);
     c50:	8c ed       	ldi	r24, 0xDC	; 220
     c52:	95 e0       	ldi	r25, 0x05	; 5
     c54:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
													//change the state of led task
													led_state=LED_TASK_GARAGE_OPENED_STATE;
     c58:	f9 82       	std	Y+1, r15	; 0x01
													xQueueSendToBack(xLed_task_q_get(),(void*)&led_state,20);
     c5a:	0e 94 66 07 	call	0xecc	; 0xecc <xLed_task_q_get>
     c5e:	21 2f       	mov	r18, r17
     c60:	44 e1       	ldi	r20, 0x14	; 20
     c62:	50 e0       	ldi	r21, 0x00	; 0
     c64:	be 01       	movw	r22, r28
     c66:	6f 5f       	subi	r22, 0xFF	; 255
     c68:	7f 4f       	sbci	r23, 0xFF	; 255
     c6a:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
													//signal the log task to log
													xQueueSendToBack(xLog_task_q_get(),(void*)&user,20);
     c6e:	0e 94 77 08 	call	0x10ee	; 0x10ee <xLog_task_q_get>
     c72:	21 2f       	mov	r18, r17
     c74:	44 e1       	ldi	r20, 0x14	; 20
     c76:	50 e0       	ldi	r21, 0x00	; 0
     c78:	be 01       	movw	r22, r28
     c7a:	6c 5f       	subi	r22, 0xFC	; 252
     c7c:	7f 4f       	sbci	r23, 0xFF	; 255
     c7e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
													
													
													//signal motor task and wait till finish
													motor_state=MOTOR_TASK_OPENING_GARAGE_STATE;
     c82:	fa 82       	std	Y+2, r15	; 0x02
													xQueueSendToBack(xMotor_task_q_get(),(void*)&motor_state,20);
     c84:	0e 94 6d 09 	call	0x12da	; 0x12da <xMotor_task_q_get>
     c88:	21 2f       	mov	r18, r17
     c8a:	44 e1       	ldi	r20, 0x14	; 20
     c8c:	50 e0       	ldi	r21, 0x00	; 0
     c8e:	be 01       	movw	r22, r28
     c90:	6e 5f       	subi	r22, 0xFE	; 254
     c92:	7f 4f       	sbci	r23, 0xFF	; 255
     c94:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
													vEcu_LcdClearDisplay();
     c98:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
													u8Ecu_LcdGoToXy(0,5);
     c9c:	65 e0       	ldi	r22, 0x05	; 5
     c9e:	81 2f       	mov	r24, r17
     ca0:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
													u8Ecu_LcdSendString("OPENINIG");
     ca4:	82 e5       	ldi	r24, 0x52	; 82
     ca6:	91 e0       	ldi	r25, 0x01	; 1
     ca8:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
																										 
													vTaskDelay(OPENING_GARAGE_DELAY / portTICK_PERIOD_MS);
     cac:	88 e8       	ldi	r24, 0x88	; 136
     cae:	93 e1       	ldi	r25, 0x13	; 19
     cb0:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
													
													motor_state=MOTOR_TASK_CLOSING_GARAGE_STATE;
     cb4:	da 82       	std	Y+2, r13	; 0x02
													xQueueSendToBack(xMotor_task_q_get(),(void*)&motor_state,20);
     cb6:	0e 94 6d 09 	call	0x12da	; 0x12da <xMotor_task_q_get>
     cba:	21 2f       	mov	r18, r17
     cbc:	44 e1       	ldi	r20, 0x14	; 20
     cbe:	50 e0       	ldi	r21, 0x00	; 0
     cc0:	be 01       	movw	r22, r28
     cc2:	6e 5f       	subi	r22, 0xFE	; 254
     cc4:	7f 4f       	sbci	r23, 0xFF	; 255
     cc6:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
													vEcu_LcdClearDisplay();
     cca:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
													u8Ecu_LcdGoToXy(0,5);
     cce:	65 e0       	ldi	r22, 0x05	; 5
     cd0:	81 2f       	mov	r24, r17
     cd2:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
													u8Ecu_LcdSendString("CLOSING");	
     cd6:	8b e5       	ldi	r24, 0x5B	; 91
     cd8:	91 e0       	ldi	r25, 0x01	; 1
     cda:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
																									
													vTaskDelay(CLOSING_GARAGE_DELAY / portTICK_PERIOD_MS);
     cde:	88 e8       	ldi	r24, 0x88	; 136
     ce0:	93 e1       	ldi	r25, 0x13	; 19
     ce2:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
													
													motor_state=MOTOR_TASK_CLOSED_STATE;
     ce6:	1a 83       	std	Y+2, r17	; 0x02
													xQueueSendToBack(xMotor_task_q_get(),(void*)&motor_state,20);													
     ce8:	0e 94 6d 09 	call	0x12da	; 0x12da <xMotor_task_q_get>
     cec:	21 2f       	mov	r18, r17
     cee:	44 e1       	ldi	r20, 0x14	; 20
     cf0:	50 e0       	ldi	r21, 0x00	; 0
     cf2:	be 01       	movw	r22, r28
     cf4:	6e 5f       	subi	r22, 0xFE	; 254
     cf6:	7f 4f       	sbci	r23, 0xFF	; 255
     cf8:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
													invalid_password_count=0;
													vEcu_LcdClearDisplay();
     cfc:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
													lcd_state=LCD_TASK_WELCOME_STATE;
     d00:	f0 92 b8 01 	sts	0x01B8, r15
																									
													vTaskDelay(CLOSING_GARAGE_DELAY / portTICK_PERIOD_MS);
													
													motor_state=MOTOR_TASK_CLOSED_STATE;
													xQueueSendToBack(xMotor_task_q_get(),(void*)&motor_state,20);													
													invalid_password_count=0;
     d04:	e1 2e       	mov	r14, r17
     d06:	72 c0       	rjmp	.+228    	; 0xdec <vlcd_task+0x346>
													lcd_state=LCD_TASK_WELCOME_STATE;
												}
												else
												{
													//invalid password
													invalid_password_count++;
     d08:	ce 2c       	mov	r12, r14
     d0a:	c3 94       	inc	r12
													//change the state of led task
													//signal the log task to log
													//change user type to undefined type
													user.type=INVALID_USER;
     d0c:	da 8a       	std	Y+18, r13	; 0x12
													xQueueSendToBack(xLog_task_q_get(),(void*)&user,20);
     d0e:	0e 94 77 08 	call	0x10ee	; 0x10ee <xLog_task_q_get>
     d12:	21 2f       	mov	r18, r17
     d14:	44 e1       	ldi	r20, 0x14	; 20
     d16:	50 e0       	ldi	r21, 0x00	; 0
     d18:	be 01       	movw	r22, r28
     d1a:	6c 5f       	subi	r22, 0xFC	; 252
     d1c:	7f 4f       	sbci	r23, 0xFF	; 255
     d1e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
     d22:	0d 2d       	mov	r16, r13
													//change lcd data
													for(index=0;index<3;index++)
													{
														vEcu_LcdClearDisplay();
     d24:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
														u8Ecu_LcdGoToXy(0,0);
     d28:	61 2f       	mov	r22, r17
     d2a:	81 2f       	mov	r24, r17
     d2c:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
														u8Ecu_LcdSendString("INVALID PASSWORD");
     d30:	83 e6       	ldi	r24, 0x63	; 99
     d32:	91 e0       	ldi	r25, 0x01	; 1
     d34:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
														vTaskDelay(800/ portTICK_PERIOD_MS);
     d38:	80 e2       	ldi	r24, 0x20	; 32
     d3a:	93 e0       	ldi	r25, 0x03	; 3
     d3c:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
     d40:	01 50       	subi	r16, 0x01	; 1
													//signal the log task to log
													//change user type to undefined type
													user.type=INVALID_USER;
													xQueueSendToBack(xLog_task_q_get(),(void*)&user,20);
													//change lcd data
													for(index=0;index<3;index++)
     d42:	81 f7       	brne	.-32     	; 0xd24 <vlcd_task+0x27e>
														vEcu_LcdClearDisplay();
														u8Ecu_LcdGoToXy(0,0);
														u8Ecu_LcdSendString("INVALID PASSWORD");
														vTaskDelay(800/ portTICK_PERIOD_MS);
													}				
													vEcu_LcdClearDisplay();
     d44:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
													u8Ecu_LcdGoToXy(0,1);
     d48:	6f 2d       	mov	r22, r15
     d4a:	81 2f       	mov	r24, r17
     d4c:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
													u8Ecu_LcdSendString("WRONG ENTRY");
     d50:	84 e7       	ldi	r24, 0x74	; 116
     d52:	91 e0       	ldi	r25, 0x01	; 1
     d54:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
													u8Ecu_LcdGoToXy(0,13);
     d58:	6d e0       	ldi	r22, 0x0D	; 13
     d5a:	81 2f       	mov	r24, r17
     d5c:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
													vEcu_LcdSendChar(invalid_password_count+'0');
     d60:	8e 2d       	mov	r24, r14
     d62:	8f 5c       	subi	r24, 0xCF	; 207
     d64:	0e 94 a6 1a 	call	0x354c	; 0x354c <vEcu_LcdSendChar>
													vTaskDelay(800/ portTICK_PERIOD_MS);
     d68:	80 e2       	ldi	r24, 0x20	; 32
     d6a:	93 e0       	ldi	r25, 0x03	; 3
     d6c:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
													if(invalid_password_count==LCD_TASK_MAX_INVALID_PASSWORD_COUNT)
     d70:	83 e0       	ldi	r24, 0x03	; 3
     d72:	c8 12       	cpse	r12, r24
     d74:	19 c0       	rjmp	.+50     	; 0xda8 <vlcd_task+0x302>
													{
														//change the state of led task
														led_state=LED_TASK_ALERT_STATE;
     d76:	a9 82       	std	Y+1, r10	; 0x01
														xQueueSendToBack(xLed_task_q_get(),(void*)&led_state,20);
     d78:	0e 94 66 07 	call	0xecc	; 0xecc <xLed_task_q_get>
     d7c:	21 2f       	mov	r18, r17
     d7e:	44 e1       	ldi	r20, 0x14	; 20
     d80:	50 e0       	ldi	r21, 0x00	; 0
     d82:	be 01       	movw	r22, r28
     d84:	6f 5f       	subi	r22, 0xFF	; 255
     d86:	7f 4f       	sbci	r23, 0xFF	; 255
     d88:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
														vEcu_LcdClearDisplay();
     d8c:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
														u8Ecu_LcdGoToXy(0,5);
     d90:	65 e0       	ldi	r22, 0x05	; 5
     d92:	81 2f       	mov	r24, r17
     d94:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <u8Ecu_LcdGoToXy>
														u8Ecu_LcdSendString("LOCKED");
     d98:	80 e8       	ldi	r24, 0x80	; 128
     d9a:	91 e0       	ldi	r25, 0x01	; 1
     d9c:	0e 94 ab 1a 	call	0x3556	; 0x3556 <u8Ecu_LcdSendString>
														lcd_state=LCD_TASK_LOCKED_STATE;
     da0:	90 92 b8 01 	sts	0x01B8, r9
													lcd_state=LCD_TASK_WELCOME_STATE;
												}
												else
												{
													//invalid password
													invalid_password_count++;
     da4:	ec 2c       	mov	r14, r12
     da6:	22 c0       	rjmp	.+68     	; 0xdec <vlcd_task+0x346>
														lcd_state=LCD_TASK_LOCKED_STATE;
													}
													else
													{
														//invalid password < 3
														vEcu_LcdClearDisplay();
     da8:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
														lcd_state=LCD_TASK_WELCOME_STATE;
     dac:	f0 92 b8 01 	sts	0x01B8, r15
													lcd_state=LCD_TASK_WELCOME_STATE;
												}
												else
												{
													//invalid password
													invalid_password_count++;
     db0:	ec 2c       	mov	r14, r12
     db2:	1c c0       	rjmp	.+56     	; 0xdec <vlcd_task+0x346>
													}
												}
												break;
			case LCD_TASK_LOCKED_STATE :
										//wait to signal from terminal task to return to welcome state
										xSemaphoreTake( g_lcd_task_resume_semaphore,portMAX_DELAY);
     db4:	6f ef       	ldi	r22, 0xFF	; 255
     db6:	7f ef       	ldi	r23, 0xFF	; 255
     db8:	80 91 b9 01 	lds	r24, 0x01B9
     dbc:	90 91 ba 01 	lds	r25, 0x01BA
     dc0:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
										invalid_password_count=0;
										vEcu_LcdClearDisplay();
     dc4:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vEcu_LcdClearDisplay>
										vTaskDelay(500/portTICK_PERIOD_MS);
     dc8:	84 ef       	ldi	r24, 0xF4	; 244
     dca:	91 e0       	ldi	r25, 0x01	; 1
     dcc:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
										xQueueReceive( xkeypad_task_q_get(),&data,0);
     dd0:	0e 94 4e 05 	call	0xa9c	; 0xa9c <xkeypad_task_q_get>
     dd4:	40 e0       	ldi	r20, 0x00	; 0
     dd6:	50 e0       	ldi	r21, 0x00	; 0
     dd8:	be 01       	movw	r22, r28
     dda:	68 5e       	subi	r22, 0xE8	; 232
     ddc:	7f 4f       	sbci	r23, 0xFF	; 255
     dde:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
										lcd_state=LCD_TASK_WELCOME_STATE;
     de2:	f0 92 b8 01 	sts	0x01B8, r15
												}
												break;
			case LCD_TASK_LOCKED_STATE :
										//wait to signal from terminal task to return to welcome state
										xSemaphoreTake( g_lcd_task_resume_semaphore,portMAX_DELAY);
										invalid_password_count=0;
     de6:	e1 2e       	mov	r14, r17
										vEcu_LcdClearDisplay();
										vTaskDelay(500/portTICK_PERIOD_MS);
										xQueueReceive( xkeypad_task_q_get(),&data,0);
										lcd_state=LCD_TASK_WELCOME_STATE;
										break;						
     de8:	01 c0       	rjmp	.+2      	; 0xdec <vlcd_task+0x346>
														//decrement index 
														password_index--;
														//check -1 condition
														if(password_index==255)
														{
															password_index=0;
     dea:	b1 2e       	mov	r11, r17
										lcd_state=LCD_TASK_WELCOME_STATE;
										break;						
			default:break;
		}

		vTaskDelay( 50 );
     dec:	82 e3       	ldi	r24, 0x32	; 50
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
	
	}
     df4:	7e ce       	rjmp	.-772    	; 0xaf2 <vlcd_task+0x4c>

00000df6 <vlcd_task_resume_semaphore_set>:
	return g_lcd_q;
}
//----------------------------------------------------
void vlcd_task_resume_semaphore_set(xSemaphoreHandle key)
{
	g_lcd_task_resume_semaphore=key;
     df6:	90 93 ba 01 	sts	0x01BA, r25
     dfa:	80 93 b9 01 	sts	0x01B9, r24
     dfe:	08 95       	ret

00000e00 <xlcd_task_resume_semaphore_get>:
}
//-----------------------------------------------------
xSemaphoreHandle xlcd_task_resume_semaphore_get(void)
{
	return g_lcd_task_resume_semaphore;
}
     e00:	80 91 b9 01 	lds	r24, 0x01B9
     e04:	90 91 ba 01 	lds	r25, 0x01BA
     e08:	08 95       	ret

00000e0a <xlcd_task_get_state>:
//--------------------------------------------
lcd_task_state_t xlcd_task_get_state(void)
{
	return lcd_state;
     e0a:	80 91 b8 01 	lds	r24, 0x01B8
     e0e:	08 95       	ret

00000e10 <vled_task>:
#include "led_task.h"
//---------------------------------------------------------------
static xQueueHandle g_led_task_q;
//----------------------------------------------------------------
void vled_task(void *pvParameters)
{
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	1f 92       	push	r1
     e16:	cd b7       	in	r28, 0x3d	; 61
     e18:	de b7       	in	r29, 0x3e	; 62
	led_task_state_t led_state=LED_TASK_IDLE_STATE;
	portBASE_TYPE que_state;
	u8 data;
	//init led and buzzer
	vEcu_led_init(&green_led_param);
     e1a:	84 ed       	ldi	r24, 0xD4	; 212
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	0e 94 2e 1b 	call	0x365c	; 0x365c <vEcu_led_init>
	vEcu_led_init(&red_led_param);
     e22:	81 ed       	ldi	r24, 0xD1	; 209
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	0e 94 2e 1b 	call	0x365c	; 0x365c <vEcu_led_init>
	vEcu_Buzzer_init(&buzzer_param);
     e2a:	89 e7       	ldi	r24, 0x79	; 121
     e2c:	90 e0       	ldi	r25, 0x00	; 0
     e2e:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <vEcu_Buzzer_init>
//---------------------------------------------------------------
static xQueueHandle g_led_task_q;
//----------------------------------------------------------------
void vled_task(void *pvParameters)
{
	led_task_state_t led_state=LED_TASK_IDLE_STATE;
     e32:	10 e0       	ldi	r17, 0x00	; 0
	vEcu_led_init(&red_led_param);
	vEcu_Buzzer_init(&buzzer_param);
	while(1)
	{
		//receive from que if any and set state
		que_state= xQueueReceive(g_led_task_q,&data,0);
     e34:	40 e0       	ldi	r20, 0x00	; 0
     e36:	50 e0       	ldi	r21, 0x00	; 0
     e38:	be 01       	movw	r22, r28
     e3a:	6f 5f       	subi	r22, 0xFF	; 255
     e3c:	7f 4f       	sbci	r23, 0xFF	; 255
     e3e:	80 91 bd 01 	lds	r24, 0x01BD
     e42:	90 91 be 01 	lds	r25, 0x01BE
     e46:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
		if(que_state ==pdPASS)
     e4a:	81 30       	cpi	r24, 0x01	; 1
     e4c:	09 f4       	brne	.+2      	; 0xe50 <vled_task+0x40>
		{
			led_state=data;
     e4e:	19 81       	ldd	r17, Y+1	; 0x01
		}
		//switch state 
		switch(led_state)
     e50:	11 30       	cpi	r17, 0x01	; 1
     e52:	a9 f0       	breq	.+42     	; 0xe7e <vled_task+0x6e>
     e54:	18 f0       	brcs	.+6      	; 0xe5c <vled_task+0x4c>
     e56:	12 30       	cpi	r17, 0x02	; 2
     e58:	69 f7       	brne	.-38     	; 0xe34 <vled_task+0x24>
     e5a:	22 c0       	rjmp	.+68     	; 0xea0 <vled_task+0x90>
		{
			case LED_TASK_IDLE_STATE :
												//toggle green led every 500 ms
												vEcu_toggle_led(&green_led_param);
     e5c:	84 ed       	ldi	r24, 0xD4	; 212
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <vEcu_toggle_led>
												//clear led red 
												vEcu_set_led_off(&red_led_param);
     e64:	81 ed       	ldi	r24, 0xD1	; 209
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	0e 94 4e 1b 	call	0x369c	; 0x369c <vEcu_set_led_off>
												//buzzer stop
												vEcu_Buzzer_stop(&buzzer_param);
     e6c:	89 e7       	ldi	r24, 0x79	; 121
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vEcu_Buzzer_stop>
												vTaskDelay(2000);
     e74:	80 ed       	ldi	r24, 0xD0	; 208
     e76:	97 e0       	ldi	r25, 0x07	; 7
     e78:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
												break;	
     e7c:	db cf       	rjmp	.-74     	; 0xe34 <vled_task+0x24>
			case LED_TASK_GARAGE_OPENED_STATE :
												//toggle green led
												vEcu_toggle_led(&green_led_param); 
     e7e:	84 ed       	ldi	r24, 0xD4	; 212
     e80:	90 e0       	ldi	r25, 0x00	; 0
     e82:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <vEcu_toggle_led>
												//set red led on
												vEcu_set_led_on(&red_led_param);
     e86:	81 ed       	ldi	r24, 0xD1	; 209
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	0e 94 48 1b 	call	0x3690	; 0x3690 <vEcu_set_led_on>
												//buzzer stop
												vEcu_Buzzer_stop(&buzzer_param);
     e8e:	89 e7       	ldi	r24, 0x79	; 121
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 20 17 	call	0x2e40	; 0x2e40 <vEcu_Buzzer_stop>
												vTaskDelay(1000);
     e96:	88 ee       	ldi	r24, 0xE8	; 232
     e98:	93 e0       	ldi	r25, 0x03	; 3
     e9a:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
												break;
     e9e:	ca cf       	rjmp	.-108    	; 0xe34 <vled_task+0x24>
			case LED_TASK_ALERT_STATE :
												//set green led off
												vEcu_set_led_off(&green_led_param);
     ea0:	84 ed       	ldi	r24, 0xD4	; 212
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	0e 94 4e 1b 	call	0x369c	; 0x369c <vEcu_set_led_off>
												//toggle red_led
												vEcu_toggle_led(&red_led_param);
     ea8:	81 ed       	ldi	r24, 0xD1	; 209
     eaa:	90 e0       	ldi	r25, 0x00	; 0
     eac:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <vEcu_toggle_led>
												//alert buzzer
												vEcu_Buzzer_toggle(&buzzer_param);
     eb0:	89 e7       	ldi	r24, 0x79	; 121
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <vEcu_Buzzer_toggle>
												vTaskDelay(500);
     eb8:	84 ef       	ldi	r24, 0xF4	; 244
     eba:	91 e0       	ldi	r25, 0x01	; 1
     ebc:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
												break;
     ec0:	b9 cf       	rjmp	.-142    	; 0xe34 <vled_task+0x24>

00000ec2 <vLed_task_q_set>:
	}
}
//-----------------------------------------------------------------
void vLed_task_q_set(xQueueHandle key)
{
	 g_led_task_q=key;
     ec2:	90 93 be 01 	sts	0x01BE, r25
     ec6:	80 93 bd 01 	sts	0x01BD, r24
     eca:	08 95       	ret

00000ecc <xLed_task_q_get>:
}
//-----------------------------------------------------
xQueueHandle xLed_task_q_get(void)
{
	return  g_led_task_q;
}
     ecc:	80 91 bd 01 	lds	r24, 0x01BD
     ed0:	90 91 be 01 	lds	r25, 0x01BE
     ed4:	08 95       	ret

00000ed6 <send_time>:
{
	return g_log_q;
}
//-------------------------------------------------------
void send_time(void)
{
     ed6:	0f 93       	push	r16
     ed8:	1f 93       	push	r17
     eda:	cf 93       	push	r28
     edc:	df 93       	push	r29
	vUartTransmit(time.hours.h12.second_digit + '0');
     ede:	c1 ec       	ldi	r28, 0xC1	; 193
     ee0:	d1 e0       	ldi	r29, 0x01	; 1
     ee2:	88 81       	ld	r24, Y
     ee4:	82 95       	swap	r24
     ee6:	81 70       	andi	r24, 0x01	; 1
     ee8:	80 5d       	subi	r24, 0xD0	; 208
     eea:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.hours.h12.first_digit + '0');
     eee:	88 81       	ld	r24, Y
     ef0:	8f 70       	andi	r24, 0x0F	; 15
     ef2:	80 5d       	subi	r24, 0xD0	; 208
     ef4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(':');
     ef8:	8a e3       	ldi	r24, 0x3A	; 58
     efa:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.minutes.bcd_data.second_digit + '0');
     efe:	00 ec       	ldi	r16, 0xC0	; 192
     f00:	11 e0       	ldi	r17, 0x01	; 1
     f02:	f8 01       	movw	r30, r16
     f04:	80 81       	ld	r24, Z
     f06:	82 95       	swap	r24
     f08:	8f 70       	andi	r24, 0x0F	; 15
     f0a:	87 70       	andi	r24, 0x07	; 7
     f0c:	80 5d       	subi	r24, 0xD0	; 208
     f0e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.minutes.bcd_data.first_digit + '0');
     f12:	f8 01       	movw	r30, r16
     f14:	80 81       	ld	r24, Z
     f16:	8f 70       	andi	r24, 0x0F	; 15
     f18:	80 5d       	subi	r24, 0xD0	; 208
     f1a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(':');
     f1e:	8a e3       	ldi	r24, 0x3A	; 58
     f20:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.seconds.bcd_data.second_digit + '0');
     f24:	0f eb       	ldi	r16, 0xBF	; 191
     f26:	11 e0       	ldi	r17, 0x01	; 1
     f28:	f8 01       	movw	r30, r16
     f2a:	80 81       	ld	r24, Z
     f2c:	82 95       	swap	r24
     f2e:	8f 70       	andi	r24, 0x0F	; 15
     f30:	87 70       	andi	r24, 0x07	; 7
     f32:	80 5d       	subi	r24, 0xD0	; 208
     f34:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.seconds.bcd_data.first_digit + '0');
     f38:	f8 01       	movw	r30, r16
     f3a:	80 81       	ld	r24, Z
     f3c:	8f 70       	andi	r24, 0x0F	; 15
     f3e:	80 5d       	subi	r24, 0xD0	; 208
     f40:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	if(time.hours.h12.SELECT_AM_PM ==RTC_AM)
     f44:	88 81       	ld	r24, Y
     f46:	85 fd       	sbrc	r24, 5
     f48:	0a c0       	rjmp	.+20     	; 0xf5e <send_time+0x88>
	{
		vUartTransmit(' ');
     f4a:	80 e2       	ldi	r24, 0x20	; 32
     f4c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmit('A');
     f50:	81 e4       	ldi	r24, 0x41	; 65
     f52:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmit('M');
     f56:	8d e4       	ldi	r24, 0x4D	; 77
     f58:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
     f5c:	09 c0       	rjmp	.+18     	; 0xf70 <send_time+0x9a>
	}
	else
	{
		vUartTransmit(' ');
     f5e:	80 e2       	ldi	r24, 0x20	; 32
     f60:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmit('P');
     f64:	80 e5       	ldi	r24, 0x50	; 80
     f66:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmit('M');
     f6a:	8d e4       	ldi	r24, 0x4D	; 77
     f6c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	}
	vUartTransmit(' ');
     f70:	80 e2       	ldi	r24, 0x20	; 32
     f72:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.date.bcd_data.second_digit + '0');
     f76:	c3 ec       	ldi	r28, 0xC3	; 195
     f78:	d1 e0       	ldi	r29, 0x01	; 1
     f7a:	88 81       	ld	r24, Y
     f7c:	82 95       	swap	r24
     f7e:	8f 70       	andi	r24, 0x0F	; 15
     f80:	83 70       	andi	r24, 0x03	; 3
     f82:	80 5d       	subi	r24, 0xD0	; 208
     f84:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.date.bcd_data.first_digit + '0');
     f88:	88 81       	ld	r24, Y
     f8a:	8f 70       	andi	r24, 0x0F	; 15
     f8c:	80 5d       	subi	r24, 0xD0	; 208
     f8e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit('-');
     f92:	8d e2       	ldi	r24, 0x2D	; 45
     f94:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.month.bcd_data.second_digit + '0');
     f98:	c4 ec       	ldi	r28, 0xC4	; 196
     f9a:	d1 e0       	ldi	r29, 0x01	; 1
     f9c:	88 81       	ld	r24, Y
     f9e:	82 95       	swap	r24
     fa0:	81 70       	andi	r24, 0x01	; 1
     fa2:	80 5d       	subi	r24, 0xD0	; 208
     fa4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.month.bcd_data.first_digit + '0');
     fa8:	88 81       	ld	r24, Y
     faa:	8f 70       	andi	r24, 0x0F	; 15
     fac:	80 5d       	subi	r24, 0xD0	; 208
     fae:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit('-');
     fb2:	8d e2       	ldi	r24, 0x2D	; 45
     fb4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.year.bcd_data.second_digit + '0');
     fb8:	c5 ec       	ldi	r28, 0xC5	; 197
     fba:	d1 e0       	ldi	r29, 0x01	; 1
     fbc:	88 81       	ld	r24, Y
     fbe:	82 95       	swap	r24
     fc0:	8f 70       	andi	r24, 0x0F	; 15
     fc2:	80 5d       	subi	r24, 0xD0	; 208
     fc4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(time.year.bcd_data.first_digit + '0');
     fc8:	88 81       	ld	r24, Y
     fca:	8f 70       	andi	r24, 0x0F	; 15
     fcc:	80 5d       	subi	r24, 0xD0	; 208
     fce:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(ENTER_KEY);
     fd2:	8d e0       	ldi	r24, 0x0D	; 13
     fd4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
}
     fd8:	df 91       	pop	r29
     fda:	cf 91       	pop	r28
     fdc:	1f 91       	pop	r17
     fde:	0f 91       	pop	r16
     fe0:	08 95       	ret

00000fe2 <vLog_task>:
//-------------------------------------------------------------------
static void send_time(void);
static rtc_time_t time;
//-------------------------------------------------------------------
void vLog_task(void *pvParameters)
{
     fe2:	cf 93       	push	r28
     fe4:	df 93       	push	r29
     fe6:	cd b7       	in	r28, 0x3d	; 61
     fe8:	de b7       	in	r29, 0x3e	; 62
     fea:	60 97       	sbiw	r28, 0x10	; 16
     fec:	0f b6       	in	r0, 0x3f	; 63
     fee:	f8 94       	cli
     ff0:	de bf       	out	0x3e, r29	; 62
     ff2:	0f be       	out	0x3f, r0	; 63
     ff4:	cd bf       	out	0x3d, r28	; 61
xQueueHandle g_log_q;
//-------------------------------------------------------------------
static void send_time(void);
static rtc_time_t time;
//-------------------------------------------------------------------
void vLog_task(void *pvParameters)
     ff6:	7e 01       	movw	r14, r28
     ff8:	8a e0       	ldi	r24, 0x0A	; 10
     ffa:	e8 0e       	add	r14, r24
     ffc:	f1 1c       	adc	r15, r1
	u8 index;
	portBASE_TYPE check;
	while(1)
	{
		//receive from que if any and set state
		check=xQueueReceive(g_log_q,&user,portMAX_DELAY);
     ffe:	4f ef       	ldi	r20, 0xFF	; 255
    1000:	5f ef       	ldi	r21, 0xFF	; 255
    1002:	be 01       	movw	r22, r28
    1004:	6f 5f       	subi	r22, 0xFF	; 255
    1006:	7f 4f       	sbci	r23, 0xFF	; 255
    1008:	80 91 29 08 	lds	r24, 0x0829
    100c:	90 91 2a 08 	lds	r25, 0x082A
    1010:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
		if(check !=pdPASS)
    1014:	81 30       	cpi	r24, 0x01	; 1
    1016:	99 f7       	brne	.-26     	; 0xffe <vLog_task+0x1c>
		{
			continue;
		}
		//take uart mutex
		check=xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1018:	6f ef       	ldi	r22, 0xFF	; 255
    101a:	7f ef       	ldi	r23, 0xFF	; 255
    101c:	80 91 2f 08 	lds	r24, 0x082F
    1020:	90 91 30 08 	lds	r25, 0x0830
    1024:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		if(check !=pdPASS)
    1028:	81 30       	cpi	r24, 0x01	; 1
    102a:	49 f7       	brne	.-46     	; 0xffe <vLog_task+0x1c>
		{
			continue;
		}
		//capture time
		check=xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    102c:	6f ef       	ldi	r22, 0xFF	; 255
    102e:	7f ef       	ldi	r23, 0xFF	; 255
    1030:	80 91 2d 08 	lds	r24, 0x082D
    1034:	90 91 2e 08 	lds	r25, 0x082E
    1038:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		if(check !=pdPASS)
    103c:	81 30       	cpi	r24, 0x01	; 1
    103e:	f9 f6       	brne	.-66     	; 0xffe <vLog_task+0x1c>
		{
			continue;
		}
		u8Rtc_Get_Time(&time);
    1040:	8f eb       	ldi	r24, 0xBF	; 191
    1042:	91 e0       	ldi	r25, 0x01	; 1
    1044:	0e 94 9a 20 	call	0x4134	; 0x4134 <u8Rtc_Get_Time>
		xSemaphoreGive(i2c_mutex);
    1048:	20 e0       	ldi	r18, 0x00	; 0
    104a:	40 e0       	ldi	r20, 0x00	; 0
    104c:	50 e0       	ldi	r21, 0x00	; 0
    104e:	60 e0       	ldi	r22, 0x00	; 0
    1050:	70 e0       	ldi	r23, 0x00	; 0
    1052:	80 91 2d 08 	lds	r24, 0x082D
    1056:	90 91 2e 08 	lds	r25, 0x082E
    105a:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		
		vUartTransmit(ENTER_KEY);
    105e:	8d e0       	ldi	r24, 0x0D	; 13
    1060:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		if(user.type ==INVALID_USER)
    1064:	8f 85       	ldd	r24, Y+15	; 0x0f
    1066:	83 30       	cpi	r24, 0x03	; 3
    1068:	21 f0       	breq	.+8      	; 0x1072 <vLog_task+0x90>
		}
		else
		{
			for(index=0 ;index<MAX_USER_NAME ;index++)
			{
				if(user.name[index] == '\0')
    106a:	89 81       	ldd	r24, Y+1	; 0x01
    106c:	81 11       	cpse	r24, r1
    106e:	34 c0       	rjmp	.+104    	; 0x10d8 <vLog_task+0xf6>
    1070:	21 c0       	rjmp	.+66     	; 0x10b4 <vLog_task+0xd2>
		
		vUartTransmit(ENTER_KEY);
		if(user.type ==INVALID_USER)
		{
			//send invalid password with password try to enter
			vUartTransmitString_program(PSTR("SOME ONE WITH PASSWORD "));
    1072:	86 ed       	ldi	r24, 0xD6	; 214
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(user.password[0]);vUartTransmit(user.password[1]);vUartTransmit(user.password[2]);vUartTransmit(user.password[3]);
    107a:	8b 85       	ldd	r24, Y+11	; 0x0b
    107c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    1080:	8c 85       	ldd	r24, Y+12	; 0x0c
    1082:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    1086:	8d 85       	ldd	r24, Y+13	; 0x0d
    1088:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    108c:	8e 85       	ldd	r24, Y+14	; 0x0e
    108e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR(" TRY TO ENTER at "));
    1092:	8e ee       	ldi	r24, 0xEE	; 238
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			send_time();
    109a:	0e 94 6b 07 	call	0xed6	; 0xed6 <send_time>
    109e:	10 c0       	rjmp	.+32     	; 0x10c0 <vLog_task+0xde>
		}
		else
		{
			for(index=0 ;index<MAX_USER_NAME ;index++)
			{
				if(user.name[index] == '\0')
    10a0:	f8 01       	movw	r30, r16
    10a2:	81 91       	ld	r24, Z+
    10a4:	8f 01       	movw	r16, r30
    10a6:	88 23       	and	r24, r24
    10a8:	29 f0       	breq	.+10     	; 0x10b4 <vLog_task+0xd2>
				{
					break;
				}
				vUartTransmit(user.name[index]);
    10aa:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR(" TRY TO ENTER at "));
			send_time();
		}
		else
		{
			for(index=0 ;index<MAX_USER_NAME ;index++)
    10ae:	0e 15       	cp	r16, r14
    10b0:	1f 05       	cpc	r17, r15
    10b2:	b1 f7       	brne	.-20     	; 0x10a0 <vLog_task+0xbe>
				{
					break;
				}
				vUartTransmit(user.name[index]);
			}
			vUartTransmitString_program(PSTR(" ENTER at "));
    10b4:	80 e0       	ldi	r24, 0x00	; 0
    10b6:	91 e0       	ldi	r25, 0x01	; 1
    10b8:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			send_time();
    10bc:	0e 94 6b 07 	call	0xed6	; 0xed6 <send_time>
		}	
		xSemaphoreGive(uart_mutex);
    10c0:	20 e0       	ldi	r18, 0x00	; 0
    10c2:	40 e0       	ldi	r20, 0x00	; 0
    10c4:	50 e0       	ldi	r21, 0x00	; 0
    10c6:	60 e0       	ldi	r22, 0x00	; 0
    10c8:	70 e0       	ldi	r23, 0x00	; 0
    10ca:	80 91 2f 08 	lds	r24, 0x082F
    10ce:	90 91 30 08 	lds	r25, 0x0830
    10d2:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    10d6:	93 cf       	rjmp	.-218    	; 0xffe <vLog_task+0x1c>
			{
				if(user.name[index] == '\0')
				{
					break;
				}
				vUartTransmit(user.name[index]);
    10d8:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    10dc:	8e 01       	movw	r16, r28
    10de:	0e 5f       	subi	r16, 0xFE	; 254
    10e0:	1f 4f       	sbci	r17, 0xFF	; 255
    10e2:	de cf       	rjmp	.-68     	; 0x10a0 <vLog_task+0xbe>

000010e4 <vLog_task_q_set>:
	}
}
//---------------------------------------------------------------------------
void vLog_task_q_set(xQueueHandle key)
{
	g_log_q=key;
    10e4:	90 93 2a 08 	sts	0x082A, r25
    10e8:	80 93 29 08 	sts	0x0829, r24
    10ec:	08 95       	ret

000010ee <xLog_task_q_get>:
}
//-----------------------------------------------------
xQueueHandle xLog_task_q_get(void)
{
	return g_log_q;
}
    10ee:	80 91 29 08 	lds	r24, 0x0829
    10f2:	90 91 2a 08 	lds	r25, 0x082A
    10f6:	08 95       	ret

000010f8 <main>:
    }
}
//-----------------------------------------------------------
static void vCommunication_init(void)
{
	sei();
    10f8:	78 94       	sei
	u8 error=0;
		//init communication
		//init spi
		spi_param.ptr2func=spi_interrupt;
    10fa:	85 e7       	ldi	r24, 0x75	; 117
    10fc:	99 e0       	ldi	r25, 0x09	; 9
    10fe:	90 93 ec 00 	sts	0x00EC, r25
    1102:	80 93 eb 00 	sts	0x00EB, r24
		vSpi_init(&spi_param);
    1106:	85 ee       	ldi	r24, 0xE5	; 229
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	0e 94 ca 25 	call	0x4b94	; 0x4b94 <vSpi_init>
		//i2c init
		u8I2c_Init(&i2c_param);
    110e:	8d e2       	ldi	r24, 0x2D	; 45
    1110:	91 e0       	ldi	r25, 0x01	; 1
    1112:	0e 94 bf 23 	call	0x477e	; 0x477e <u8I2c_Init>
		//init serial
		//set callback
		uart0.rx_ISR=&rx_complete_isr_func;
    1116:	8b ef       	ldi	r24, 0xFB	; 251
    1118:	9d e0       	ldi	r25, 0x0D	; 13
    111a:	90 93 fc 00 	sts	0x00FC, r25
    111e:	80 93 fb 00 	sts	0x00FB, r24
		//init uart
		vUartInit(&uart0);
    1122:	8d ee       	ldi	r24, 0xED	; 237
    1124:	90 e0       	ldi	r25, 0x00	; 0
    1126:	0e 94 63 26 	call	0x4cc6	; 0x4cc6 <vUartInit>
		//init eeprom 
		error=u8Init_MCB();
    112a:	0e 94 6e 1d 	call	0x3adc	; 0x3adc <u8Init_MCB>
		if(error==EEPROM_LOCKED_MC_STATE)
    112e:	82 30       	cpi	r24, 0x02	; 2
    1130:	79 f4       	brne	.+30     	; 0x1150 <main+0x58>
		{
			//lock state
			vUartTransmitString_program(PSTR("SYSTEM LOCKED PLEASE CONTACT THE DEVELOPER "));
    1132:	8b e0       	ldi	r24, 0x0B	; 11
    1134:	91 e0       	ldi	r25, 0x01	; 1
    1136:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);
    113a:	8d e0       	ldi	r24, 0x0D	; 13
    113c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			while(1)
			{
				if(g_unlock_system_flag==1)
    1140:	80 91 c9 01 	lds	r24, 0x01C9
    1144:	81 30       	cpi	r24, 0x01	; 1
    1146:	e1 f7       	brne	.-8      	; 0x1140 <main+0x48>
				{
					vEXTERNAL_EEPROM_unlock_state();
    1148:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <vEXTERNAL_EEPROM_unlock_state>
					g_unlock_system_flag=0;
    114c:	10 92 c9 01 	sts	0x01C9, r1
				}
			}
		}

			//set rtc format to 12 
			u8Rtc_Set_format(RTC_12_FORMAT);
    1150:	81 e0       	ldi	r24, 0x01	; 1
    1152:	0e 94 40 21 	call	0x4280	; 0x4280 <u8Rtc_Set_format>
	
	//init i2c and uart and eeprom and set rtc format to AM/PM
	vCommunication_init();
						
	//CREATE SEMAPHORE
	sem_temp=xSemaphoreCreateBinary();
    1156:	43 e0       	ldi	r20, 0x03	; 3
    1158:	60 e0       	ldi	r22, 0x00	; 0
    115a:	81 e0       	ldi	r24, 0x01	; 1
    115c:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xQueueGenericCreate>
	vlcd_task_resume_semaphore_set(sem_temp);
    1160:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vlcd_task_resume_semaphore_set>
	//create mutex
	uart_mutex=xSemaphoreCreateMutex();
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	0e 94 d0 2b 	call	0x57a0	; 0x57a0 <xQueueCreateMutex>
    116a:	90 93 30 08 	sts	0x0830, r25
    116e:	80 93 2f 08 	sts	0x082F, r24
	i2c_mutex=xSemaphoreCreateMutex();
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	0e 94 d0 2b 	call	0x57a0	; 0x57a0 <xQueueCreateMutex>
    1178:	90 93 2e 08 	sts	0x082E, r25
    117c:	80 93 2d 08 	sts	0x082D, r24
	
	//create keypad queue
	temp=xQueueCreate(KEYPAD_TASK_QUEUE_SIZE,KEYPAD_TASK_QUEUE_DATA_SIZE);
    1180:	40 e0       	ldi	r20, 0x00	; 0
    1182:	61 e0       	ldi	r22, 0x01	; 1
    1184:	81 e0       	ldi	r24, 0x01	; 1
    1186:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xQueueGenericCreate>
	vkeypad_task_q_set(temp);	
    118a:	0e 94 49 05 	call	0xa92	; 0xa92 <vkeypad_task_q_set>
	//create led task queue
	temp=xQueueCreate(LED_TASK_QUEUE_SIZE,LED_TASK_QUEUE_DATA_SIZE);
    118e:	40 e0       	ldi	r20, 0x00	; 0
    1190:	61 e0       	ldi	r22, 0x01	; 1
    1192:	83 e0       	ldi	r24, 0x03	; 3
    1194:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xQueueGenericCreate>
	vLed_task_q_set(temp);
    1198:	0e 94 61 07 	call	0xec2	; 0xec2 <vLed_task_q_set>
	//create motor task queue
	temp=xQueueCreate(MOTOR_TASK_QUEUE_SIZE,MOTOR_TASK_QUEUE_DATA_SIZE);
    119c:	40 e0       	ldi	r20, 0x00	; 0
    119e:	61 e0       	ldi	r22, 0x01	; 1
    11a0:	82 e0       	ldi	r24, 0x02	; 2
    11a2:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xQueueGenericCreate>
	vMotor_task_q_set(temp);
    11a6:	0e 94 68 09 	call	0x12d0	; 0x12d0 <vMotor_task_q_set>
	//create log task queue
	temp=xQueueCreate(LOG_TASK_QUEUE_SIZE,LOG_TASK_QUEUE_DATA_SIZE);
    11aa:	40 e0       	ldi	r20, 0x00	; 0
    11ac:	60 e1       	ldi	r22, 0x10	; 16
    11ae:	82 e0       	ldi	r24, 0x02	; 2
    11b0:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xQueueGenericCreate>
	vLog_task_q_set(temp);
    11b4:	0e 94 72 08 	call	0x10e4	; 0x10e4 <vLog_task_q_set>
	//create terminal task queue
	temp=xQueueCreate(TERMINAL_TASK_QUEUE_SIZE,TERMINAL_TASK_QUEUE_DATA_SIZE);
    11b8:	40 e0       	ldi	r20, 0x00	; 0
    11ba:	61 e0       	ldi	r22, 0x01	; 1
    11bc:	8a e0       	ldi	r24, 0x0A	; 10
    11be:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xQueueGenericCreate>
	vTerminal_task_q_set(temp);
    11c2:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <vTerminal_task_q_set>
	
	//create tasks			
		xTaskCreate(vkeypad_task,"keypad_x",100,NULL,4,NULL);
    11c6:	e1 2c       	mov	r14, r1
    11c8:	f1 2c       	mov	r15, r1
    11ca:	04 e0       	ldi	r16, 0x04	; 4
    11cc:	20 e0       	ldi	r18, 0x00	; 0
    11ce:	30 e0       	ldi	r19, 0x00	; 0
    11d0:	44 e6       	ldi	r20, 0x64	; 100
    11d2:	50 e0       	ldi	r21, 0x00	; 0
    11d4:	67 e8       	ldi	r22, 0x87	; 135
    11d6:	71 e0       	ldi	r23, 0x01	; 1
    11d8:	83 e2       	ldi	r24, 0x23	; 35
    11da:	95 e0       	ldi	r25, 0x05	; 5
    11dc:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <xTaskCreate>
		xTaskCreate(vlcd_task,"lcd_x",100,NULL,3,NULL);
    11e0:	03 e0       	ldi	r16, 0x03	; 3
    11e2:	20 e0       	ldi	r18, 0x00	; 0
    11e4:	30 e0       	ldi	r19, 0x00	; 0
    11e6:	44 e6       	ldi	r20, 0x64	; 100
    11e8:	50 e0       	ldi	r21, 0x00	; 0
    11ea:	60 e9       	ldi	r22, 0x90	; 144
    11ec:	71 e0       	ldi	r23, 0x01	; 1
    11ee:	83 e5       	ldi	r24, 0x53	; 83
    11f0:	95 e0       	ldi	r25, 0x05	; 5
    11f2:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <xTaskCreate>
		xTaskCreate(vled_task,"led_x",100,NULL,1,NULL);
    11f6:	01 e0       	ldi	r16, 0x01	; 1
    11f8:	20 e0       	ldi	r18, 0x00	; 0
    11fa:	30 e0       	ldi	r19, 0x00	; 0
    11fc:	44 e6       	ldi	r20, 0x64	; 100
    11fe:	50 e0       	ldi	r21, 0x00	; 0
    1200:	66 e9       	ldi	r22, 0x96	; 150
    1202:	71 e0       	ldi	r23, 0x01	; 1
    1204:	88 e0       	ldi	r24, 0x08	; 8
    1206:	97 e0       	ldi	r25, 0x07	; 7
    1208:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <xTaskCreate>
		xTaskCreate(vMotor_task,"motor_x",100,NULL,4,NULL);	
    120c:	04 e0       	ldi	r16, 0x04	; 4
    120e:	20 e0       	ldi	r18, 0x00	; 0
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	44 e6       	ldi	r20, 0x64	; 100
    1214:	50 e0       	ldi	r21, 0x00	; 0
    1216:	6c e9       	ldi	r22, 0x9C	; 156
    1218:	71 e0       	ldi	r23, 0x01	; 1
    121a:	89 e2       	ldi	r24, 0x29	; 41
    121c:	99 e0       	ldi	r25, 0x09	; 9
    121e:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <xTaskCreate>
		xTaskCreate(vTerminal_task,"term_x",150,NULL,2,NULL);
    1222:	02 e0       	ldi	r16, 0x02	; 2
    1224:	20 e0       	ldi	r18, 0x00	; 0
    1226:	30 e0       	ldi	r19, 0x00	; 0
    1228:	46 e9       	ldi	r20, 0x96	; 150
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	64 ea       	ldi	r22, 0xA4	; 164
    122e:	71 e0       	ldi	r23, 0x01	; 1
    1230:	85 ea       	ldi	r24, 0xA5	; 165
    1232:	9e e0       	ldi	r25, 0x0E	; 14
    1234:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <xTaskCreate>
		xTaskCreate(vLog_task,"log_x",100,NULL,2,NULL);
    1238:	20 e0       	ldi	r18, 0x00	; 0
    123a:	30 e0       	ldi	r19, 0x00	; 0
    123c:	44 e6       	ldi	r20, 0x64	; 100
    123e:	50 e0       	ldi	r21, 0x00	; 0
    1240:	6b ea       	ldi	r22, 0xAB	; 171
    1242:	71 e0       	ldi	r23, 0x01	; 1
    1244:	81 ef       	ldi	r24, 0xF1	; 241
    1246:	97 e0       	ldi	r25, 0x07	; 7
    1248:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <xTaskCreate>
		
		//start os
		vTaskStartScheduler();
    124c:	0e 94 fd 2e 	call	0x5dfa	; 0x5dfa <vTaskStartScheduler>
    1250:	ff cf       	rjmp	.-2      	; 0x1250 <main+0x158>

00001252 <vMotor_task>:
static xQueueHandle g_motor_task_q;

static motor_task_state_t garage_state=MOTOR_TASK_CLOSED_STATE;

void vMotor_task(void *pvParameters)
{
    1252:	cf 93       	push	r28
    1254:	df 93       	push	r29
    1256:	1f 92       	push	r1
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
	
	portBASE_TYPE que_state;
	u8 data;
	//init
	
	vMotor_driver_init(&motor_param);
    125c:	87 ed       	ldi	r24, 0xD7	; 215
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	0e 94 0e 20 	call	0x401c	; 0x401c <vMotor_driver_init>
	
	while(1)
	{
		//receive from que if any and set state
		que_state= xQueueReceive(g_motor_task_q,&data,portMAX_DELAY);
    1264:	4f ef       	ldi	r20, 0xFF	; 255
    1266:	5f ef       	ldi	r21, 0xFF	; 255
    1268:	be 01       	movw	r22, r28
    126a:	6f 5f       	subi	r22, 0xFF	; 255
    126c:	7f 4f       	sbci	r23, 0xFF	; 255
    126e:	80 91 c6 01 	lds	r24, 0x01C6
    1272:	90 91 c7 01 	lds	r25, 0x01C7
    1276:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
		if(que_state ==pdPASS)
    127a:	81 30       	cpi	r24, 0x01	; 1
    127c:	19 f4       	brne	.+6      	; 0x1284 <vMotor_task+0x32>
		{
			garage_state=data;
    127e:	89 81       	ldd	r24, Y+1	; 0x01
    1280:	80 93 c8 01 	sts	0x01C8, r24
		}
		//select state
		switch(garage_state)
    1284:	80 91 c8 01 	lds	r24, 0x01C8
    1288:	81 30       	cpi	r24, 0x01	; 1
    128a:	69 f0       	breq	.+26     	; 0x12a6 <vMotor_task+0x54>
    128c:	28 f0       	brcs	.+10     	; 0x1298 <vMotor_task+0x46>
    128e:	82 30       	cpi	r24, 0x02	; 2
    1290:	89 f0       	breq	.+34     	; 0x12b4 <vMotor_task+0x62>
    1292:	83 30       	cpi	r24, 0x03	; 3
    1294:	39 f7       	brne	.-50     	; 0x1264 <vMotor_task+0x12>
    1296:	15 c0       	rjmp	.+42     	; 0x12c2 <vMotor_task+0x70>
		{
			case MOTOR_TASK_CLOSED_STATE :
											vMotor_driver_rotate(&motor_param,0,MOTOR_STOPED);
    1298:	40 e0       	ldi	r20, 0x00	; 0
    129a:	60 e0       	ldi	r22, 0x00	; 0
    129c:	87 ed       	ldi	r24, 0xD7	; 215
    129e:	90 e0       	ldi	r25, 0x00	; 0
    12a0:	0e 94 4a 20 	call	0x4094	; 0x4094 <vMotor_driver_rotate>
											//vTaskDelay(1000);
											break;
    12a4:	df cf       	rjmp	.-66     	; 0x1264 <vMotor_task+0x12>
			case MOTOR_TASK_OPENING_GARAGE_STATE :
											vMotor_driver_rotate(&motor_param,50,MOTOR_ROTATE_CLOCKWISE);
    12a6:	41 e0       	ldi	r20, 0x01	; 1
    12a8:	62 e3       	ldi	r22, 0x32	; 50
    12aa:	87 ed       	ldi	r24, 0xD7	; 215
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	0e 94 4a 20 	call	0x4094	; 0x4094 <vMotor_driver_rotate>
											//vTaskDelay(OPENING_GARAGE_DELAY);
											break;
    12b2:	d8 cf       	rjmp	.-80     	; 0x1264 <vMotor_task+0x12>
			case MOTOR_TASK_OPENED_GARAGE_STATE :
											vMotor_driver_rotate(&motor_param,0,MOTOR_STOPED);
    12b4:	40 e0       	ldi	r20, 0x00	; 0
    12b6:	60 e0       	ldi	r22, 0x00	; 0
    12b8:	87 ed       	ldi	r24, 0xD7	; 215
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	0e 94 4a 20 	call	0x4094	; 0x4094 <vMotor_driver_rotate>
											//vTaskDelay(1000);
											break;					
    12c0:	d1 cf       	rjmp	.-94     	; 0x1264 <vMotor_task+0x12>
			case MOTOR_TASK_CLOSING_GARAGE_STATE :
											vMotor_driver_rotate(&motor_param,50,MOTOR_ROTATE_COUNTER_CLOCKWISE);
    12c2:	42 e0       	ldi	r20, 0x02	; 2
    12c4:	62 e3       	ldi	r22, 0x32	; 50
    12c6:	87 ed       	ldi	r24, 0xD7	; 215
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	0e 94 4a 20 	call	0x4094	; 0x4094 <vMotor_driver_rotate>
											//vTaskDelay(CLOSING_GARAGE_DELAY);
											break;			
    12ce:	ca cf       	rjmp	.-108    	; 0x1264 <vMotor_task+0x12>

000012d0 <vMotor_task_q_set>:
}

//-----------------------------------------------------------------
void vMotor_task_q_set(xQueueHandle key)
{
	g_motor_task_q=key;
    12d0:	90 93 c7 01 	sts	0x01C7, r25
    12d4:	80 93 c6 01 	sts	0x01C6, r24
    12d8:	08 95       	ret

000012da <xMotor_task_q_get>:
}
//-----------------------------------------------------
xQueueHandle xMotor_task_q_get(void)
{
	return  g_motor_task_q;
}
    12da:	80 91 c6 01 	lds	r24, 0x01C6
    12de:	90 91 c7 01 	lds	r25, 0x01C7
    12e2:	08 95       	ret

000012e4 <xGet_garage_task_state>:
//--------------------------------------------------------------
motor_task_state_t xGet_garage_task_state(void)
{
	return garage_state;
}
    12e4:	80 91 c8 01 	lds	r24, 0x01C8
    12e8:	08 95       	ret

000012ea <spi_interrupt>:
volatile u8 g_unlock_system_flag=0;
void spi_interrupt(void)
{
	u8 error=0;
	//save coming byte
	spi_rx_buffer[spi_rx_buffer_index]=SPDR;
    12ea:	80 91 ca 01 	lds	r24, 0x01CA
    12ee:	9f b1       	in	r25, 0x0f	; 15
    12f0:	e8 2f       	mov	r30, r24
    12f2:	f0 e0       	ldi	r31, 0x00	; 0
    12f4:	e5 53       	subi	r30, 0x35	; 53
    12f6:	fe 4f       	sbci	r31, 0xFE	; 254
    12f8:	90 83       	st	Z, r25
	//increment index and check limit
	spi_rx_buffer_index++;
    12fa:	8f 5f       	subi	r24, 0xFF	; 255
    12fc:	80 93 ca 01 	sts	0x01CA, r24
	if(spi_rx_buffer_index==4)
    1300:	84 30       	cpi	r24, 0x04	; 4
    1302:	a9 f4       	brne	.+42     	; 0x132e <spi_interrupt+0x44>
    1304:	eb ec       	ldi	r30, 0xCB	; 203
    1306:	f1 e0       	ldi	r31, 0x01	; 1
    1308:	a1 e0       	ldi	r26, 0x01	; 1
    130a:	b1 e0       	ldi	r27, 0x01	; 1

const static u8 spi_rx_default_pass[4]={'m','i','n','a'};
static u8 spi_rx_buffer[4];
static u8 spi_rx_buffer_index=0;
volatile u8 g_unlock_system_flag=0;
void spi_interrupt(void)
    130c:	8f ec       	ldi	r24, 0xCF	; 207
    130e:	91 e0       	ldi	r25, 0x01	; 1
{
	u8 error=0;
    1310:	40 e0       	ldi	r20, 0x00	; 0
	{
		
		//check buffer
		for(spi_rx_buffer_index=0;spi_rx_buffer_index<4;spi_rx_buffer_index++)
		{
			if(spi_rx_buffer[spi_rx_buffer_index] != spi_rx_default_pass[spi_rx_buffer_index])
    1312:	31 91       	ld	r19, Z+
    1314:	2d 91       	ld	r18, X+
    1316:	32 13       	cpse	r19, r18
			{
				error++;
    1318:	4f 5f       	subi	r20, 0xFF	; 255
	spi_rx_buffer_index++;
	if(spi_rx_buffer_index==4)
	{
		
		//check buffer
		for(spi_rx_buffer_index=0;spi_rx_buffer_index<4;spi_rx_buffer_index++)
    131a:	e8 17       	cp	r30, r24
    131c:	f9 07       	cpc	r31, r25
    131e:	c9 f7       	brne	.-14     	; 0x1312 <spi_interrupt+0x28>
			if(spi_rx_buffer[spi_rx_buffer_index] != spi_rx_default_pass[spi_rx_buffer_index])
			{
				error++;
			}
		} 
		if(error ==0)
    1320:	41 11       	cpse	r20, r1
    1322:	03 c0       	rjmp	.+6      	; 0x132a <spi_interrupt+0x40>
		{
			g_unlock_system_flag=1;
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	80 93 c9 01 	sts	0x01C9, r24
		}
		spi_rx_buffer_index=0;
    132a:	10 92 ca 01 	sts	0x01CA, r1
    132e:	08 95       	ret

00001330 <unlock_system>:



 void unlock_system(void)
{
	lcd_task_state_t state=xlcd_task_get_state();
    1330:	0e 94 05 07 	call	0xe0a	; 0xe0a <xlcd_task_get_state>
	if(state != LCD_TASK_LOCKED_STATE)
    1334:	84 30       	cpi	r24, 0x04	; 4
    1336:	d9 f0       	breq	.+54     	; 0x136e <unlock_system+0x3e>
	{
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1338:	6f ef       	ldi	r22, 0xFF	; 255
    133a:	7f ef       	ldi	r23, 0xFF	; 255
    133c:	80 91 2f 08 	lds	r24, 0x082F
    1340:	90 91 30 08 	lds	r25, 0x0830
    1344:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmitString_program(PSTR("THE SYSTEM IS NOT LOCKED ......"));
    1348:	87 e3       	ldi	r24, 0x37	; 55
    134a:	91 e0       	ldi	r25, 0x01	; 1
    134c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);
    1350:	8d e0       	ldi	r24, 0x0D	; 13
    1352:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		xSemaphoreGive(uart_mutex);
    1356:	20 e0       	ldi	r18, 0x00	; 0
    1358:	40 e0       	ldi	r20, 0x00	; 0
    135a:	50 e0       	ldi	r21, 0x00	; 0
    135c:	60 e0       	ldi	r22, 0x00	; 0
    135e:	70 e0       	ldi	r23, 0x00	; 0
    1360:	80 91 2f 08 	lds	r24, 0x082F
    1364:	90 91 30 08 	lds	r25, 0x0830
    1368:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    136c:	08 95       	ret
	}
	else
	{
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    136e:	6f ef       	ldi	r22, 0xFF	; 255
    1370:	7f ef       	ldi	r23, 0xFF	; 255
    1372:	80 91 2f 08 	lds	r24, 0x082F
    1376:	90 91 30 08 	lds	r25, 0x0830
    137a:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmitString_program(PSTR("UNLOCKING THE SYSTEM ......"));
    137e:	87 e5       	ldi	r24, 0x57	; 87
    1380:	91 e0       	ldi	r25, 0x01	; 1
    1382:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);
    1386:	8d e0       	ldi	r24, 0x0D	; 13
    1388:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		xSemaphoreGive(uart_mutex);
    138c:	20 e0       	ldi	r18, 0x00	; 0
    138e:	40 e0       	ldi	r20, 0x00	; 0
    1390:	50 e0       	ldi	r21, 0x00	; 0
    1392:	60 e0       	ldi	r22, 0x00	; 0
    1394:	70 e0       	ldi	r23, 0x00	; 0
    1396:	80 91 2f 08 	lds	r24, 0x082F
    139a:	90 91 30 08 	lds	r25, 0x0830
    139e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		
		xSemaphoreGive( xlcd_task_resume_semaphore_get() );
    13a2:	0e 94 00 07 	call	0xe00	; 0xe00 <xlcd_task_resume_semaphore_get>
    13a6:	20 e0       	ldi	r18, 0x00	; 0
    13a8:	40 e0       	ldi	r20, 0x00	; 0
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	60 e0       	ldi	r22, 0x00	; 0
    13ae:	70 e0       	ldi	r23, 0x00	; 0
    13b0:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    13b4:	08 95       	ret

000013b6 <open_garage>:
	}
	
}
//--------------------------------------------------------------------------
 void open_garage(void)
{
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	00 d0       	rcall	.+0      	; 0x13be <open_garage+0x8>
    13be:	cd b7       	in	r28, 0x3d	; 61
    13c0:	de b7       	in	r29, 0x3e	; 62
	u8 led_state;
	motor_task_state_t garage_state=xGet_garage_task_state();
    13c2:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xGet_garage_task_state>
    13c6:	8a 83       	std	Y+2, r24	; 0x02
	if(garage_state ==MOTOR_TASK_CLOSED_STATE)
    13c8:	81 11       	cpse	r24, r1
    13ca:	45 c0       	rjmp	.+138    	; 0x1456 <open_garage+0xa0>
	{
		//set led state to opened state
		led_state=LED_TASK_GARAGE_OPENED_STATE;
    13cc:	11 e0       	ldi	r17, 0x01	; 1
    13ce:	19 83       	std	Y+1, r17	; 0x01
		xQueueSendToBack(xLed_task_q_get(),(void*)&led_state,20);
    13d0:	0e 94 66 07 	call	0xecc	; 0xecc <xLed_task_q_get>
    13d4:	20 e0       	ldi	r18, 0x00	; 0
    13d6:	44 e1       	ldi	r20, 0x14	; 20
    13d8:	50 e0       	ldi	r21, 0x00	; 0
    13da:	be 01       	movw	r22, r28
    13dc:	6f 5f       	subi	r22, 0xFF	; 255
    13de:	7f 4f       	sbci	r23, 0xFF	; 255
    13e0:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		garage_state=MOTOR_TASK_OPENING_GARAGE_STATE;
    13e4:	1a 83       	std	Y+2, r17	; 0x02
		
		xQueueSendToBack(xMotor_task_q_get(),(void*)&garage_state,portMAX_DELAY);
    13e6:	0e 94 6d 09 	call	0x12da	; 0x12da <xMotor_task_q_get>
    13ea:	20 e0       	ldi	r18, 0x00	; 0
    13ec:	4f ef       	ldi	r20, 0xFF	; 255
    13ee:	5f ef       	ldi	r21, 0xFF	; 255
    13f0:	be 01       	movw	r22, r28
    13f2:	6e 5f       	subi	r22, 0xFE	; 254
    13f4:	7f 4f       	sbci	r23, 0xFF	; 255
    13f6:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    13fa:	6f ef       	ldi	r22, 0xFF	; 255
    13fc:	7f ef       	ldi	r23, 0xFF	; 255
    13fe:	80 91 2f 08 	lds	r24, 0x082F
    1402:	90 91 30 08 	lds	r25, 0x0830
    1406:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmit(ENTER_KEY);
    140a:	8d e0       	ldi	r24, 0x0D	; 13
    140c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmitString_program(PSTR("OPENING THE GARAGE ......"));
    1410:	83 e7       	ldi	r24, 0x73	; 115
    1412:	91 e0       	ldi	r25, 0x01	; 1
    1414:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);
    1418:	8d e0       	ldi	r24, 0x0D	; 13
    141a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		xSemaphoreGive(uart_mutex);
    141e:	20 e0       	ldi	r18, 0x00	; 0
    1420:	40 e0       	ldi	r20, 0x00	; 0
    1422:	50 e0       	ldi	r21, 0x00	; 0
    1424:	60 e0       	ldi	r22, 0x00	; 0
    1426:	70 e0       	ldi	r23, 0x00	; 0
    1428:	80 91 2f 08 	lds	r24, 0x082F
    142c:	90 91 30 08 	lds	r25, 0x0830
    1430:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		
		vTaskDelay(OPENING_GARAGE_DELAY / portTICK_PERIOD_MS);
    1434:	88 e8       	ldi	r24, 0x88	; 136
    1436:	93 e1       	ldi	r25, 0x13	; 19
    1438:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
		garage_state=MOTOR_TASK_OPENED_GARAGE_STATE;
    143c:	82 e0       	ldi	r24, 0x02	; 2
    143e:	8a 83       	std	Y+2, r24	; 0x02
		xQueueSendToBack(xMotor_task_q_get(),(void*)&garage_state,portMAX_DELAY);
    1440:	0e 94 6d 09 	call	0x12da	; 0x12da <xMotor_task_q_get>
    1444:	20 e0       	ldi	r18, 0x00	; 0
    1446:	4f ef       	ldi	r20, 0xFF	; 255
    1448:	5f ef       	ldi	r21, 0xFF	; 255
    144a:	be 01       	movw	r22, r28
    144c:	6e 5f       	subi	r22, 0xFE	; 254
    144e:	7f 4f       	sbci	r23, 0xFF	; 255
    1450:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    1454:	1d c0       	rjmp	.+58     	; 0x1490 <open_garage+0xda>
	}
	else
	{
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1456:	6f ef       	ldi	r22, 0xFF	; 255
    1458:	7f ef       	ldi	r23, 0xFF	; 255
    145a:	80 91 2f 08 	lds	r24, 0x082F
    145e:	90 91 30 08 	lds	r25, 0x0830
    1462:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmit(ENTER_KEY);
    1466:	8d e0       	ldi	r24, 0x0D	; 13
    1468:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmitString_program(PSTR("GARAGE HAS ALREADY BEEN OPENED ......"));
    146c:	8d e8       	ldi	r24, 0x8D	; 141
    146e:	91 e0       	ldi	r25, 0x01	; 1
    1470:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);
    1474:	8d e0       	ldi	r24, 0x0D	; 13
    1476:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		xSemaphoreGive(uart_mutex);
    147a:	20 e0       	ldi	r18, 0x00	; 0
    147c:	40 e0       	ldi	r20, 0x00	; 0
    147e:	50 e0       	ldi	r21, 0x00	; 0
    1480:	60 e0       	ldi	r22, 0x00	; 0
    1482:	70 e0       	ldi	r23, 0x00	; 0
    1484:	80 91 2f 08 	lds	r24, 0x082F
    1488:	90 91 30 08 	lds	r25, 0x0830
    148c:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	}


}
    1490:	0f 90       	pop	r0
    1492:	0f 90       	pop	r0
    1494:	df 91       	pop	r29
    1496:	cf 91       	pop	r28
    1498:	1f 91       	pop	r17
    149a:	08 95       	ret

0000149c <close_garage>:
//--------------------------------------------------------------------------
 void close_garage(void)
{
    149c:	cf 93       	push	r28
    149e:	df 93       	push	r29
    14a0:	00 d0       	rcall	.+0      	; 0x14a2 <close_garage+0x6>
    14a2:	cd b7       	in	r28, 0x3d	; 61
    14a4:	de b7       	in	r29, 0x3e	; 62
	u8 led_state=0;
    14a6:	19 82       	std	Y+1, r1	; 0x01
	motor_task_state_t garage_state=xGet_garage_task_state();
    14a8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <xGet_garage_task_state>
    14ac:	8a 83       	std	Y+2, r24	; 0x02
	
	if(garage_state ==MOTOR_TASK_OPENED_GARAGE_STATE)
    14ae:	82 30       	cpi	r24, 0x02	; 2
    14b0:	09 f0       	breq	.+2      	; 0x14b4 <close_garage+0x18>
    14b2:	44 c0       	rjmp	.+136    	; 0x153c <close_garage+0xa0>
	{
		//set led state to off
		led_state=LED_TASK_IDLE_STATE;
    14b4:	19 82       	std	Y+1, r1	; 0x01
		xQueueSendToBack(xLed_task_q_get(),(void*)&led_state,20);
    14b6:	0e 94 66 07 	call	0xecc	; 0xecc <xLed_task_q_get>
    14ba:	20 e0       	ldi	r18, 0x00	; 0
    14bc:	44 e1       	ldi	r20, 0x14	; 20
    14be:	50 e0       	ldi	r21, 0x00	; 0
    14c0:	be 01       	movw	r22, r28
    14c2:	6f 5f       	subi	r22, 0xFF	; 255
    14c4:	7f 4f       	sbci	r23, 0xFF	; 255
    14c6:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		//set motor state
		garage_state=MOTOR_TASK_CLOSING_GARAGE_STATE;
    14ca:	83 e0       	ldi	r24, 0x03	; 3
    14cc:	8a 83       	std	Y+2, r24	; 0x02
		xQueueSendToBack(xMotor_task_q_get(),(void*)&garage_state,portMAX_DELAY);
    14ce:	0e 94 6d 09 	call	0x12da	; 0x12da <xMotor_task_q_get>
    14d2:	20 e0       	ldi	r18, 0x00	; 0
    14d4:	4f ef       	ldi	r20, 0xFF	; 255
    14d6:	5f ef       	ldi	r21, 0xFF	; 255
    14d8:	be 01       	movw	r22, r28
    14da:	6e 5f       	subi	r22, 0xFE	; 254
    14dc:	7f 4f       	sbci	r23, 0xFF	; 255
    14de:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    14e2:	6f ef       	ldi	r22, 0xFF	; 255
    14e4:	7f ef       	ldi	r23, 0xFF	; 255
    14e6:	80 91 2f 08 	lds	r24, 0x082F
    14ea:	90 91 30 08 	lds	r25, 0x0830
    14ee:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmit(ENTER_KEY);
    14f2:	8d e0       	ldi	r24, 0x0D	; 13
    14f4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmitString_program(PSTR("CLOSING THE GARAGE ......"));
    14f8:	83 eb       	ldi	r24, 0xB3	; 179
    14fa:	91 e0       	ldi	r25, 0x01	; 1
    14fc:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);
    1500:	8d e0       	ldi	r24, 0x0D	; 13
    1502:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		xSemaphoreGive(uart_mutex);
    1506:	20 e0       	ldi	r18, 0x00	; 0
    1508:	40 e0       	ldi	r20, 0x00	; 0
    150a:	50 e0       	ldi	r21, 0x00	; 0
    150c:	60 e0       	ldi	r22, 0x00	; 0
    150e:	70 e0       	ldi	r23, 0x00	; 0
    1510:	80 91 2f 08 	lds	r24, 0x082F
    1514:	90 91 30 08 	lds	r25, 0x0830
    1518:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		
		vTaskDelay(CLOSING_GARAGE_DELAY / portTICK_PERIOD_MS);
    151c:	88 e8       	ldi	r24, 0x88	; 136
    151e:	93 e1       	ldi	r25, 0x13	; 19
    1520:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
		garage_state=MOTOR_TASK_CLOSED_STATE;
    1524:	1a 82       	std	Y+2, r1	; 0x02
		xQueueSendToBack(xMotor_task_q_get(),(void*)&garage_state,portMAX_DELAY);
    1526:	0e 94 6d 09 	call	0x12da	; 0x12da <xMotor_task_q_get>
    152a:	20 e0       	ldi	r18, 0x00	; 0
    152c:	4f ef       	ldi	r20, 0xFF	; 255
    152e:	5f ef       	ldi	r21, 0xFF	; 255
    1530:	be 01       	movw	r22, r28
    1532:	6e 5f       	subi	r22, 0xFE	; 254
    1534:	7f 4f       	sbci	r23, 0xFF	; 255
    1536:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    153a:	1d c0       	rjmp	.+58     	; 0x1576 <close_garage+0xda>
	}
	else
	{
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    153c:	6f ef       	ldi	r22, 0xFF	; 255
    153e:	7f ef       	ldi	r23, 0xFF	; 255
    1540:	80 91 2f 08 	lds	r24, 0x082F
    1544:	90 91 30 08 	lds	r25, 0x0830
    1548:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmit(ENTER_KEY);
    154c:	8d e0       	ldi	r24, 0x0D	; 13
    154e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmitString_program(PSTR("GARAGE IS CLOSED..............."));
    1552:	8d ec       	ldi	r24, 0xCD	; 205
    1554:	91 e0       	ldi	r25, 0x01	; 1
    1556:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);
    155a:	8d e0       	ldi	r24, 0x0D	; 13
    155c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		xSemaphoreGive(uart_mutex);
    1560:	20 e0       	ldi	r18, 0x00	; 0
    1562:	40 e0       	ldi	r20, 0x00	; 0
    1564:	50 e0       	ldi	r21, 0x00	; 0
    1566:	60 e0       	ldi	r22, 0x00	; 0
    1568:	70 e0       	ldi	r23, 0x00	; 0
    156a:	80 91 2f 08 	lds	r24, 0x082F
    156e:	90 91 30 08 	lds	r25, 0x0830
    1572:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	}

}
    1576:	0f 90       	pop	r0
    1578:	0f 90       	pop	r0
    157a:	df 91       	pop	r29
    157c:	cf 91       	pop	r28
    157e:	08 95       	ret

00001580 <set_time>:
//--------------------------------------------------------------------------
 void set_time(void)
{
    1580:	9f 92       	push	r9
    1582:	af 92       	push	r10
    1584:	bf 92       	push	r11
    1586:	cf 92       	push	r12
    1588:	df 92       	push	r13
    158a:	ef 92       	push	r14
    158c:	ff 92       	push	r15
    158e:	0f 93       	push	r16
    1590:	1f 93       	push	r17
    1592:	cf 93       	push	r28
    1594:	df 93       	push	r29
    1596:	cd b7       	in	r28, 0x3d	; 61
    1598:	de b7       	in	r29, 0x3e	; 62
    159a:	28 97       	sbiw	r28, 0x08	; 8
    159c:	0f b6       	in	r0, 0x3f	; 63
    159e:	f8 94       	cli
    15a0:	de bf       	out	0x3e, r29	; 62
    15a2:	0f be       	out	0x3f, r0	; 63
    15a4:	cd bf       	out	0x3d, r28	; 61
	} func_error;
	
	func_state=SET_HOUR_STATE;
	func_error=NO_ERROR;
	
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    15a6:	6f ef       	ldi	r22, 0xFF	; 255
    15a8:	7f ef       	ldi	r23, 0xFF	; 255
    15aa:	80 91 2f 08 	lds	r24, 0x082F
    15ae:	90 91 30 08 	lds	r25, 0x0830
    15b2:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmitString_program(PSTR("--------------------------------"));
    15b6:	8d ee       	ldi	r24, 0xED	; 237
    15b8:	91 e0       	ldi	r25, 0x01	; 1
    15ba:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    15be:	8d e0       	ldi	r24, 0x0D	; 13
    15c0:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		INVALID_YEAR_ERROR,
		TIMEOUT_ERROR
	} func_error;
	
	func_state=SET_HOUR_STATE;
	func_error=NO_ERROR;
    15c4:	00 e0       	ldi	r16, 0x00	; 0
		INVALID_MONTH_ERROR,
		INVALID_YEAR_ERROR,
		TIMEOUT_ERROR
	} func_error;
	
	func_state=SET_HOUR_STATE;
    15c6:	10 e0       	ldi	r17, 0x00	; 0
					func_state=SET_DATE_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_AM_ERROR;
    15c8:	0f 2e       	mov	r0, r31
    15ca:	f3 e0       	ldi	r31, 0x03	; 3
    15cc:	cf 2e       	mov	r12, r31
    15ce:	f0 2d       	mov	r31, r0
					func_state=SET_AM_PM_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_MINUTE_ERROR;
    15d0:	68 94       	set
    15d2:	dd 24       	eor	r13, r13
    15d4:	d1 f8       	bld	r13, 1
						time.minutes.bcd_data.first_digit=first;
						time.minutes.bcd_data.second_digit=0;
					}
					else
					{
						first=time.minutes.raw_data%10;
    15d6:	0f 2e       	mov	r0, r31
    15d8:	fd ec       	ldi	r31, 0xCD	; 205
    15da:	af 2e       	mov	r10, r31
    15dc:	f0 2d       	mov	r31, r0
					func_state=SET_MINUTE_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_HOUR_ERROR;
    15de:	99 24       	eor	r9, r9
    15e0:	93 94       	inc	r9
					func_state=SET_MONTH_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_DATE_ERROR;
    15e2:	68 94       	set
    15e4:	ee 24       	eor	r14, r14
    15e6:	e2 f8       	bld	r14, 2
					func_state=SET_YEAR_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_MONTH_ERROR;
    15e8:	0f 2e       	mov	r0, r31
    15ea:	f5 e0       	ldi	r31, 0x05	; 5
    15ec:	ff 2e       	mov	r15, r31
    15ee:	f0 2d       	mov	r31, r0
					func_state=SAVE_TIME_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_YEAR_ERROR;
    15f0:	0f 2e       	mov	r0, r31
    15f2:	f6 e0       	ldi	r31, 0x06	; 6
    15f4:	bf 2e       	mov	r11, r31
    15f6:	f0 2d       	mov	r31, r0
	
	vUartTransmitString_program(PSTR("--------------------------------"));
	vUartTransmit(ENTER_KEY);
	while(1)
	{
		switch(func_state)
    15f8:	13 30       	cpi	r17, 0x03	; 3
    15fa:	09 f4       	brne	.+2      	; 0x15fe <set_time+0x7e>
    15fc:	9c c0       	rjmp	.+312    	; 0x1736 <set_time+0x1b6>
    15fe:	30 f4       	brcc	.+12     	; 0x160c <set_time+0x8c>
    1600:	11 30       	cpi	r17, 0x01	; 1
    1602:	09 f4       	brne	.+2      	; 0x1606 <set_time+0x86>
    1604:	47 c0       	rjmp	.+142    	; 0x1694 <set_time+0x114>
    1606:	08 f0       	brcs	.+2      	; 0x160a <set_time+0x8a>
    1608:	79 c0       	rjmp	.+242    	; 0x16fc <set_time+0x17c>
    160a:	09 c0       	rjmp	.+18     	; 0x161e <set_time+0x9e>
    160c:	15 30       	cpi	r17, 0x05	; 5
    160e:	09 f4       	brne	.+2      	; 0x1612 <set_time+0x92>
    1610:	01 c1       	rjmp	.+514    	; 0x1814 <set_time+0x294>
    1612:	08 f4       	brcc	.+2      	; 0x1616 <set_time+0x96>
    1614:	c6 c0       	rjmp	.+396    	; 0x17a2 <set_time+0x222>
    1616:	16 30       	cpi	r17, 0x06	; 6
    1618:	09 f0       	breq	.+2      	; 0x161c <set_time+0x9c>
    161a:	5a c1       	rjmp	.+692    	; 0x18d0 <set_time+0x350>
    161c:	2c c1       	rjmp	.+600    	; 0x1876 <set_time+0x2f6>
		{
			case SET_HOUR_STATE :
			vUartTransmit(ENTER_KEY);
    161e:	8d e0       	ldi	r24, 0x0D	; 13
    1620:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("ENTER HOUR  : "));
    1624:	8e e0       	ldi	r24, 0x0E	; 14
    1626:	92 e0       	ldi	r25, 0x02	; 2
    1628:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			temp=get_u8(&(time.hours.raw_data));
    162c:	ce 01       	movw	r24, r28
    162e:	03 96       	adiw	r24, 0x03	; 3
    1630:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
			if(temp == TERMINAL_RETURN_U8)
    1634:	8a 3a       	cpi	r24, 0xAA	; 170
    1636:	09 f0       	breq	.+2      	; 0x163a <set_time+0xba>
    1638:	5f c1       	rjmp	.+702    	; 0x18f8 <set_time+0x378>
			{
				if(time.hours.raw_data <=12 && time.hours.raw_data !=0)
    163a:	8b 81       	ldd	r24, Y+3	; 0x03
    163c:	98 2f       	mov	r25, r24
    163e:	91 50       	subi	r25, 0x01	; 1
    1640:	9c 30       	cpi	r25, 0x0C	; 12
    1642:	08 f0       	brcs	.+2      	; 0x1646 <set_time+0xc6>
    1644:	68 c1       	rjmp	.+720    	; 0x1916 <set_time+0x396>
				{
					//check >9
					if(time.hours.raw_data <9)
    1646:	89 30       	cpi	r24, 0x09	; 9
    1648:	50 f4       	brcc	.+20     	; 0x165e <set_time+0xde>
					{
						first=time.hours.raw_data;
    164a:	88 87       	std	Y+8, r24	; 0x08
						time.hours.h12.SELECT_12_24=RTC_12_FORMAT;
    164c:	98 2f       	mov	r25, r24
    164e:	90 64       	ori	r25, 0x40	; 64
						time.hours.h12.first_digit=first;
    1650:	8f 70       	andi	r24, 0x0F	; 15
    1652:	90 7f       	andi	r25, 0xF0	; 240
						time.hours.h12.second_digit=0;
    1654:	89 2b       	or	r24, r25
    1656:	8f 7e       	andi	r24, 0xEF	; 239
    1658:	8b 83       	std	Y+3, r24	; 0x03
						second=time.hours.raw_data/10;
						time.hours.h12.SELECT_12_24=RTC_12_FORMAT;
						time.hours.h12.first_digit=first;
						time.hours.h12.second_digit=second;
					}
					func_state=SET_MINUTE_STATE;
    165a:	19 2d       	mov	r17, r9
    165c:	1b c0       	rjmp	.+54     	; 0x1694 <set_time+0x114>
						time.hours.h12.first_digit=first;
						time.hours.h12.second_digit=0;
					}
					else
					{
						first=time.hours.raw_data%10;
    165e:	8a 9d       	mul	r24, r10
    1660:	21 2d       	mov	r18, r1
    1662:	11 24       	eor	r1, r1
    1664:	92 2f       	mov	r25, r18
    1666:	96 95       	lsr	r25
    1668:	96 95       	lsr	r25
    166a:	96 95       	lsr	r25
    166c:	99 0f       	add	r25, r25
    166e:	39 2f       	mov	r19, r25
    1670:	33 0f       	add	r19, r19
    1672:	33 0f       	add	r19, r19
    1674:	93 0f       	add	r25, r19
    1676:	89 1b       	sub	r24, r25
    1678:	98 2f       	mov	r25, r24
    167a:	88 87       	std	Y+8, r24	; 0x08
						second=time.hours.raw_data/10;
						time.hours.h12.SELECT_12_24=RTC_12_FORMAT;
    167c:	8b 81       	ldd	r24, Y+3	; 0x03
    167e:	80 64       	ori	r24, 0x40	; 64
						time.hours.h12.first_digit=first;
    1680:	9f 70       	andi	r25, 0x0F	; 15
    1682:	80 7f       	andi	r24, 0xF0	; 240
						time.hours.h12.second_digit=0;
					}
					else
					{
						first=time.hours.raw_data%10;
						second=time.hours.raw_data/10;
    1684:	26 95       	lsr	r18
    1686:	26 95       	lsr	r18
    1688:	26 95       	lsr	r18
						time.hours.h12.SELECT_12_24=RTC_12_FORMAT;
						time.hours.h12.first_digit=first;
						time.hours.h12.second_digit=second;
    168a:	98 2b       	or	r25, r24
    168c:	20 fb       	bst	r18, 0
    168e:	94 f9       	bld	r25, 4
    1690:	9b 83       	std	Y+3, r25	; 0x03
					}
					func_state=SET_MINUTE_STATE;
    1692:	19 2d       	mov	r17, r9
				//invalid type
				func_error=TIMEOUT_ERROR;
				break;
			}
			case SET_MINUTE_STATE :
			vUartTransmit(ENTER_KEY);
    1694:	8d e0       	ldi	r24, 0x0D	; 13
    1696:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("ENTER MINUTE  : "));
    169a:	8d e1       	ldi	r24, 0x1D	; 29
    169c:	92 e0       	ldi	r25, 0x02	; 2
    169e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			temp=get_u8(&(time.minutes.raw_data));
    16a2:	ce 01       	movw	r24, r28
    16a4:	02 96       	adiw	r24, 0x02	; 2
    16a6:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
			if(temp == TERMINAL_RETURN_U8)
    16aa:	8a 3a       	cpi	r24, 0xAA	; 170
    16ac:	09 f0       	breq	.+2      	; 0x16b0 <set_time+0x130>
    16ae:	24 c1       	rjmp	.+584    	; 0x18f8 <set_time+0x378>
			{
				if(time.minutes.raw_data <=59)
    16b0:	8a 81       	ldd	r24, Y+2	; 0x02
    16b2:	8c 33       	cpi	r24, 0x3C	; 60
    16b4:	08 f0       	brcs	.+2      	; 0x16b8 <set_time+0x138>
    16b6:	31 c1       	rjmp	.+610    	; 0x191a <set_time+0x39a>
				{
					//check >9
					if(time.minutes.raw_data <9)
    16b8:	89 30       	cpi	r24, 0x09	; 9
    16ba:	40 f4       	brcc	.+16     	; 0x16cc <set_time+0x14c>
					{
						first=time.minutes.raw_data;
    16bc:	88 87       	std	Y+8, r24	; 0x08
						time.minutes.bcd_data.first_digit=first;
    16be:	8f 70       	andi	r24, 0x0F	; 15
    16c0:	9a 81       	ldd	r25, Y+2	; 0x02
    16c2:	90 78       	andi	r25, 0x80	; 128
						time.minutes.bcd_data.second_digit=0;
    16c4:	89 2b       	or	r24, r25
    16c6:	8a 83       	std	Y+2, r24	; 0x02
						first=time.minutes.raw_data%10;
						second=time.minutes.raw_data/10;
						time.minutes.bcd_data.first_digit=first;
						time.minutes.bcd_data.second_digit=second;
					}
					func_state=SET_AM_PM_STATE;
    16c8:	1d 2d       	mov	r17, r13
    16ca:	18 c0       	rjmp	.+48     	; 0x16fc <set_time+0x17c>
						time.minutes.bcd_data.first_digit=first;
						time.minutes.bcd_data.second_digit=0;
					}
					else
					{
						first=time.minutes.raw_data%10;
    16cc:	8a 9d       	mul	r24, r10
    16ce:	21 2d       	mov	r18, r1
    16d0:	11 24       	eor	r1, r1
    16d2:	92 2f       	mov	r25, r18
    16d4:	96 95       	lsr	r25
    16d6:	96 95       	lsr	r25
    16d8:	96 95       	lsr	r25
    16da:	99 0f       	add	r25, r25
    16dc:	39 2f       	mov	r19, r25
    16de:	33 0f       	add	r19, r19
    16e0:	33 0f       	add	r19, r19
    16e2:	93 0f       	add	r25, r19
    16e4:	89 1b       	sub	r24, r25
    16e6:	98 2f       	mov	r25, r24
    16e8:	88 87       	std	Y+8, r24	; 0x08
						second=time.minutes.raw_data/10;
						time.minutes.bcd_data.first_digit=first;
    16ea:	9f 70       	andi	r25, 0x0F	; 15
    16ec:	8a 81       	ldd	r24, Y+2	; 0x02
    16ee:	80 78       	andi	r24, 0x80	; 128
						time.minutes.bcd_data.second_digit=second;
    16f0:	22 0f       	add	r18, r18
    16f2:	20 77       	andi	r18, 0x70	; 112
    16f4:	98 2b       	or	r25, r24
    16f6:	92 2b       	or	r25, r18
    16f8:	9a 83       	std	Y+2, r25	; 0x02
					}
					func_state=SET_AM_PM_STATE;
    16fa:	1d 2d       	mov	r17, r13
				//invalid type
				func_error=TIMEOUT_ERROR;
				break;
			}
			case SET_AM_PM_STATE :
			vUartTransmit(ENTER_KEY);
    16fc:	8d e0       	ldi	r24, 0x0D	; 13
    16fe:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("ENTER (1 -> AM ) (2 -> PM)  : "));
    1702:	8e e2       	ldi	r24, 0x2E	; 46
    1704:	92 e0       	ldi	r25, 0x02	; 2
    1706:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			temp=get_u8(&(first));
    170a:	ce 01       	movw	r24, r28
    170c:	08 96       	adiw	r24, 0x08	; 8
    170e:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
			if(temp == TERMINAL_RETURN_U8)
    1712:	8a 3a       	cpi	r24, 0xAA	; 170
    1714:	09 f0       	breq	.+2      	; 0x1718 <set_time+0x198>
    1716:	f0 c0       	rjmp	.+480    	; 0x18f8 <set_time+0x378>
			{
				if(first ==1)
    1718:	88 85       	ldd	r24, Y+8	; 0x08
    171a:	81 30       	cpi	r24, 0x01	; 1
    171c:	29 f4       	brne	.+10     	; 0x1728 <set_time+0x1a8>
				{
					time.hours.h12.SELECT_AM_PM=RTC_AM;
    171e:	8b 81       	ldd	r24, Y+3	; 0x03
    1720:	8f 7d       	andi	r24, 0xDF	; 223
    1722:	8b 83       	std	Y+3, r24	; 0x03
					func_state=SET_DATE_STATE;
    1724:	1c 2d       	mov	r17, r12
    1726:	07 c0       	rjmp	.+14     	; 0x1736 <set_time+0x1b6>
					func_error=NO_ERROR;
				}
				else if(first ==2)
    1728:	82 30       	cpi	r24, 0x02	; 2
    172a:	09 f0       	breq	.+2      	; 0x172e <set_time+0x1ae>
    172c:	f8 c0       	rjmp	.+496    	; 0x191e <set_time+0x39e>
				{
					time.hours.h12.SELECT_AM_PM=RTC_PM;
    172e:	8b 81       	ldd	r24, Y+3	; 0x03
    1730:	80 62       	ori	r24, 0x20	; 32
    1732:	8b 83       	std	Y+3, r24	; 0x03
					func_state=SET_DATE_STATE;
    1734:	1c 2d       	mov	r17, r12
				//invalid type
				func_error=TIMEOUT_ERROR;
				break;
			}
			case SET_DATE_STATE :
			vUartTransmit(ENTER_KEY);
    1736:	8d e0       	ldi	r24, 0x0D	; 13
    1738:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("ENTER DATE  : "));
    173c:	8d e4       	ldi	r24, 0x4D	; 77
    173e:	92 e0       	ldi	r25, 0x02	; 2
    1740:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			temp=get_u8(&(time.date.raw_data));
    1744:	ce 01       	movw	r24, r28
    1746:	05 96       	adiw	r24, 0x05	; 5
    1748:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
			if(temp == TERMINAL_RETURN_U8)
    174c:	8a 3a       	cpi	r24, 0xAA	; 170
    174e:	09 f0       	breq	.+2      	; 0x1752 <set_time+0x1d2>
    1750:	d3 c0       	rjmp	.+422    	; 0x18f8 <set_time+0x378>
			{
				if(time.date.raw_data <=31 && time.date.raw_data !=0)
    1752:	8d 81       	ldd	r24, Y+5	; 0x05
    1754:	98 2f       	mov	r25, r24
    1756:	91 50       	subi	r25, 0x01	; 1
    1758:	9f 31       	cpi	r25, 0x1F	; 31
    175a:	08 f0       	brcs	.+2      	; 0x175e <set_time+0x1de>
    175c:	e2 c0       	rjmp	.+452    	; 0x1922 <set_time+0x3a2>
				{
					//check >9
					if(time.date.raw_data <9)
    175e:	89 30       	cpi	r24, 0x09	; 9
    1760:	40 f4       	brcc	.+16     	; 0x1772 <set_time+0x1f2>
					{
						first=time.date.raw_data;
    1762:	88 87       	std	Y+8, r24	; 0x08
						time.date.bcd_data.first_digit=first;
    1764:	8f 70       	andi	r24, 0x0F	; 15
    1766:	9d 81       	ldd	r25, Y+5	; 0x05
    1768:	90 7c       	andi	r25, 0xC0	; 192
						time.date.bcd_data.second_digit=0;
    176a:	89 2b       	or	r24, r25
    176c:	8d 83       	std	Y+5, r24	; 0x05
						first=time.date.raw_data%10;
						second=time.date.raw_data/10;
						time.date.bcd_data.first_digit=first;
						time.date.bcd_data.second_digit=second;
					}
					func_state=SET_MONTH_STATE;
    176e:	1e 2d       	mov	r17, r14
    1770:	18 c0       	rjmp	.+48     	; 0x17a2 <set_time+0x222>
						time.date.bcd_data.first_digit=first;
						time.date.bcd_data.second_digit=0;
					}
					else
					{
						first=time.date.raw_data%10;
    1772:	8a 9d       	mul	r24, r10
    1774:	21 2d       	mov	r18, r1
    1776:	11 24       	eor	r1, r1
    1778:	92 2f       	mov	r25, r18
    177a:	96 95       	lsr	r25
    177c:	96 95       	lsr	r25
    177e:	96 95       	lsr	r25
    1780:	99 0f       	add	r25, r25
    1782:	39 2f       	mov	r19, r25
    1784:	33 0f       	add	r19, r19
    1786:	33 0f       	add	r19, r19
    1788:	93 0f       	add	r25, r19
    178a:	89 1b       	sub	r24, r25
    178c:	98 2f       	mov	r25, r24
    178e:	88 87       	std	Y+8, r24	; 0x08
						second=time.date.raw_data/10;
						time.date.bcd_data.first_digit=first;
    1790:	9f 70       	andi	r25, 0x0F	; 15
    1792:	8d 81       	ldd	r24, Y+5	; 0x05
    1794:	80 7c       	andi	r24, 0xC0	; 192
						time.date.bcd_data.second_digit=second;
    1796:	22 0f       	add	r18, r18
    1798:	20 73       	andi	r18, 0x30	; 48
    179a:	98 2b       	or	r25, r24
    179c:	92 2b       	or	r25, r18
    179e:	9d 83       	std	Y+5, r25	; 0x05
					}
					func_state=SET_MONTH_STATE;
    17a0:	1e 2d       	mov	r17, r14
				//invalid type
				func_error=TIMEOUT_ERROR;
				break;
			}
			case SET_MONTH_STATE :
			vUartTransmit(ENTER_KEY);
    17a2:	8d e0       	ldi	r24, 0x0D	; 13
    17a4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("ENTER MONTH  : "));
    17a8:	8c e5       	ldi	r24, 0x5C	; 92
    17aa:	92 e0       	ldi	r25, 0x02	; 2
    17ac:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			temp=get_u8(&(time.month.raw_data));
    17b0:	ce 01       	movw	r24, r28
    17b2:	06 96       	adiw	r24, 0x06	; 6
    17b4:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
			if(temp == TERMINAL_RETURN_U8)
    17b8:	8a 3a       	cpi	r24, 0xAA	; 170
    17ba:	09 f0       	breq	.+2      	; 0x17be <set_time+0x23e>
    17bc:	9d c0       	rjmp	.+314    	; 0x18f8 <set_time+0x378>
			{
				if(time.month.raw_data <=12 && time.month.raw_data !=0)
    17be:	8e 81       	ldd	r24, Y+6	; 0x06
    17c0:	98 2f       	mov	r25, r24
    17c2:	91 50       	subi	r25, 0x01	; 1
    17c4:	9c 30       	cpi	r25, 0x0C	; 12
    17c6:	08 f0       	brcs	.+2      	; 0x17ca <set_time+0x24a>
    17c8:	ae c0       	rjmp	.+348    	; 0x1926 <set_time+0x3a6>
				{
					//check >9
					if(time.month.raw_data <9)
    17ca:	89 30       	cpi	r24, 0x09	; 9
    17cc:	48 f4       	brcc	.+18     	; 0x17e0 <set_time+0x260>
					{
						first=time.month.raw_data;
    17ce:	88 87       	std	Y+8, r24	; 0x08
						time.month.bcd_data.first_digit=first;
    17d0:	8f 70       	andi	r24, 0x0F	; 15
    17d2:	9e 81       	ldd	r25, Y+6	; 0x06
    17d4:	90 7f       	andi	r25, 0xF0	; 240
						time.month.bcd_data.second_digit=0;
    17d6:	89 2b       	or	r24, r25
    17d8:	8f 7e       	andi	r24, 0xEF	; 239
    17da:	8e 83       	std	Y+6, r24	; 0x06
						first=time.month.raw_data%10;
						second=time.month.raw_data/10;
						time.month.bcd_data.first_digit=first;
						time.month.bcd_data.second_digit=second;
					}
					func_state=SET_YEAR_STATE;
    17dc:	1f 2d       	mov	r17, r15
    17de:	1a c0       	rjmp	.+52     	; 0x1814 <set_time+0x294>
						time.month.bcd_data.first_digit=first;
						time.month.bcd_data.second_digit=0;
					}
					else
					{
						first=time.month.raw_data%10;
    17e0:	8a 9d       	mul	r24, r10
    17e2:	21 2d       	mov	r18, r1
    17e4:	11 24       	eor	r1, r1
    17e6:	92 2f       	mov	r25, r18
    17e8:	96 95       	lsr	r25
    17ea:	96 95       	lsr	r25
    17ec:	96 95       	lsr	r25
    17ee:	99 0f       	add	r25, r25
    17f0:	39 2f       	mov	r19, r25
    17f2:	33 0f       	add	r19, r19
    17f4:	33 0f       	add	r19, r19
    17f6:	93 0f       	add	r25, r19
    17f8:	89 1b       	sub	r24, r25
    17fa:	98 2f       	mov	r25, r24
    17fc:	88 87       	std	Y+8, r24	; 0x08
						second=time.month.raw_data/10;
						time.month.bcd_data.first_digit=first;
    17fe:	9f 70       	andi	r25, 0x0F	; 15
    1800:	8e 81       	ldd	r24, Y+6	; 0x06
    1802:	80 7f       	andi	r24, 0xF0	; 240
						time.month.bcd_data.second_digit=0;
					}
					else
					{
						first=time.month.raw_data%10;
						second=time.month.raw_data/10;
    1804:	26 95       	lsr	r18
    1806:	26 95       	lsr	r18
    1808:	26 95       	lsr	r18
						time.month.bcd_data.first_digit=first;
						time.month.bcd_data.second_digit=second;
    180a:	98 2b       	or	r25, r24
    180c:	20 fb       	bst	r18, 0
    180e:	94 f9       	bld	r25, 4
    1810:	9e 83       	std	Y+6, r25	; 0x06
					}
					func_state=SET_YEAR_STATE;
    1812:	1f 2d       	mov	r17, r15
				//invalid type
				func_error=TIMEOUT_ERROR;
				break;
			}
			case SET_YEAR_STATE :
			vUartTransmit(ENTER_KEY);
    1814:	8d e0       	ldi	r24, 0x0D	; 13
    1816:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("ENTER YEAR  : "));
    181a:	8c e6       	ldi	r24, 0x6C	; 108
    181c:	92 e0       	ldi	r25, 0x02	; 2
    181e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			temp=get_u8(&(time.year.raw_data));
    1822:	ce 01       	movw	r24, r28
    1824:	07 96       	adiw	r24, 0x07	; 7
    1826:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
			if(temp == TERMINAL_RETURN_U8)
    182a:	8a 3a       	cpi	r24, 0xAA	; 170
    182c:	09 f0       	breq	.+2      	; 0x1830 <set_time+0x2b0>
    182e:	64 c0       	rjmp	.+200    	; 0x18f8 <set_time+0x378>
			{
				if(time.year.raw_data <=99)
    1830:	8f 81       	ldd	r24, Y+7	; 0x07
    1832:	84 36       	cpi	r24, 0x64	; 100
    1834:	08 f0       	brcs	.+2      	; 0x1838 <set_time+0x2b8>
    1836:	79 c0       	rjmp	.+242    	; 0x192a <set_time+0x3aa>
				{
					//check >9
					if(time.year.raw_data <9)
    1838:	89 30       	cpi	r24, 0x09	; 9
    183a:	20 f4       	brcc	.+8      	; 0x1844 <set_time+0x2c4>
					{
						first=time.year.raw_data;
    183c:	88 87       	std	Y+8, r24	; 0x08
						time.year.bcd_data.first_digit=first;
						time.year.bcd_data.second_digit=0;
    183e:	8f 70       	andi	r24, 0x0F	; 15
    1840:	8f 83       	std	Y+7, r24	; 0x07
    1842:	19 c0       	rjmp	.+50     	; 0x1876 <set_time+0x2f6>
					}
					else
					{
						first=time.year.raw_data%10;
    1844:	2d ec       	ldi	r18, 0xCD	; 205
    1846:	82 9f       	mul	r24, r18
    1848:	21 2d       	mov	r18, r1
    184a:	11 24       	eor	r1, r1
    184c:	92 2f       	mov	r25, r18
    184e:	96 95       	lsr	r25
    1850:	96 95       	lsr	r25
    1852:	96 95       	lsr	r25
    1854:	99 0f       	add	r25, r25
    1856:	39 2f       	mov	r19, r25
    1858:	33 0f       	add	r19, r19
    185a:	33 0f       	add	r19, r19
    185c:	93 0f       	add	r25, r19
    185e:	89 1b       	sub	r24, r25
    1860:	98 2f       	mov	r25, r24
    1862:	88 87       	std	Y+8, r24	; 0x08
						second=time.year.raw_data/10;
    1864:	82 2f       	mov	r24, r18
    1866:	86 95       	lsr	r24
    1868:	86 95       	lsr	r24
    186a:	86 95       	lsr	r24
						time.year.bcd_data.first_digit=first;
						time.year.bcd_data.second_digit=second;
    186c:	82 95       	swap	r24
    186e:	80 7f       	andi	r24, 0xF0	; 240
    1870:	9f 70       	andi	r25, 0x0F	; 15
    1872:	89 2b       	or	r24, r25
    1874:	8f 83       	std	Y+7, r24	; 0x07
				//invalid type
				func_error=TIMEOUT_ERROR;
				break;
			}
			case SAVE_TIME_STATE :
							xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    1876:	6f ef       	ldi	r22, 0xFF	; 255
    1878:	7f ef       	ldi	r23, 0xFF	; 255
    187a:	80 91 2d 08 	lds	r24, 0x082D
    187e:	90 91 2e 08 	lds	r25, 0x082E
    1882:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
							u8Rtc_Set_Time(&time);
    1886:	ce 01       	movw	r24, r28
    1888:	01 96       	adiw	r24, 0x01	; 1
    188a:	0e 94 d8 20 	call	0x41b0	; 0x41b0 <u8Rtc_Set_Time>
							xSemaphoreGive(i2c_mutex);
    188e:	20 e0       	ldi	r18, 0x00	; 0
    1890:	40 e0       	ldi	r20, 0x00	; 0
    1892:	50 e0       	ldi	r21, 0x00	; 0
    1894:	60 e0       	ldi	r22, 0x00	; 0
    1896:	70 e0       	ldi	r23, 0x00	; 0
    1898:	80 91 2d 08 	lds	r24, 0x082D
    189c:	90 91 2e 08 	lds	r25, 0x082E
    18a0:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
							vUartTransmit(ENTER_KEY);
    18a4:	8d e0       	ldi	r24, 0x0D	; 13
    18a6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
							vUartTransmitString_program(PSTR("DONE TIME IS SET ....... "));
    18aa:	8b e7       	ldi	r24, 0x7B	; 123
    18ac:	92 e0       	ldi	r25, 0x02	; 2
    18ae:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
							vUartTransmit(ENTER_KEY);
    18b2:	8d e0       	ldi	r24, 0x0D	; 13
    18b4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
							xSemaphoreGive(uart_mutex);
    18b8:	20 e0       	ldi	r18, 0x00	; 0
    18ba:	40 e0       	ldi	r20, 0x00	; 0
    18bc:	50 e0       	ldi	r21, 0x00	; 0
    18be:	60 e0       	ldi	r22, 0x00	; 0
    18c0:	70 e0       	ldi	r23, 0x00	; 0
    18c2:	80 91 2f 08 	lds	r24, 0x082F
    18c6:	90 91 30 08 	lds	r25, 0x0830
    18ca:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    18ce:	2f c0       	rjmp	.+94     	; 0x192e <set_time+0x3ae>
							return;
			default:break;
		}
		switch(func_error)
    18d0:	01 30       	cpi	r16, 0x01	; 1
    18d2:	08 f4       	brcc	.+2      	; 0x18d6 <set_time+0x356>
    18d4:	91 ce       	rjmp	.-734    	; 0x15f8 <set_time+0x78>
    18d6:	07 30       	cpi	r16, 0x07	; 7
    18d8:	20 f0       	brcs	.+8      	; 0x18e2 <set_time+0x362>
    18da:	07 30       	cpi	r16, 0x07	; 7
    18dc:	09 f0       	breq	.+2      	; 0x18e0 <set_time+0x360>
    18de:	8c ce       	rjmp	.-744    	; 0x15f8 <set_time+0x78>
    18e0:	0b c0       	rjmp	.+22     	; 0x18f8 <set_time+0x378>
			case INVALID_MINUTE_ERROR :
			case INVALID_AM_ERROR :
			case INVALID_DATE_ERROR:
			case INVALID_MONTH_ERROR:
			case INVALID_YEAR_ERROR :
			vUartTransmit(ENTER_KEY);
    18e2:	8d e0       	ldi	r24, 0x0D	; 13
    18e4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("INVALID INPUT ....... "));
    18e8:	85 e9       	ldi	r24, 0x95	; 149
    18ea:	92 e0       	ldi	r25, 0x02	; 2
    18ec:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);
    18f0:	8d e0       	ldi	r24, 0x0D	; 13
    18f2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			break;
    18f6:	80 ce       	rjmp	.-768    	; 0x15f8 <set_time+0x78>
			case TIMEOUT_ERROR :
			vSet_terminal_task_state(TERMINAL_TASK_LOGGED_OFF_STATE);
    18f8:	81 e0       	ldi	r24, 0x01	; 1
    18fa:	0e 94 85 11 	call	0x230a	; 0x230a <vSet_terminal_task_state>
			xSemaphoreGive(uart_mutex);
    18fe:	20 e0       	ldi	r18, 0x00	; 0
    1900:	40 e0       	ldi	r20, 0x00	; 0
    1902:	50 e0       	ldi	r21, 0x00	; 0
    1904:	60 e0       	ldi	r22, 0x00	; 0
    1906:	70 e0       	ldi	r23, 0x00	; 0
    1908:	80 91 2f 08 	lds	r24, 0x082F
    190c:	90 91 30 08 	lds	r25, 0x0830
    1910:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    1914:	0c c0       	rjmp	.+24     	; 0x192e <set_time+0x3ae>
					func_state=SET_MINUTE_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_HOUR_ERROR;
    1916:	09 2d       	mov	r16, r9
    1918:	e4 cf       	rjmp	.-56     	; 0x18e2 <set_time+0x362>
					func_state=SET_AM_PM_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_MINUTE_ERROR;
    191a:	0d 2d       	mov	r16, r13
    191c:	e2 cf       	rjmp	.-60     	; 0x18e2 <set_time+0x362>
					func_state=SET_DATE_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_AM_ERROR;
    191e:	0c 2d       	mov	r16, r12
    1920:	e0 cf       	rjmp	.-64     	; 0x18e2 <set_time+0x362>
					func_state=SET_MONTH_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_DATE_ERROR;
    1922:	0e 2d       	mov	r16, r14
    1924:	de cf       	rjmp	.-68     	; 0x18e2 <set_time+0x362>
					func_state=SET_YEAR_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_MONTH_ERROR;
    1926:	0f 2d       	mov	r16, r15
    1928:	dc cf       	rjmp	.-72     	; 0x18e2 <set_time+0x362>
					func_state=SAVE_TIME_STATE;
					func_error=NO_ERROR;
				}
				else
				{
					func_error=INVALID_YEAR_ERROR;
    192a:	0b 2d       	mov	r16, r11
    192c:	da cf       	rjmp	.-76     	; 0x18e2 <set_time+0x362>
			return;
			default :break;
		}
	}
	
    192e:	28 96       	adiw	r28, 0x08	; 8
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	f8 94       	cli
    1934:	de bf       	out	0x3e, r29	; 62
    1936:	0f be       	out	0x3f, r0	; 63
    1938:	cd bf       	out	0x3d, r28	; 61
    193a:	df 91       	pop	r29
    193c:	cf 91       	pop	r28
    193e:	1f 91       	pop	r17
    1940:	0f 91       	pop	r16
    1942:	ff 90       	pop	r15
    1944:	ef 90       	pop	r14
    1946:	df 90       	pop	r13
    1948:	cf 90       	pop	r12
    194a:	bf 90       	pop	r11
    194c:	af 90       	pop	r10
    194e:	9f 90       	pop	r9
    1950:	08 95       	ret

00001952 <get_user_input>:
//------------------------------------------------------------------------------
u8 get_user_input(void)
{
	u8 input=0;
	//check g_buffer index if not 1 invalid input
	if((g_command_index >1) || (g_command_index ==0))
    1952:	80 91 d0 01 	lds	r24, 0x01D0
    1956:	81 30       	cpi	r24, 0x01	; 1
    1958:	39 f4       	brne	.+14     	; 0x1968 <get_user_input+0x16>
		return INVALID_INPUT;
	}
	else 
	{
		//check valid user input
		input=g_command_array[0] - '0' - 1;
    195a:	80 91 d1 01 	lds	r24, 0x01D1
    195e:	81 53       	subi	r24, 0x31	; 49
		if((input >=0) && (input <MAX_MENU_OPTIONS))
    1960:	86 30       	cpi	r24, 0x06	; 6
    1962:	18 f0       	brcs	.+6      	; 0x196a <get_user_input+0x18>
		{
			return input;
		}
		else
		{
			return INVALID_INPUT;
    1964:	8f ef       	ldi	r24, 0xFF	; 255
    1966:	08 95       	ret
{
	u8 input=0;
	//check g_buffer index if not 1 invalid input
	if((g_command_index >1) || (g_command_index ==0))
	{
		return INVALID_INPUT;
    1968:	8f ef       	ldi	r24, 0xFF	; 255
		else
		{
			return INVALID_INPUT;
		}
	}
}
    196a:	08 95       	ret

0000196c <u8Get_input_buffer>:
	u8 data=UDR;
	xQueueSendToBackFromISR(g_terminal_task_q,(void*)&data,0);
}
//----------------------------------------------------------------------get user input data
u8 u8Get_input_buffer(void)
{
    196c:	cf 93       	push	r28
    196e:	df 93       	push	r29
    1970:	1f 92       	push	r1
    1972:	cd b7       	in	r28, 0x3d	; 61
    1974:	de b7       	in	r29, 0x3e	; 62
    1976:	e1 ed       	ldi	r30, 0xD1	; 209
    1978:	f1 e0       	ldi	r31, 0x01	; 1
{
	u8 data=UDR;
	xQueueSendToBackFromISR(g_terminal_task_q,(void*)&data,0);
}
//----------------------------------------------------------------------get user input data
u8 u8Get_input_buffer(void)
    197a:	8b ed       	ldi	r24, 0xDB	; 219
    197c:	91 e0       	ldi	r25, 0x01	; 1
	portBASE_TYPE que_state;
	u8 data;
	//reset default values
	for(g_command_index=0;g_command_index<MAX_TERMINAL_BUFFER_DATA;g_command_index++)
	{
		g_command_array[g_command_index]=0;
    197e:	11 92       	st	Z+, r1
u8 u8Get_input_buffer(void)
{
	portBASE_TYPE que_state;
	u8 data;
	//reset default values
	for(g_command_index=0;g_command_index<MAX_TERMINAL_BUFFER_DATA;g_command_index++)
    1980:	e8 17       	cp	r30, r24
    1982:	f9 07       	cpc	r31, r25
    1984:	e1 f7       	brne	.-8      	; 0x197e <u8Get_input_buffer+0x12>
	{
		g_command_array[g_command_index]=0;
	}
	g_command_index=0;
    1986:	10 92 d0 01 	sts	0x01D0, r1
    198a:	02 c0       	rjmp	.+4      	; 0x1990 <u8Get_input_buffer+0x24>
								//return @ key
								return AT_KEY;
					default:
								//fill the command array
								g_command_array[g_command_index]=data;
								g_command_index++;
    198c:	80 93 d0 01 	sts	0x01D0, r24
		g_command_array[g_command_index]=0;
	}
	g_command_index=0;
	while(1)
		{
			que_state= xQueueReceive(g_terminal_task_q,&data,10000/ portTICK_PERIOD_MS);
    1990:	40 e1       	ldi	r20, 0x10	; 16
    1992:	57 e2       	ldi	r21, 0x27	; 39
    1994:	be 01       	movw	r22, r28
    1996:	6f 5f       	subi	r22, 0xFF	; 255
    1998:	7f 4f       	sbci	r23, 0xFF	; 255
    199a:	80 91 db 01 	lds	r24, 0x01DB
    199e:	90 91 dc 01 	lds	r25, 0x01DC
    19a2:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
			if(que_state ==pdPASS)
    19a6:	81 30       	cpi	r24, 0x01	; 1
    19a8:	31 f5       	brne	.+76     	; 0x19f6 <u8Get_input_buffer+0x8a>
			{
				switch(data)
    19aa:	89 81       	ldd	r24, Y+1	; 0x01
    19ac:	8d 30       	cpi	r24, 0x0D	; 13
    19ae:	29 f0       	breq	.+10     	; 0x19ba <u8Get_input_buffer+0x4e>
    19b0:	80 34       	cpi	r24, 0x40	; 64
    19b2:	19 f1       	breq	.+70     	; 0x19fa <u8Get_input_buffer+0x8e>
    19b4:	88 30       	cpi	r24, 0x08	; 8
    19b6:	99 f4       	brne	.+38     	; 0x19de <u8Get_input_buffer+0x72>
    19b8:	02 c0       	rjmp	.+4      	; 0x19be <u8Get_input_buffer+0x52>
				{
					case ENTER_KEY :
										//signal shell parser to start parsing command
										return ENTER_KEY ;
    19ba:	8d e0       	ldi	r24, 0x0D	; 13
    19bc:	1f c0       	rjmp	.+62     	; 0x19fc <u8Get_input_buffer+0x90>
					case BACKSPACE_KEY :
										//delete last char
										g_command_index--;
    19be:	80 91 d0 01 	lds	r24, 0x01D0
    19c2:	81 50       	subi	r24, 0x01	; 1
    19c4:	18 f0       	brcs	.+6      	; 0x19cc <u8Get_input_buffer+0x60>
    19c6:	80 93 d0 01 	sts	0x01D0, r24
    19ca:	02 c0       	rjmp	.+4      	; 0x19d0 <u8Get_input_buffer+0x64>
										if(g_command_index==255)
										{
											g_command_index=0;
    19cc:	10 92 d0 01 	sts	0x01D0, r1
										}
										g_command_array[g_command_index]=0;
    19d0:	e0 91 d0 01 	lds	r30, 0x01D0
    19d4:	f0 e0       	ldi	r31, 0x00	; 0
    19d6:	ef 52       	subi	r30, 0x2F	; 47
    19d8:	fe 4f       	sbci	r31, 0xFE	; 254
    19da:	10 82       	st	Z, r1
										break;
    19dc:	d9 cf       	rjmp	.-78     	; 0x1990 <u8Get_input_buffer+0x24>
					case AT_KEY :
								//return @ key
								return AT_KEY;
					default:
								//fill the command array
								g_command_array[g_command_index]=data;
    19de:	90 91 d0 01 	lds	r25, 0x01D0
    19e2:	e9 2f       	mov	r30, r25
    19e4:	f0 e0       	ldi	r31, 0x00	; 0
    19e6:	ef 52       	subi	r30, 0x2F	; 47
    19e8:	fe 4f       	sbci	r31, 0xFE	; 254
    19ea:	80 83       	st	Z, r24
								g_command_index++;
    19ec:	89 2f       	mov	r24, r25
    19ee:	8f 5f       	subi	r24, 0xFF	; 255
								if(g_command_index==MAX_TERMINAL_BUFFER_DATA)
    19f0:	8a 30       	cpi	r24, 0x0A	; 10
    19f2:	61 f6       	brne	.-104    	; 0x198c <u8Get_input_buffer+0x20>
    19f4:	cd cf       	rjmp	.-102    	; 0x1990 <u8Get_input_buffer+0x24>
				}
			}
			else
			{
				//time out finish
				return TERMINAL_TIME_OUT;
    19f6:	85 e5       	ldi	r24, 0x55	; 85
    19f8:	01 c0       	rjmp	.+2      	; 0x19fc <u8Get_input_buffer+0x90>
										}
										g_command_array[g_command_index]=0;
										break;
					case AT_KEY :
								//return @ key
								return AT_KEY;
    19fa:	80 e4       	ldi	r24, 0x40	; 64
				return TERMINAL_TIME_OUT;
			}
			
		}
		
}
    19fc:	0f 90       	pop	r0
    19fe:	df 91       	pop	r29
    1a00:	cf 91       	pop	r28
    1a02:	08 95       	ret

00001a04 <invalid_password_print>:
	return TERMINAL_TIME_OUT;
}
//-------------------------------------------------
void invalid_password_print(void)
{
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1a04:	6f ef       	ldi	r22, 0xFF	; 255
    1a06:	7f ef       	ldi	r23, 0xFF	; 255
    1a08:	80 91 2f 08 	lds	r24, 0x082F
    1a0c:	90 91 30 08 	lds	r25, 0x0830
    1a10:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	vUartTransmit(ENTER_KEY);
    1a14:	8d e0       	ldi	r24, 0x0D	; 13
    1a16:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("Wrong entry "));
    1a1a:	8c e6       	ldi	r24, 0x6C	; 108
    1a1c:	93 e0       	ldi	r25, 0x03	; 3
    1a1e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(admin_invalid_count+48+1);
    1a22:	80 91 cf 01 	lds	r24, 0x01CF
    1a26:	8f 5c       	subi	r24, 0xCF	; 207
    1a28:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(ENTER_KEY);
    1a2c:	8d e0       	ldi	r24, 0x0D	; 13
    1a2e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	xSemaphoreGive(uart_mutex);
    1a32:	20 e0       	ldi	r18, 0x00	; 0
    1a34:	40 e0       	ldi	r20, 0x00	; 0
    1a36:	50 e0       	ldi	r21, 0x00	; 0
    1a38:	60 e0       	ldi	r22, 0x00	; 0
    1a3a:	70 e0       	ldi	r23, 0x00	; 0
    1a3c:	80 91 2f 08 	lds	r24, 0x082F
    1a40:	90 91 30 08 	lds	r25, 0x0830
    1a44:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	admin_invalid_count++;
    1a48:	80 91 cf 01 	lds	r24, 0x01CF
    1a4c:	8f 5f       	subi	r24, 0xFF	; 255
    1a4e:	80 93 cf 01 	sts	0x01CF, r24
	if(admin_invalid_count ==3)
    1a52:	83 30       	cpi	r24, 0x03	; 3
    1a54:	21 f4       	brne	.+8      	; 0x1a5e <invalid_password_print+0x5a>
	{
		//lock for root user
		task_state=TERMINAL_TASK_LOCKED_STATE;
    1a56:	85 e0       	ldi	r24, 0x05	; 5
    1a58:	80 93 60 00 	sts	0x0060, r24
		return;
    1a5c:	08 95       	ret
	}
	else
	{
		//else change state to logged of state and increment the failed count
		task_state=TERMINAL_TASK_CHECK_ADMIN_PASS_STATE;
    1a5e:	82 e0       	ldi	r24, 0x02	; 2
    1a60:	80 93 60 00 	sts	0x0060, r24
    1a64:	08 95       	ret

00001a66 <vMenu_users_options_print>:
	xSemaphoreGive(uart_mutex);				
}
//-------------------------------------------------------------------------------
static void vMenu_users_options_print(void)
{
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1a66:	6f ef       	ldi	r22, 0xFF	; 255
    1a68:	7f ef       	ldi	r23, 0xFF	; 255
    1a6a:	80 91 2f 08 	lds	r24, 0x082F
    1a6e:	90 91 30 08 	lds	r25, 0x0830
    1a72:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmit(ENTER_KEY);
    1a76:	8d e0       	ldi	r24, 0x0D	; 13
    1a78:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 1 TO LIST ALL USERS"));
    1a7c:	8d e5       	ldi	r24, 0x5D	; 93
    1a7e:	94 e0       	ldi	r25, 0x04	; 4
    1a80:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    1a84:	8d e0       	ldi	r24, 0x0D	; 13
    1a86:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 2 TO ADD NEW USER"));
    1a8a:	87 e7       	ldi	r24, 0x77	; 119
    1a8c:	94 e0       	ldi	r25, 0x04	; 4
    1a8e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);	
    1a92:	8d e0       	ldi	r24, 0x0D	; 13
    1a94:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 3 TO EDIT USER"));
    1a98:	8f e8       	ldi	r24, 0x8F	; 143
    1a9a:	94 e0       	ldi	r25, 0x04	; 4
    1a9c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    1aa0:	8d e0       	ldi	r24, 0x0D	; 13
    1aa2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 4 TO DELETE USER"));
    1aa6:	84 ea       	ldi	r24, 0xA4	; 164
    1aa8:	94 e0       	ldi	r25, 0x04	; 4
    1aaa:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    1aae:	8d e0       	ldi	r24, 0x0D	; 13
    1ab0:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 5 TO RESET FACTORY DEFAULT"));
    1ab4:	8b eb       	ldi	r24, 0xBB	; 187
    1ab6:	94 e0       	ldi	r25, 0x04	; 4
    1ab8:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    1abc:	8d e0       	ldi	r24, 0x0D	; 13
    1abe:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 6 TO BACK TO MENU"));
    1ac2:	8c ed       	ldi	r24, 0xDC	; 220
    1ac4:	94 e0       	ldi	r25, 0x04	; 4
    1ac6:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    1aca:	8d e0       	ldi	r24, 0x0D	; 13
    1acc:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(ENTER_KEY);
    1ad0:	8d e0       	ldi	r24, 0x0D	; 13
    1ad2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	
	xSemaphoreGive(uart_mutex);
    1ad6:	20 e0       	ldi	r18, 0x00	; 0
    1ad8:	40 e0       	ldi	r20, 0x00	; 0
    1ada:	50 e0       	ldi	r21, 0x00	; 0
    1adc:	60 e0       	ldi	r22, 0x00	; 0
    1ade:	70 e0       	ldi	r23, 0x00	; 0
    1ae0:	80 91 2f 08 	lds	r24, 0x082F
    1ae4:	90 91 30 08 	lds	r25, 0x0830
    1ae8:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    1aec:	08 95       	ret

00001aee <menu_users_choose>:
}
//----------------------------------------------------------------
void menu_users_choose(void)
{
	u8 returned_key;
	vUartTransmitString_program(PSTR(">>>"));
    1aee:	84 ef       	ldi	r24, 0xF4	; 244
    1af0:	94 e0       	ldi	r25, 0x04	; 4
    1af2:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	returned_key=u8Get_input_buffer();
    1af6:	0e 94 b6 0c 	call	0x196c	; 0x196c <u8Get_input_buffer>
	if(returned_key ==ENTER_KEY)
    1afa:	8d 30       	cpi	r24, 0x0D	; 13
    1afc:	a9 f4       	brne	.+42     	; 0x1b28 <menu_users_choose+0x3a>
	{
		//check input
		returned_key=get_user_input();
    1afe:	0e 94 a9 0c 	call	0x1952	; 0x1952 <get_user_input>
		if (returned_key !=INVALID_INPUT)
    1b02:	8f 3f       	cpi	r24, 0xFF	; 255
    1b04:	b1 f0       	breq	.+44     	; 0x1b32 <menu_users_choose+0x44>
		{
			if(returned_key ==BACK_TO_MAIN_MENU)
    1b06:	85 30       	cpi	r24, 0x05	; 5
    1b08:	21 f4       	brne	.+8      	; 0x1b12 <menu_users_choose+0x24>
			{
				task_state=TERMINAL_TASK_MENU_STATE;
    1b0a:	83 e0       	ldi	r24, 0x03	; 3
    1b0c:	80 93 60 00 	sts	0x0060, r24
    1b10:	08 95       	ret
			}
			else
			{
				user_menu_ptr[returned_key]();
    1b12:	e8 2f       	mov	r30, r24
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	ee 0f       	add	r30, r30
    1b18:	ff 1f       	adc	r31, r31
    1b1a:	ef 59       	subi	r30, 0x9F	; 159
    1b1c:	ff 4f       	sbci	r31, 0xFF	; 255
    1b1e:	01 90       	ld	r0, Z+
    1b20:	f0 81       	ld	r31, Z
    1b22:	e0 2d       	mov	r30, r0
    1b24:	09 95       	icall
    1b26:	08 95       	ret
			}
		}
	}
	else if(returned_key==TERMINAL_TIME_OUT)
    1b28:	85 35       	cpi	r24, 0x55	; 85
    1b2a:	19 f4       	brne	.+6      	; 0x1b32 <menu_users_choose+0x44>
	{
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    1b2c:	81 e0       	ldi	r24, 0x01	; 1
    1b2e:	80 93 60 00 	sts	0x0060, r24
    1b32:	08 95       	ret

00001b34 <u8Get_user_password>:
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
	}
}
//------------------------------------------------------
u8 u8Get_user_password(void)
{
    1b34:	1f 93       	push	r17
    1b36:	cf 93       	push	r28
    1b38:	df 93       	push	r29
    1b3a:	cd b7       	in	r28, 0x3d	; 61
    1b3c:	de b7       	in	r29, 0x3e	; 62
    1b3e:	61 97       	sbiw	r28, 0x11	; 17
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	f8 94       	cli
    1b44:	de bf       	out	0x3e, r29	; 62
    1b46:	0f be       	out	0x3f, r0	; 63
    1b48:	cd bf       	out	0x3d, r28	; 61
	u8 returned_key;
	u8 error;
	user_t temp;
	u8 temp_id;
	returned_key=u8Get_input_buffer();
    1b4a:	0e 94 b6 0c 	call	0x196c	; 0x196c <u8Get_input_buffer>
	if(returned_key ==ENTER_KEY)
    1b4e:	8d 30       	cpi	r24, 0x0D	; 13
    1b50:	b9 f5       	brne	.+110    	; 0x1bc0 <u8Get_user_password+0x8c>
	{
		//check password
		if(g_command_index !=4)
    1b52:	80 91 d0 01 	lds	r24, 0x01D0
    1b56:	84 30       	cpi	r24, 0x04	; 4
    1b58:	d1 f5       	brne	.+116    	; 0x1bce <u8Get_user_password+0x9a>
		{
			return PASSWORD_NOT_FOUND;
		}
		//check password
		xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    1b5a:	6f ef       	ldi	r22, 0xFF	; 255
    1b5c:	7f ef       	ldi	r23, 0xFF	; 255
    1b5e:	80 91 2d 08 	lds	r24, 0x082D
    1b62:	90 91 2e 08 	lds	r25, 0x082E
    1b66:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		error=u8EXTERNAL_EEPROM_search_by_password(g_command_array,temp.name,&temp_id,&(temp.type));
    1b6a:	9e 01       	movw	r18, r28
    1b6c:	21 5f       	subi	r18, 0xF1	; 241
    1b6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b70:	ae 01       	movw	r20, r28
    1b72:	4f 5e       	subi	r20, 0xEF	; 239
    1b74:	5f 4f       	sbci	r21, 0xFF	; 255
    1b76:	be 01       	movw	r22, r28
    1b78:	6f 5f       	subi	r22, 0xFF	; 255
    1b7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b7c:	81 ed       	ldi	r24, 0xD1	; 209
    1b7e:	91 e0       	ldi	r25, 0x01	; 1
    1b80:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <u8EXTERNAL_EEPROM_search_by_password>
    1b84:	18 2f       	mov	r17, r24
		xSemaphoreGive(i2c_mutex);
    1b86:	20 e0       	ldi	r18, 0x00	; 0
    1b88:	40 e0       	ldi	r20, 0x00	; 0
    1b8a:	50 e0       	ldi	r21, 0x00	; 0
    1b8c:	60 e0       	ldi	r22, 0x00	; 0
    1b8e:	70 e0       	ldi	r23, 0x00	; 0
    1b90:	80 91 2d 08 	lds	r24, 0x082D
    1b94:	90 91 2e 08 	lds	r25, 0x082E
    1b98:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		if(error ==PASSWORD_FOUND)
    1b9c:	11 11       	cpse	r17, r1
    1b9e:	19 c0       	rjmp	.+50     	; 0x1bd2 <u8Get_user_password+0x9e>
		{
			current_id=temp_id;
    1ba0:	89 89       	ldd	r24, Y+17	; 0x11
    1ba2:	80 93 41 08 	sts	0x0841, r24
			current_admin=temp;
    1ba6:	80 e1       	ldi	r24, 0x10	; 16
    1ba8:	fe 01       	movw	r30, r28
    1baa:	31 96       	adiw	r30, 0x01	; 1
    1bac:	a1 e3       	ldi	r26, 0x31	; 49
    1bae:	b8 e0       	ldi	r27, 0x08	; 8
    1bb0:	01 90       	ld	r0, Z+
    1bb2:	0d 92       	st	X+, r0
    1bb4:	8a 95       	dec	r24
    1bb6:	e1 f7       	brne	.-8      	; 0x1bb0 <u8Get_user_password+0x7c>
			admin_invalid_count=0;
    1bb8:	10 92 cf 01 	sts	0x01CF, r1
			return PASSWORD_FOUND;
    1bbc:	80 e0       	ldi	r24, 0x00	; 0
    1bbe:	0c c0       	rjmp	.+24     	; 0x1bd8 <u8Get_user_password+0xa4>
		}			
	}
	else if(returned_key==TERMINAL_TIME_OUT)
    1bc0:	85 35       	cpi	r24, 0x55	; 85
    1bc2:	49 f4       	brne	.+18     	; 0x1bd6 <u8Get_user_password+0xa2>
	{
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    1bc4:	81 e0       	ldi	r24, 0x01	; 1
    1bc6:	80 93 60 00 	sts	0x0060, r24
		return TERMINAL_TIME_OUT;
    1bca:	85 e5       	ldi	r24, 0x55	; 85
    1bcc:	05 c0       	rjmp	.+10     	; 0x1bd8 <u8Get_user_password+0xa4>
	if(returned_key ==ENTER_KEY)
	{
		//check password
		if(g_command_index !=4)
		{
			return PASSWORD_NOT_FOUND;
    1bce:	8f ef       	ldi	r24, 0xFF	; 255
    1bd0:	03 c0       	rjmp	.+6      	; 0x1bd8 <u8Get_user_password+0xa4>
	}
	else
	{
		return PASSWORD_NOT_FOUND;
	}
	return PASSWORD_NOT_FOUND;
    1bd2:	8f ef       	ldi	r24, 0xFF	; 255
    1bd4:	01 c0       	rjmp	.+2      	; 0x1bd8 <u8Get_user_password+0xa4>
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
		return TERMINAL_TIME_OUT;
	}
	else
	{
		return PASSWORD_NOT_FOUND;
    1bd6:	8f ef       	ldi	r24, 0xFF	; 255
	}
	return PASSWORD_NOT_FOUND;
}
    1bd8:	61 96       	adiw	r28, 0x11	; 17
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	de bf       	out	0x3e, r29	; 62
    1be0:	0f be       	out	0x3f, r0	; 63
    1be2:	cd bf       	out	0x3d, r28	; 61
    1be4:	df 91       	pop	r29
    1be6:	cf 91       	pop	r28
    1be8:	1f 91       	pop	r17
    1bea:	08 95       	ret

00001bec <vTerminal_task_q_set>:
}

//-------------------------------------------------------
void vTerminal_task_q_set(xQueueHandle key)
{
	g_terminal_task_q=key;
    1bec:	90 93 dc 01 	sts	0x01DC, r25
    1bf0:	80 93 db 01 	sts	0x01DB, r24
    1bf4:	08 95       	ret

00001bf6 <rx_complete_isr_func>:
{
	return g_terminal_task_q;
}
//----------------------------------------------ISR call back FUNCTION
void rx_complete_isr_func(void)
{
    1bf6:	cf 93       	push	r28
    1bf8:	df 93       	push	r29
    1bfa:	1f 92       	push	r1
    1bfc:	cd b7       	in	r28, 0x3d	; 61
    1bfe:	de b7       	in	r29, 0x3e	; 62
	u8 data=UDR;
    1c00:	8c b1       	in	r24, 0x0c	; 12
    1c02:	89 83       	std	Y+1, r24	; 0x01
	xQueueSendToBackFromISR(g_terminal_task_q,(void*)&data,0);
    1c04:	20 e0       	ldi	r18, 0x00	; 0
    1c06:	40 e0       	ldi	r20, 0x00	; 0
    1c08:	50 e0       	ldi	r21, 0x00	; 0
    1c0a:	be 01       	movw	r22, r28
    1c0c:	6f 5f       	subi	r22, 0xFF	; 255
    1c0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c10:	80 91 db 01 	lds	r24, 0x01DB
    1c14:	90 91 dc 01 	lds	r25, 0x01DC
    1c18:	0e 94 eb 2b 	call	0x57d6	; 0x57d6 <xQueueGenericSendFromISR>
}
    1c1c:	0f 90       	pop	r0
    1c1e:	df 91       	pop	r29
    1c20:	cf 91       	pop	r28
    1c22:	08 95       	ret

00001c24 <get_u8>:
		}
	}
}
//-----------------------------------------------------------------------------------
u8 get_u8(u8* data)
{
    1c24:	cf 93       	push	r28
    1c26:	df 93       	push	r29
    1c28:	ec 01       	movw	r28, r24
	u8 first,second,third,result;
	result=u8Get_input_buffer();
    1c2a:	0e 94 b6 0c 	call	0x196c	; 0x196c <u8Get_input_buffer>
	if(result==ENTER_KEY)
    1c2e:	8d 30       	cpi	r24, 0x0D	; 13
    1c30:	c9 f5       	brne	.+114    	; 0x1ca4 <get_u8+0x80>
	{
		//if 1 digit
		if(g_command_index == 1)
    1c32:	80 91 d0 01 	lds	r24, 0x01D0
    1c36:	81 30       	cpi	r24, 0x01	; 1
    1c38:	31 f4       	brne	.+12     	; 0x1c46 <get_u8+0x22>
		{
			first=g_command_array[0] - '0';
    1c3a:	80 91 d1 01 	lds	r24, 0x01D1
    1c3e:	80 53       	subi	r24, 0x30	; 48
			*data=first;
    1c40:	88 83       	st	Y, r24
			return TERMINAL_RETURN_U8;
    1c42:	8a ea       	ldi	r24, 0xAA	; 170
    1c44:	34 c0       	rjmp	.+104    	; 0x1cae <get_u8+0x8a>
		}
		//if 2 digit
		else if(g_command_index == 2)
    1c46:	82 30       	cpi	r24, 0x02	; 2
    1c48:	79 f4       	brne	.+30     	; 0x1c68 <get_u8+0x44>
		{
			second=g_command_array[0] - '0';
			first=g_command_array[1] - '0';
    1c4a:	90 91 d2 01 	lds	r25, 0x01D2
    1c4e:	90 53       	subi	r25, 0x30	; 48
			return TERMINAL_RETURN_U8;
		}
		//if 2 digit
		else if(g_command_index == 2)
		{
			second=g_command_array[0] - '0';
    1c50:	80 91 d1 01 	lds	r24, 0x01D1
    1c54:	80 53       	subi	r24, 0x30	; 48
			first=g_command_array[1] - '0';
			
			*data=first+(second*10);
    1c56:	88 0f       	add	r24, r24
    1c58:	28 2f       	mov	r18, r24
    1c5a:	22 0f       	add	r18, r18
    1c5c:	22 0f       	add	r18, r18
    1c5e:	82 0f       	add	r24, r18
    1c60:	89 0f       	add	r24, r25
    1c62:	88 83       	st	Y, r24
			return TERMINAL_RETURN_U8;
    1c64:	8a ea       	ldi	r24, 0xAA	; 170
    1c66:	23 c0       	rjmp	.+70     	; 0x1cae <get_u8+0x8a>
		}
		else if(g_command_index == 3)
    1c68:	83 30       	cpi	r24, 0x03	; 3
    1c6a:	f1 f4       	brne	.+60     	; 0x1ca8 <get_u8+0x84>
		{
			third=g_command_array[0] - '0';
    1c6c:	80 91 d1 01 	lds	r24, 0x01D1
    1c70:	80 53       	subi	r24, 0x30	; 48
			second=g_command_array[1] - '0';
    1c72:	90 91 d2 01 	lds	r25, 0x01D2
    1c76:	90 53       	subi	r25, 0x30	; 48
			first=g_command_array[2] - '0';
    1c78:	20 91 d3 01 	lds	r18, 0x01D3
    1c7c:	20 53       	subi	r18, 0x30	; 48
			if(third >= 2 )
    1c7e:	82 30       	cpi	r24, 0x02	; 2
    1c80:	20 f0       	brcs	.+8      	; 0x1c8a <get_u8+0x66>
			{
				if(second >=5)
    1c82:	95 30       	cpi	r25, 0x05	; 5
    1c84:	10 f0       	brcs	.+4      	; 0x1c8a <get_u8+0x66>
				{
					if(first >5)
    1c86:	26 30       	cpi	r18, 0x06	; 6
    1c88:	88 f4       	brcc	.+34     	; 0x1cac <get_u8+0x88>
						//error
						return TERMINAL_TIME_OUT;
					}
				}
			}
			*data=first+(second*10)+(third*100);
    1c8a:	99 0f       	add	r25, r25
    1c8c:	39 2f       	mov	r19, r25
    1c8e:	33 0f       	add	r19, r19
    1c90:	33 0f       	add	r19, r19
    1c92:	93 0f       	add	r25, r19
    1c94:	34 e6       	ldi	r19, 0x64	; 100
    1c96:	83 9f       	mul	r24, r19
    1c98:	90 0d       	add	r25, r0
    1c9a:	11 24       	eor	r1, r1
    1c9c:	29 0f       	add	r18, r25
    1c9e:	28 83       	st	Y, r18
			return TERMINAL_RETURN_U8;
    1ca0:	8a ea       	ldi	r24, 0xAA	; 170
    1ca2:	05 c0       	rjmp	.+10     	; 0x1cae <get_u8+0x8a>
			return TERMINAL_TIME_OUT;
		}
	}
	else
	{
		return TERMINAL_TIME_OUT;
    1ca4:	85 e5       	ldi	r24, 0x55	; 85
    1ca6:	03 c0       	rjmp	.+6      	; 0x1cae <get_u8+0x8a>
			*data=first+(second*10)+(third*100);
			return TERMINAL_RETURN_U8;
		}
		else
		{
			return TERMINAL_TIME_OUT;
    1ca8:	85 e5       	ldi	r24, 0x55	; 85
    1caa:	01 c0       	rjmp	.+2      	; 0x1cae <get_u8+0x8a>
				if(second >=5)
				{
					if(first >5)
					{
						//error
						return TERMINAL_TIME_OUT;
    1cac:	85 e5       	ldi	r24, 0x55	; 85
	else
	{
		return TERMINAL_TIME_OUT;
	}
	
}
    1cae:	df 91       	pop	r29
    1cb0:	cf 91       	pop	r28
    1cb2:	08 95       	ret

00001cb4 <get_user_name>:
//-----------------------------------------------------------------------
u8 get_user_name(u8* data)
{
    1cb4:	cf 93       	push	r28
    1cb6:	df 93       	push	r29
    1cb8:	ec 01       	movw	r28, r24
	u8 first,result;
	result=u8Get_input_buffer();
    1cba:	0e 94 b6 0c 	call	0x196c	; 0x196c <u8Get_input_buffer>
	if(result==ENTER_KEY)
    1cbe:	8d 30       	cpi	r24, 0x0D	; 13
    1cc0:	c1 f4       	brne	.+48     	; 0x1cf2 <get_user_name+0x3e>
	{
		//if > length
		if(g_command_index > MAX_USER_NAME+1)
    1cc2:	30 91 d0 01 	lds	r19, 0x01D0
    1cc6:	3b 30       	cpi	r19, 0x0B	; 11
    1cc8:	b0 f4       	brcc	.+44     	; 0x1cf6 <get_user_name+0x42>
			
			return TERMINAL_RETURN_U8;
		}
		else
		{
			for(first=0;first<g_command_index;first++)
    1cca:	33 23       	and	r19, r19
    1ccc:	69 f0       	breq	.+26     	; 0x1ce8 <get_user_name+0x34>
    1cce:	e1 ed       	ldi	r30, 0xD1	; 209
    1cd0:	f1 e0       	ldi	r31, 0x01	; 1
    1cd2:	de 01       	movw	r26, r28
		return TERMINAL_TIME_OUT;
	}
	
}
//-----------------------------------------------------------------------
u8 get_user_name(u8* data)
    1cd4:	83 2f       	mov	r24, r19
    1cd6:	81 50       	subi	r24, 0x01	; 1
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	8e 52       	subi	r24, 0x2E	; 46
    1cdc:	9e 4f       	sbci	r25, 0xFE	; 254
		}
		else
		{
			for(first=0;first<g_command_index;first++)
			{
				data[first]=g_command_array[first];
    1cde:	21 91       	ld	r18, Z+
    1ce0:	2d 93       	st	X+, r18
			
			return TERMINAL_RETURN_U8;
		}
		else
		{
			for(first=0;first<g_command_index;first++)
    1ce2:	e8 17       	cp	r30, r24
    1ce4:	f9 07       	cpc	r31, r25
    1ce6:	d9 f7       	brne	.-10     	; 0x1cde <get_user_name+0x2a>
			{
				data[first]=g_command_array[first];
			}
			data[first]='\0';
    1ce8:	c3 0f       	add	r28, r19
    1cea:	d1 1d       	adc	r29, r1
    1cec:	18 82       	st	Y, r1
			return VALID_NAME;
    1cee:	80 e0       	ldi	r24, 0x00	; 0
    1cf0:	03 c0       	rjmp	.+6      	; 0x1cf8 <get_user_name+0x44>
		}
		
	}
	else
	{
		return TERMINAL_TIME_OUT;
    1cf2:	85 e5       	ldi	r24, 0x55	; 85
    1cf4:	01 c0       	rjmp	.+2      	; 0x1cf8 <get_user_name+0x44>
	{
		//if > length
		if(g_command_index > MAX_USER_NAME+1)
		{
			
			return TERMINAL_RETURN_U8;
    1cf6:	8a ea       	ldi	r24, 0xAA	; 170
	else
	{
		return TERMINAL_TIME_OUT;
	}
	return TERMINAL_TIME_OUT;
}
    1cf8:	df 91       	pop	r29
    1cfa:	cf 91       	pop	r28
    1cfc:	08 95       	ret

00001cfe <u8Get_user_password_arr>:
	}
	return PASSWORD_NOT_FOUND;
}
//----------------------------------------------------------
u8 u8Get_user_password_arr(u8 * password)
{
    1cfe:	cf 93       	push	r28
    1d00:	df 93       	push	r29
    1d02:	d8 2f       	mov	r29, r24
    1d04:	c9 2f       	mov	r28, r25
	u8 returned_key;
	u8 index;
	returned_key=u8Get_input_buffer();
    1d06:	0e 94 b6 0c 	call	0x196c	; 0x196c <u8Get_input_buffer>
	if(returned_key ==ENTER_KEY)
    1d0a:	8d 30       	cpi	r24, 0x0D	; 13
    1d0c:	89 f4       	brne	.+34     	; 0x1d30 <u8Get_user_password_arr+0x32>
	{
		//check password
		if(g_command_index !=4)
    1d0e:	80 91 d0 01 	lds	r24, 0x01D0
    1d12:	84 30       	cpi	r24, 0x04	; 4
    1d14:	a1 f4       	brne	.+40     	; 0x1d3e <u8Get_user_password_arr+0x40>
    1d16:	e1 ed       	ldi	r30, 0xD1	; 209
    1d18:	f1 e0       	ldi	r31, 0x01	; 1
    1d1a:	ad 2f       	mov	r26, r29
    1d1c:	bc 2f       	mov	r27, r28
		return PASSWORD_NOT_FOUND;
	}
	return PASSWORD_NOT_FOUND;
}
//----------------------------------------------------------
u8 u8Get_user_password_arr(u8 * password)
    1d1e:	85 ed       	ldi	r24, 0xD5	; 213
    1d20:	91 e0       	ldi	r25, 0x01	; 1
		}
		else
		{
			for(index=0;index<MAX_USER_PASSWORD;index++)
			{
				password[index]=g_command_array[index];
    1d22:	21 91       	ld	r18, Z+
    1d24:	2d 93       	st	X+, r18
		{
			return PASSWORD_NOT_VALID;
		}
		else
		{
			for(index=0;index<MAX_USER_PASSWORD;index++)
    1d26:	e8 17       	cp	r30, r24
    1d28:	f9 07       	cpc	r31, r25
    1d2a:	d9 f7       	brne	.-10     	; 0x1d22 <u8Get_user_password_arr+0x24>
			{
				password[index]=g_command_array[index];
			}
			return PASSWORD_VALID;
    1d2c:	80 e0       	ldi	r24, 0x00	; 0
    1d2e:	0a c0       	rjmp	.+20     	; 0x1d44 <u8Get_user_password_arr+0x46>
		}
	
	}
	else if(returned_key==TERMINAL_TIME_OUT)
    1d30:	85 35       	cpi	r24, 0x55	; 85
    1d32:	39 f4       	brne	.+14     	; 0x1d42 <u8Get_user_password_arr+0x44>
	{
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	80 93 60 00 	sts	0x0060, r24
		return PASSWORD_NOT_VALID;
    1d3a:	8f ef       	ldi	r24, 0xFF	; 255
    1d3c:	03 c0       	rjmp	.+6      	; 0x1d44 <u8Get_user_password_arr+0x46>
	if(returned_key ==ENTER_KEY)
	{
		//check password
		if(g_command_index !=4)
		{
			return PASSWORD_NOT_VALID;
    1d3e:	8f ef       	ldi	r24, 0xFF	; 255
    1d40:	01 c0       	rjmp	.+2      	; 0x1d44 <u8Get_user_password_arr+0x46>
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
		return PASSWORD_NOT_VALID;
	}
	else
	{
		return PASSWORD_NOT_VALID;
    1d42:	8f ef       	ldi	r24, 0xFF	; 255
	}
	return PASSWORD_NOT_VALID;
}
    1d44:	df 91       	pop	r29
    1d46:	cf 91       	pop	r28
    1d48:	08 95       	ret

00001d4a <vTerminal_task>:
u8 admin_invalid_count=0;	
user_t current_admin;
u8 current_id;
//----------------------------------------------------------------	
void vTerminal_task(void *pvParameters)
{	
    1d4a:	cf 93       	push	r28
    1d4c:	df 93       	push	r29
    1d4e:	1f 92       	push	r1
    1d50:	cd b7       	in	r28, 0x3d	; 61
    1d52:	de b7       	in	r29, 0x3e	; 62
//-----------------------------------------------------------------
//check if root user
void vTerminal_users_menu_state(void)
{
	u8 error;
	if (current_admin.type>ROOT_USER)
    1d54:	0f e3       	ldi	r16, 0x3F	; 63
    1d56:	18 e0       	ldi	r17, 0x08	; 8
			xSemaphoreTake(uart_mutex,portMAX_DELAY);
			vUartTransmit(ENTER_KEY);
			vUartTransmitString_program(PSTR("WRONG ROOT PASSWORD .... "));
			vUartTransmit(ENTER_KEY);
			xSemaphoreGive(uart_mutex);
			task_state=TERMINAL_TASK_MENU_STATE;
    1d58:	0f 2e       	mov	r0, r31
    1d5a:	f3 e0       	ldi	r31, 0x03	; 3
    1d5c:	5f 2e       	mov	r5, r31
    1d5e:	f0 2d       	mov	r31, r0
		}
	
	}
	else if(returned_key==TERMINAL_TIME_OUT)
	{
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    1d60:	77 24       	eor	r7, r7
    1d62:	73 94       	inc	r7
		returned_key=get_user_input();
		if (returned_key !=INVALID_INPUT)
		{
			if(returned_key ==USERS_MENU)
			{
				task_state=TERMINAL_TASK_USERS_MENU_STATE;
    1d64:	68 94       	set
    1d66:	22 24       	eor	r2, r2
    1d68:	22 f8       	bld	r2, 2
		xSemaphoreGive(uart_mutex);
		returned_key=u8Get_user_password_arr(current_admin.password);
		if(returned_key==PASSWORD_VALID)
		{
			//set password
			current_admin.name[0]='R';
    1d6a:	0f 2e       	mov	r0, r31
    1d6c:	f1 e3       	ldi	r31, 0x31	; 49
    1d6e:	ef 2e       	mov	r14, r31
    1d70:	f8 e0       	ldi	r31, 0x08	; 8
    1d72:	ff 2e       	mov	r15, r31
    1d74:	f0 2d       	mov	r31, r0
    1d76:	0f 2e       	mov	r0, r31
    1d78:	f2 e5       	ldi	r31, 0x52	; 82
    1d7a:	3f 2e       	mov	r3, r31
    1d7c:	f0 2d       	mov	r31, r0
			current_admin.name[1]='O';
    1d7e:	0f 2e       	mov	r0, r31
    1d80:	f2 e3       	ldi	r31, 0x32	; 50
    1d82:	8f 2e       	mov	r8, r31
    1d84:	f8 e0       	ldi	r31, 0x08	; 8
    1d86:	9f 2e       	mov	r9, r31
    1d88:	f0 2d       	mov	r31, r0
    1d8a:	0f 2e       	mov	r0, r31
    1d8c:	ff e4       	ldi	r31, 0x4F	; 79
    1d8e:	6f 2e       	mov	r6, r31
    1d90:	f0 2d       	mov	r31, r0
			current_admin.name[2]='O';
    1d92:	0f 2e       	mov	r0, r31
    1d94:	f3 e3       	ldi	r31, 0x33	; 51
    1d96:	af 2e       	mov	r10, r31
    1d98:	f8 e0       	ldi	r31, 0x08	; 8
    1d9a:	bf 2e       	mov	r11, r31
    1d9c:	f0 2d       	mov	r31, r0
			current_admin.name[3]='T';
    1d9e:	0f 2e       	mov	r0, r31
    1da0:	f4 e3       	ldi	r31, 0x34	; 52
    1da2:	cf 2e       	mov	r12, r31
    1da4:	f8 e0       	ldi	r31, 0x08	; 8
    1da6:	df 2e       	mov	r13, r31
    1da8:	f0 2d       	mov	r31, r0
    1daa:	0f 2e       	mov	r0, r31
    1dac:	f4 e5       	ldi	r31, 0x54	; 84
    1dae:	4f 2e       	mov	r4, r31
    1db0:	f0 2d       	mov	r31, r0
//----------------------------------------------------------------	
void vTerminal_task(void *pvParameters)
{	
	while(1)
	{
		switch(task_state)
    1db2:	80 91 60 00 	lds	r24, 0x0060
    1db6:	82 30       	cpi	r24, 0x02	; 2
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <vTerminal_task+0x72>
    1dba:	09 c1       	rjmp	.+530    	; 0x1fce <vTerminal_task+0x284>
    1dbc:	28 f4       	brcc	.+10     	; 0x1dc8 <vTerminal_task+0x7e>
    1dbe:	88 23       	and	r24, r24
    1dc0:	59 f0       	breq	.+22     	; 0x1dd8 <vTerminal_task+0x8e>
    1dc2:	81 30       	cpi	r24, 0x01	; 1
    1dc4:	c1 f7       	brne	.-16     	; 0x1db6 <vTerminal_task+0x6c>
    1dc6:	ed c0       	rjmp	.+474    	; 0x1fa2 <vTerminal_task+0x258>
    1dc8:	84 30       	cpi	r24, 0x04	; 4
    1dca:	09 f4       	brne	.+2      	; 0x1dce <vTerminal_task+0x84>
    1dcc:	ba c1       	rjmp	.+884    	; 0x2142 <vTerminal_task+0x3f8>
    1dce:	08 f4       	brcc	.+2      	; 0x1dd2 <vTerminal_task+0x88>
    1dd0:	4d c1       	rjmp	.+666    	; 0x206c <vTerminal_task+0x322>
    1dd2:	85 30       	cpi	r24, 0x05	; 5
    1dd4:	81 f7       	brne	.-32     	; 0x1db6 <vTerminal_task+0x6c>
    1dd6:	23 c2       	rjmp	.+1094   	; 0x221e <vTerminal_task+0x4d4>
}
//-----------------------------------------------------------
static void vTerminal_factory_state(void)
{
	u8 returned_key;
	xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    1dd8:	6f ef       	ldi	r22, 0xFF	; 255
    1dda:	7f ef       	ldi	r23, 0xFF	; 255
    1ddc:	80 91 2d 08 	lds	r24, 0x082D
    1de0:	90 91 2e 08 	lds	r25, 0x082E
    1de4:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	vEXTERNAL_EEPROM_reset();
    1de8:	0e 94 c6 1f 	call	0x3f8c	; 0x3f8c <vEXTERNAL_EEPROM_reset>
	xSemaphoreGive(i2c_mutex);
    1dec:	20 e0       	ldi	r18, 0x00	; 0
    1dee:	40 e0       	ldi	r20, 0x00	; 0
    1df0:	50 e0       	ldi	r21, 0x00	; 0
    1df2:	60 e0       	ldi	r22, 0x00	; 0
    1df4:	70 e0       	ldi	r23, 0x00	; 0
    1df6:	80 91 2d 08 	lds	r24, 0x082D
    1dfa:	90 91 2e 08 	lds	r25, 0x082E
    1dfe:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	
	
	//enter password
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1e02:	6f ef       	ldi	r22, 0xFF	; 255
    1e04:	7f ef       	ldi	r23, 0xFF	; 255
    1e06:	80 91 2f 08 	lds	r24, 0x082F
    1e0a:	90 91 30 08 	lds	r25, 0x0830
    1e0e:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmit(ENTER_KEY);
    1e12:	8d e0       	ldi	r24, 0x0D	; 13
    1e14:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER ROOT PASSWORD : "));
    1e18:	8c ea       	ldi	r24, 0xAC	; 172
    1e1a:	92 e0       	ldi	r25, 0x02	; 2
    1e1c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	xSemaphoreGive(uart_mutex);
    1e20:	20 e0       	ldi	r18, 0x00	; 0
    1e22:	40 e0       	ldi	r20, 0x00	; 0
    1e24:	50 e0       	ldi	r21, 0x00	; 0
    1e26:	60 e0       	ldi	r22, 0x00	; 0
    1e28:	70 e0       	ldi	r23, 0x00	; 0
    1e2a:	80 91 2f 08 	lds	r24, 0x082F
    1e2e:	90 91 30 08 	lds	r25, 0x0830
    1e32:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	returned_key=u8Get_user_password();
    1e36:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <u8Get_user_password>
	if(returned_key==PASSWORD_FOUND)
    1e3a:	81 11       	cpse	r24, r1
    1e3c:	91 c0       	rjmp	.+290    	; 0x1f60 <vTerminal_task+0x216>
	{
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1e3e:	6f ef       	ldi	r22, 0xFF	; 255
    1e40:	7f ef       	ldi	r23, 0xFF	; 255
    1e42:	80 91 2f 08 	lds	r24, 0x082F
    1e46:	90 91 30 08 	lds	r25, 0x0830
    1e4a:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmit(ENTER_KEY);
    1e4e:	8d e0       	ldi	r24, 0x0D	; 13
    1e50:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmitString_program(PSTR("LOGGING IN ....... "));
    1e54:	83 ec       	ldi	r24, 0xC3	; 195
    1e56:	92 e0       	ldi	r25, 0x02	; 2
    1e58:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);
    1e5c:	8d e0       	ldi	r24, 0x0D	; 13
    1e5e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmit(ENTER_KEY);
    1e62:	8d e0       	ldi	r24, 0x0D	; 13
    1e64:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		//change root password
		vUartTransmitString_program(PSTR("CHANGE ROOT PASSWORD : "));
    1e68:	87 ed       	ldi	r24, 0xD7	; 215
    1e6a:	92 e0       	ldi	r25, 0x02	; 2
    1e6c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		xSemaphoreGive(uart_mutex);
    1e70:	20 e0       	ldi	r18, 0x00	; 0
    1e72:	40 e0       	ldi	r20, 0x00	; 0
    1e74:	50 e0       	ldi	r21, 0x00	; 0
    1e76:	60 e0       	ldi	r22, 0x00	; 0
    1e78:	70 e0       	ldi	r23, 0x00	; 0
    1e7a:	80 91 2f 08 	lds	r24, 0x082F
    1e7e:	90 91 30 08 	lds	r25, 0x0830
    1e82:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		returned_key=u8Get_user_password_arr(current_admin.password);
    1e86:	8b e3       	ldi	r24, 0x3B	; 59
    1e88:	98 e0       	ldi	r25, 0x08	; 8
    1e8a:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <u8Get_user_password_arr>
		if(returned_key==PASSWORD_VALID)
    1e8e:	81 11       	cpse	r24, r1
    1e90:	46 c0       	rjmp	.+140    	; 0x1f1e <vTerminal_task+0x1d4>
		{
			//set password
			current_admin.name[0]='R';
    1e92:	f7 01       	movw	r30, r14
    1e94:	30 82       	st	Z, r3
			current_admin.name[1]='O';
    1e96:	f4 01       	movw	r30, r8
    1e98:	60 82       	st	Z, r6
			current_admin.name[2]='O';
    1e9a:	f5 01       	movw	r30, r10
    1e9c:	60 82       	st	Z, r6
			current_admin.name[3]='T';
    1e9e:	f6 01       	movw	r30, r12
    1ea0:	40 82       	st	Z, r4
			current_admin.type=ROOT_USER;
    1ea2:	f8 01       	movw	r30, r16
    1ea4:	10 82       	st	Z, r1
			//edit user
			xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    1ea6:	6f ef       	ldi	r22, 0xFF	; 255
    1ea8:	7f ef       	ldi	r23, 0xFF	; 255
    1eaa:	80 91 2d 08 	lds	r24, 0x082D
    1eae:	90 91 2e 08 	lds	r25, 0x082E
    1eb2:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
			vEXTERNAL_EEPROM_edit_user(&current_admin,0);
    1eb6:	60 e0       	ldi	r22, 0x00	; 0
    1eb8:	c7 01       	movw	r24, r14
    1eba:	0e 94 b6 1f 	call	0x3f6c	; 0x3f6c <vEXTERNAL_EEPROM_edit_user>
			xSemaphoreGive(i2c_mutex);
    1ebe:	20 e0       	ldi	r18, 0x00	; 0
    1ec0:	40 e0       	ldi	r20, 0x00	; 0
    1ec2:	50 e0       	ldi	r21, 0x00	; 0
    1ec4:	60 e0       	ldi	r22, 0x00	; 0
    1ec6:	70 e0       	ldi	r23, 0x00	; 0
    1ec8:	80 91 2d 08 	lds	r24, 0x082D
    1ecc:	90 91 2e 08 	lds	r25, 0x082E
    1ed0:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
			//set time
			xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1ed4:	6f ef       	ldi	r22, 0xFF	; 255
    1ed6:	7f ef       	ldi	r23, 0xFF	; 255
    1ed8:	80 91 2f 08 	lds	r24, 0x082F
    1edc:	90 91 30 08 	lds	r25, 0x0830
    1ee0:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
			vUartTransmit(ENTER_KEY);
    1ee4:	8d e0       	ldi	r24, 0x0D	; 13
    1ee6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("PLEASE SET THE TIME ....... "));
    1eea:	8f ee       	ldi	r24, 0xEF	; 239
    1eec:	92 e0       	ldi	r25, 0x02	; 2
    1eee:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);
    1ef2:	8d e0       	ldi	r24, 0x0D	; 13
    1ef4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmit(ENTER_KEY);
    1ef8:	8d e0       	ldi	r24, 0x0D	; 13
    1efa:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			xSemaphoreGive(uart_mutex);
    1efe:	20 e0       	ldi	r18, 0x00	; 0
    1f00:	40 e0       	ldi	r20, 0x00	; 0
    1f02:	50 e0       	ldi	r21, 0x00	; 0
    1f04:	60 e0       	ldi	r22, 0x00	; 0
    1f06:	70 e0       	ldi	r23, 0x00	; 0
    1f08:	80 91 2f 08 	lds	r24, 0x082F
    1f0c:	90 91 30 08 	lds	r25, 0x0830
    1f10:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
			set_time();
    1f14:	0e 94 c0 0a 	call	0x1580	; 0x1580 <set_time>
			task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    1f18:	70 92 60 00 	sts	0x0060, r7
    1f1c:	4a cf       	rjmp	.-364    	; 0x1db2 <vTerminal_task+0x68>
		}
		else
		{
			//if not root password
			xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1f1e:	6f ef       	ldi	r22, 0xFF	; 255
    1f20:	7f ef       	ldi	r23, 0xFF	; 255
    1f22:	80 91 2f 08 	lds	r24, 0x082F
    1f26:	90 91 30 08 	lds	r25, 0x0830
    1f2a:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
			vUartTransmit(ENTER_KEY);
    1f2e:	8d e0       	ldi	r24, 0x0D	; 13
    1f30:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("INVALID PASSWORD ......"));
    1f34:	8c e0       	ldi	r24, 0x0C	; 12
    1f36:	93 e0       	ldi	r25, 0x03	; 3
    1f38:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);vUartTransmit(ENTER_KEY);
    1f3c:	8d e0       	ldi	r24, 0x0D	; 13
    1f3e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    1f42:	8d e0       	ldi	r24, 0x0D	; 13
    1f44:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			xSemaphoreGive(uart_mutex);
    1f48:	20 e0       	ldi	r18, 0x00	; 0
    1f4a:	40 e0       	ldi	r20, 0x00	; 0
    1f4c:	50 e0       	ldi	r21, 0x00	; 0
    1f4e:	60 e0       	ldi	r22, 0x00	; 0
    1f50:	70 e0       	ldi	r23, 0x00	; 0
    1f52:	80 91 2f 08 	lds	r24, 0x082F
    1f56:	90 91 30 08 	lds	r25, 0x0830
    1f5a:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    1f5e:	29 cf       	rjmp	.-430    	; 0x1db2 <vTerminal_task+0x68>
		}
	}
	else
	{
		//error
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1f60:	6f ef       	ldi	r22, 0xFF	; 255
    1f62:	7f ef       	ldi	r23, 0xFF	; 255
    1f64:	80 91 2f 08 	lds	r24, 0x082F
    1f68:	90 91 30 08 	lds	r25, 0x0830
    1f6c:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmit(ENTER_KEY);
    1f70:	8d e0       	ldi	r24, 0x0D	; 13
    1f72:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmitString_program(PSTR("INVALID PASSWORD ......"));
    1f76:	84 e2       	ldi	r24, 0x24	; 36
    1f78:	93 e0       	ldi	r25, 0x03	; 3
    1f7a:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		vUartTransmit(ENTER_KEY);vUartTransmit(ENTER_KEY);
    1f7e:	8d e0       	ldi	r24, 0x0D	; 13
    1f80:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    1f84:	8d e0       	ldi	r24, 0x0D	; 13
    1f86:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		xSemaphoreGive(uart_mutex);
    1f8a:	20 e0       	ldi	r18, 0x00	; 0
    1f8c:	40 e0       	ldi	r20, 0x00	; 0
    1f8e:	50 e0       	ldi	r21, 0x00	; 0
    1f90:	60 e0       	ldi	r22, 0x00	; 0
    1f92:	70 e0       	ldi	r23, 0x00	; 0
    1f94:	80 91 2f 08 	lds	r24, 0x082F
    1f98:	90 91 30 08 	lds	r25, 0x0830
    1f9c:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    1fa0:	08 cf       	rjmp	.-496    	; 0x1db2 <vTerminal_task+0x68>
static void vTerminal_logged_off_state(void)
{
	u8 returned_key;
	while(1)
	{
		vUartTransmit(ENTER_KEY);
    1fa2:	8d e0       	ldi	r24, 0x0D	; 13
    1fa4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		vUartTransmitString_program(PSTR("###"));
    1fa8:	8c e3       	ldi	r24, 0x3C	; 60
    1faa:	93 e0       	ldi	r25, 0x03	; 3
    1fac:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
u8 u8Get_at_char(void)
{
	u8 data;
	while(1)
	{
		xQueueReceive(g_terminal_task_q,&data,portMAX_DELAY);
    1fb0:	4f ef       	ldi	r20, 0xFF	; 255
    1fb2:	5f ef       	ldi	r21, 0xFF	; 255
    1fb4:	be 01       	movw	r22, r28
    1fb6:	6f 5f       	subi	r22, 0xFF	; 255
    1fb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1fba:	80 91 db 01 	lds	r24, 0x01DB
    1fbe:	90 91 dc 01 	lds	r25, 0x01DC
    1fc2:	0e 94 21 2c 	call	0x5842	; 0x5842 <xQueueReceive>
		if(data ==AT_KEY)
    1fc6:	89 81       	ldd	r24, Y+1	; 0x01
    1fc8:	80 34       	cpi	r24, 0x40	; 64
    1fca:	59 f7       	brne	.-42     	; 0x1fa2 <vTerminal_task+0x258>
    1fcc:	9a c1       	rjmp	.+820    	; 0x2302 <vTerminal_task+0x5b8>
//----------------------------------------------------------
static void vTerminal_check_admin_pass_state(void)
{
	u8 returned_key;
	
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    1fce:	6f ef       	ldi	r22, 0xFF	; 255
    1fd0:	7f ef       	ldi	r23, 0xFF	; 255
    1fd2:	80 91 2f 08 	lds	r24, 0x082F
    1fd6:	90 91 30 08 	lds	r25, 0x0830
    1fda:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmit(ENTER_KEY);
    1fde:	8d e0       	ldi	r24, 0x0D	; 13
    1fe0:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER ADMIN PASSWORD : "));
    1fe4:	80 e4       	ldi	r24, 0x40	; 64
    1fe6:	93 e0       	ldi	r25, 0x03	; 3
    1fe8:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	xSemaphoreGive(uart_mutex);
    1fec:	20 e0       	ldi	r18, 0x00	; 0
    1fee:	40 e0       	ldi	r20, 0x00	; 0
    1ff0:	50 e0       	ldi	r21, 0x00	; 0
    1ff2:	60 e0       	ldi	r22, 0x00	; 0
    1ff4:	70 e0       	ldi	r23, 0x00	; 0
    1ff6:	80 91 2f 08 	lds	r24, 0x082F
    1ffa:	90 91 30 08 	lds	r25, 0x0830
    1ffe:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	//check
	returned_key=u8Get_user_password();
    2002:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <u8Get_user_password>
	if(returned_key==PASSWORD_FOUND)
    2006:	81 11       	cpse	r24, r1
    2008:	29 c0       	rjmp	.+82     	; 0x205c <vTerminal_task+0x312>
	{
		if (current_admin.type>ADMIN_USER)
    200a:	f8 01       	movw	r30, r16
    200c:	80 81       	ld	r24, Z
    200e:	82 30       	cpi	r24, 0x02	; 2
    2010:	18 f0       	brcs	.+6      	; 0x2018 <vTerminal_task+0x2ce>
		{
			//error
			invalid_password_print();
    2012:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <invalid_password_print>
    2016:	cd ce       	rjmp	.-614    	; 0x1db2 <vTerminal_task+0x68>
		}
		else
		{
			xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2018:	6f ef       	ldi	r22, 0xFF	; 255
    201a:	7f ef       	ldi	r23, 0xFF	; 255
    201c:	80 91 2f 08 	lds	r24, 0x082F
    2020:	90 91 30 08 	lds	r25, 0x0830
    2024:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
			vUartTransmit(ENTER_KEY);
    2028:	8d e0       	ldi	r24, 0x0D	; 13
    202a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("LOGGING IN ....... "));
    202e:	88 e5       	ldi	r24, 0x58	; 88
    2030:	93 e0       	ldi	r25, 0x03	; 3
    2032:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);
    2036:	8d e0       	ldi	r24, 0x0D	; 13
    2038:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			xSemaphoreGive(uart_mutex);
    203c:	20 e0       	ldi	r18, 0x00	; 0
    203e:	40 e0       	ldi	r20, 0x00	; 0
    2040:	50 e0       	ldi	r21, 0x00	; 0
    2042:	60 e0       	ldi	r22, 0x00	; 0
    2044:	70 e0       	ldi	r23, 0x00	; 0
    2046:	80 91 2f 08 	lds	r24, 0x082F
    204a:	90 91 30 08 	lds	r25, 0x0830
    204e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
			admin_invalid_count=0;
    2052:	10 92 cf 01 	sts	0x01CF, r1
			task_state=TERMINAL_TASK_MENU_STATE;
    2056:	50 92 60 00 	sts	0x0060, r5
    205a:	ab ce       	rjmp	.-682    	; 0x1db2 <vTerminal_task+0x68>
		}
	}
	else if(returned_key ==TERMINAL_TIME_OUT)
    205c:	85 35       	cpi	r24, 0x55	; 85
    205e:	19 f4       	brne	.+6      	; 0x2066 <vTerminal_task+0x31c>
	{
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    2060:	70 92 60 00 	sts	0x0060, r7
    2064:	a6 ce       	rjmp	.-692    	; 0x1db2 <vTerminal_task+0x68>
	}
	else
	{
		//error
		invalid_password_print();
    2066:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <invalid_password_print>
    206a:	a3 ce       	rjmp	.-698    	; 0x1db2 <vTerminal_task+0x68>
		
}
//-----------------------------------------------------------------------------------
static void vMenu_options_print(void)
{
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    206c:	6f ef       	ldi	r22, 0xFF	; 255
    206e:	7f ef       	ldi	r23, 0xFF	; 255
    2070:	80 91 2f 08 	lds	r24, 0x082F
    2074:	90 91 30 08 	lds	r25, 0x0830
    2078:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmit(ENTER_KEY);
    207c:	8d e0       	ldi	r24, 0x0D	; 13
    207e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 1 TO UNLOCK THE SYSTEM"));
    2082:	89 e7       	ldi	r24, 0x79	; 121
    2084:	93 e0       	ldi	r25, 0x03	; 3
    2086:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    208a:	8d e0       	ldi	r24, 0x0D	; 13
    208c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 2 TO OPEN GARAGE"));
    2090:	86 e9       	ldi	r24, 0x96	; 150
    2092:	93 e0       	ldi	r25, 0x03	; 3
    2094:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);	
    2098:	8d e0       	ldi	r24, 0x0D	; 13
    209a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 3 TO CLOSE GARAGE"));
    209e:	8d ea       	ldi	r24, 0xAD	; 173
    20a0:	93 e0       	ldi	r25, 0x03	; 3
    20a2:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    20a6:	8d e0       	ldi	r24, 0x0D	; 13
    20a8:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 4 TO SET THE TIME"));
    20ac:	85 ec       	ldi	r24, 0xC5	; 197
    20ae:	93 e0       	ldi	r25, 0x03	; 3
    20b0:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    20b4:	8d e0       	ldi	r24, 0x0D	; 13
    20b6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 5 TO ADD/REMOVE USERS"));
    20ba:	8d ed       	ldi	r24, 0xDD	; 221
    20bc:	93 e0       	ldi	r25, 0x03	; 3
    20be:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    20c2:	8d e0       	ldi	r24, 0x0D	; 13
    20c4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER 6 TO LOGOUT"));
    20c8:	89 ef       	ldi	r24, 0xF9	; 249
    20ca:	93 e0       	ldi	r25, 0x03	; 3
    20cc:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    20d0:	8d e0       	ldi	r24, 0x0D	; 13
    20d2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(ENTER_KEY);
    20d6:	8d e0       	ldi	r24, 0x0D	; 13
    20d8:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
		
	xSemaphoreGive(uart_mutex);				
    20dc:	20 e0       	ldi	r18, 0x00	; 0
    20de:	40 e0       	ldi	r20, 0x00	; 0
    20e0:	50 e0       	ldi	r21, 0x00	; 0
    20e2:	60 e0       	ldi	r22, 0x00	; 0
    20e4:	70 e0       	ldi	r23, 0x00	; 0
    20e6:	80 91 2f 08 	lds	r24, 0x082F
    20ea:	90 91 30 08 	lds	r25, 0x0830
    20ee:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
}
//--------------------------------------------------
void main_menu_choose(void)
{
	u8 returned_key;
	vUartTransmitString_program(PSTR(">>>"));
    20f2:	8b e0       	ldi	r24, 0x0B	; 11
    20f4:	94 e0       	ldi	r25, 0x04	; 4
    20f6:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	returned_key=u8Get_input_buffer();
    20fa:	0e 94 b6 0c 	call	0x196c	; 0x196c <u8Get_input_buffer>
	if(returned_key ==ENTER_KEY)
    20fe:	8d 30       	cpi	r24, 0x0D	; 13
    2100:	d1 f4       	brne	.+52     	; 0x2136 <vTerminal_task+0x3ec>
	{
		//check input
		returned_key=get_user_input();
    2102:	0e 94 a9 0c 	call	0x1952	; 0x1952 <get_user_input>
		if (returned_key !=INVALID_INPUT)
    2106:	8f 3f       	cpi	r24, 0xFF	; 255
    2108:	09 f4       	brne	.+2      	; 0x210c <vTerminal_task+0x3c2>
    210a:	53 ce       	rjmp	.-858    	; 0x1db2 <vTerminal_task+0x68>
		{
			if(returned_key ==USERS_MENU)
    210c:	84 30       	cpi	r24, 0x04	; 4
    210e:	19 f4       	brne	.+6      	; 0x2116 <vTerminal_task+0x3cc>
			{
				task_state=TERMINAL_TASK_USERS_MENU_STATE;
    2110:	20 92 60 00 	sts	0x0060, r2
    2114:	4e ce       	rjmp	.-868    	; 0x1db2 <vTerminal_task+0x68>
			}
			else if(returned_key==LOG_OUT)
    2116:	85 30       	cpi	r24, 0x05	; 5
    2118:	19 f4       	brne	.+6      	; 0x2120 <vTerminal_task+0x3d6>
			{
				task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    211a:	70 92 60 00 	sts	0x0060, r7
    211e:	49 ce       	rjmp	.-878    	; 0x1db2 <vTerminal_task+0x68>
			}
			else
			{
				menu_func_ptr[returned_key]();
    2120:	e8 2f       	mov	r30, r24
    2122:	f0 e0       	ldi	r31, 0x00	; 0
    2124:	ee 0f       	add	r30, r30
    2126:	ff 1f       	adc	r31, r31
    2128:	e3 59       	subi	r30, 0x93	; 147
    212a:	ff 4f       	sbci	r31, 0xFF	; 255
    212c:	01 90       	ld	r0, Z+
    212e:	f0 81       	ld	r31, Z
    2130:	e0 2d       	mov	r30, r0
    2132:	09 95       	icall
    2134:	3e ce       	rjmp	.-900    	; 0x1db2 <vTerminal_task+0x68>
			}
			//call functions pointer of index
		}
	
	}
	else if(returned_key==TERMINAL_TIME_OUT)
    2136:	85 35       	cpi	r24, 0x55	; 85
    2138:	09 f0       	breq	.+2      	; 0x213c <vTerminal_task+0x3f2>
    213a:	3b ce       	rjmp	.-906    	; 0x1db2 <vTerminal_task+0x68>
	{
		task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    213c:	70 92 60 00 	sts	0x0060, r7
    2140:	38 ce       	rjmp	.-912    	; 0x1db2 <vTerminal_task+0x68>
//-----------------------------------------------------------------
//check if root user
void vTerminal_users_menu_state(void)
{
	u8 error;
	if (current_admin.type>ROOT_USER)
    2142:	f8 01       	movw	r30, r16
    2144:	80 81       	ld	r24, Z
    2146:	88 23       	and	r24, r24
    2148:	09 f4       	brne	.+2      	; 0x214c <vTerminal_task+0x402>
    214a:	64 c0       	rjmp	.+200    	; 0x2214 <vTerminal_task+0x4ca>
	{
		//print enter root user passsword
		xSemaphoreTake(uart_mutex,portMAX_DELAY);
    214c:	6f ef       	ldi	r22, 0xFF	; 255
    214e:	7f ef       	ldi	r23, 0xFF	; 255
    2150:	80 91 2f 08 	lds	r24, 0x082F
    2154:	90 91 30 08 	lds	r25, 0x0830
    2158:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
		vUartTransmitString_program(PSTR("ENTER ROOT USER PASSWORD : "));
    215c:	8f e0       	ldi	r24, 0x0F	; 15
    215e:	94 e0       	ldi	r25, 0x04	; 4
    2160:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
		xSemaphoreGive(uart_mutex);
    2164:	20 e0       	ldi	r18, 0x00	; 0
    2166:	40 e0       	ldi	r20, 0x00	; 0
    2168:	50 e0       	ldi	r21, 0x00	; 0
    216a:	60 e0       	ldi	r22, 0x00	; 0
    216c:	70 e0       	ldi	r23, 0x00	; 0
    216e:	80 91 2f 08 	lds	r24, 0x082F
    2172:	90 91 30 08 	lds	r25, 0x0830
    2176:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
		error=u8Get_user_password();
    217a:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <u8Get_user_password>
		if(error ==PASSWORD_FOUND)
    217e:	81 11       	cpse	r24, r1
    2180:	29 c0       	rjmp	.+82     	; 0x21d4 <vTerminal_task+0x48a>
		{
			if(current_admin.type ==ROOT_USER)
    2182:	f8 01       	movw	r30, r16
    2184:	80 81       	ld	r24, Z
    2186:	81 11       	cpse	r24, r1
    2188:	05 c0       	rjmp	.+10     	; 0x2194 <vTerminal_task+0x44a>
			{
				vMenu_users_options_print();
    218a:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vMenu_users_options_print>
				menu_users_choose();
    218e:	0e 94 77 0d 	call	0x1aee	; 0x1aee <menu_users_choose>
    2192:	0f ce       	rjmp	.-994    	; 0x1db2 <vTerminal_task+0x68>
			}
			else
			{
				xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2194:	6f ef       	ldi	r22, 0xFF	; 255
    2196:	7f ef       	ldi	r23, 0xFF	; 255
    2198:	80 91 2f 08 	lds	r24, 0x082F
    219c:	90 91 30 08 	lds	r25, 0x0830
    21a0:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
				vUartTransmit(ENTER_KEY);
    21a4:	8d e0       	ldi	r24, 0x0D	; 13
    21a6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
				vUartTransmitString_program(PSTR("NOT ROOT PASSWORD .... "));
    21aa:	8b e2       	ldi	r24, 0x2B	; 43
    21ac:	94 e0       	ldi	r25, 0x04	; 4
    21ae:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
				vUartTransmit(ENTER_KEY);
    21b2:	8d e0       	ldi	r24, 0x0D	; 13
    21b4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
				xSemaphoreGive(uart_mutex);
    21b8:	20 e0       	ldi	r18, 0x00	; 0
    21ba:	40 e0       	ldi	r20, 0x00	; 0
    21bc:	50 e0       	ldi	r21, 0x00	; 0
    21be:	60 e0       	ldi	r22, 0x00	; 0
    21c0:	70 e0       	ldi	r23, 0x00	; 0
    21c2:	80 91 2f 08 	lds	r24, 0x082F
    21c6:	90 91 30 08 	lds	r25, 0x0830
    21ca:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
				task_state=TERMINAL_TASK_MENU_STATE;
    21ce:	50 92 60 00 	sts	0x0060, r5
    21d2:	ef cd       	rjmp	.-1058   	; 0x1db2 <vTerminal_task+0x68>
			}
		}
		else
		{
			//print enter root password
			xSemaphoreTake(uart_mutex,portMAX_DELAY);
    21d4:	6f ef       	ldi	r22, 0xFF	; 255
    21d6:	7f ef       	ldi	r23, 0xFF	; 255
    21d8:	80 91 2f 08 	lds	r24, 0x082F
    21dc:	90 91 30 08 	lds	r25, 0x0830
    21e0:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
			vUartTransmit(ENTER_KEY);
    21e4:	8d e0       	ldi	r24, 0x0D	; 13
    21e6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("WRONG ROOT PASSWORD .... "));
    21ea:	83 e4       	ldi	r24, 0x43	; 67
    21ec:	94 e0       	ldi	r25, 0x04	; 4
    21ee:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);
    21f2:	8d e0       	ldi	r24, 0x0D	; 13
    21f4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			xSemaphoreGive(uart_mutex);
    21f8:	20 e0       	ldi	r18, 0x00	; 0
    21fa:	40 e0       	ldi	r20, 0x00	; 0
    21fc:	50 e0       	ldi	r21, 0x00	; 0
    21fe:	60 e0       	ldi	r22, 0x00	; 0
    2200:	70 e0       	ldi	r23, 0x00	; 0
    2202:	80 91 2f 08 	lds	r24, 0x082F
    2206:	90 91 30 08 	lds	r25, 0x0830
    220a:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
			task_state=TERMINAL_TASK_MENU_STATE;
    220e:	50 92 60 00 	sts	0x0060, r5
    2212:	cf cd       	rjmp	.-1122   	; 0x1db2 <vTerminal_task+0x68>
		}
	}
	else
	{
		//if root
		vMenu_users_options_print();
    2214:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vMenu_users_options_print>
		menu_users_choose();
    2218:	0e 94 77 0d 	call	0x1aee	; 0x1aee <menu_users_choose>
    221c:	ca cd       	rjmp	.-1132   	; 0x1db2 <vTerminal_task+0x68>
//-------------------------------------------------------------
static void vTerminal_locked_state(void)
{
	u8 returned_key;
	static u8 invalid_locked_count=0;
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    221e:	6f ef       	ldi	r22, 0xFF	; 255
    2220:	7f ef       	ldi	r23, 0xFF	; 255
    2222:	80 91 2f 08 	lds	r24, 0x082F
    2226:	90 91 30 08 	lds	r25, 0x0830
    222a:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmit(ENTER_KEY);
    222e:	8d e0       	ldi	r24, 0x0D	; 13
    2230:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(ENTER_KEY);
    2234:	8d e0       	ldi	r24, 0x0D	; 13
    2236:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("TERMINAL LOCKED .... "));
    223a:	88 ef       	ldi	r24, 0xF8	; 248
    223c:	94 e0       	ldi	r25, 0x04	; 4
    223e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    2242:	8d e0       	ldi	r24, 0x0D	; 13
    2244:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("ENTER ROOT PASSWORD TO UNLOCK : "));
    2248:	8e e0       	ldi	r24, 0x0E	; 14
    224a:	95 e0       	ldi	r25, 0x05	; 5
    224c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	
	xSemaphoreGive(uart_mutex);
    2250:	20 e0       	ldi	r18, 0x00	; 0
    2252:	40 e0       	ldi	r20, 0x00	; 0
    2254:	50 e0       	ldi	r21, 0x00	; 0
    2256:	60 e0       	ldi	r22, 0x00	; 0
    2258:	70 e0       	ldi	r23, 0x00	; 0
    225a:	80 91 2f 08 	lds	r24, 0x082F
    225e:	90 91 30 08 	lds	r25, 0x0830
    2262:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	
	returned_key=u8Get_user_password();
    2266:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <u8Get_user_password>
	if(returned_key ==PASSWORD_FOUND)
    226a:	81 11       	cpse	r24, r1
    226c:	09 c0       	rjmp	.+18     	; 0x2280 <vTerminal_task+0x536>
	{
		//check password
		if(current_admin.type ==ROOT_USER)
    226e:	f8 01       	movw	r30, r16
    2270:	80 81       	ld	r24, Z
    2272:	81 11       	cpse	r24, r1
    2274:	9e cd       	rjmp	.-1220   	; 0x1db2 <vTerminal_task+0x68>
		{
			invalid_locked_count=0;
    2276:	10 92 dd 01 	sts	0x01DD, r1
			task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    227a:	70 92 60 00 	sts	0x0060, r7
    227e:	99 cd       	rjmp	.-1230   	; 0x1db2 <vTerminal_task+0x68>
		}
	}
	else
	{
		//call mina badrous :D
		invalid_locked_count++;
    2280:	80 91 dd 01 	lds	r24, 0x01DD
    2284:	8f 5f       	subi	r24, 0xFF	; 255
    2286:	80 93 dd 01 	sts	0x01DD, r24
		if(invalid_locked_count ==3)
    228a:	83 30       	cpi	r24, 0x03	; 3
    228c:	09 f0       	breq	.+2      	; 0x2290 <vTerminal_task+0x546>
    228e:	91 cd       	rjmp	.-1246   	; 0x1db2 <vTerminal_task+0x68>
		{
			xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2290:	6f ef       	ldi	r22, 0xFF	; 255
    2292:	7f ef       	ldi	r23, 0xFF	; 255
    2294:	80 91 2f 08 	lds	r24, 0x082F
    2298:	90 91 30 08 	lds	r25, 0x0830
    229c:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
			
			vUartTransmit(ENTER_KEY);
    22a0:	8d e0       	ldi	r24, 0x0D	; 13
    22a2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmit(ENTER_KEY);
    22a6:	8d e0       	ldi	r24, 0x0D	; 13
    22a8:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("SYSTEM LOCKED PLEASE CONTACT THE DEVELOPER "));
    22ac:	8f e2       	ldi	r24, 0x2F	; 47
    22ae:	95 e0       	ldi	r25, 0x05	; 5
    22b0:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);
    22b4:	8d e0       	ldi	r24, 0x0D	; 13
    22b6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			
			xSemaphoreGive(uart_mutex);
    22ba:	20 e0       	ldi	r18, 0x00	; 0
    22bc:	40 e0       	ldi	r20, 0x00	; 0
    22be:	50 e0       	ldi	r21, 0x00	; 0
    22c0:	60 e0       	ldi	r22, 0x00	; 0
    22c2:	70 e0       	ldi	r23, 0x00	; 0
    22c4:	80 91 2f 08 	lds	r24, 0x082F
    22c8:	90 91 30 08 	lds	r25, 0x0830
    22cc:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
			//save state in eeprom 
			vEXTERNAL_EEPROM_lock_state();
    22d0:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <vEXTERNAL_EEPROM_lock_state>
			
			//vTaskSuspendAll();
			//vTaskSuspend(keypad_task_handler);
			//vTaskResumeAll();
			
			while(g_unlock_system_flag==0)
    22d4:	80 91 c9 01 	lds	r24, 0x01C9
    22d8:	81 11       	cpse	r24, r1
    22da:	08 c0       	rjmp	.+16     	; 0x22ec <vTerminal_task+0x5a2>
			{
				vTaskDelay(500);
    22dc:	84 ef       	ldi	r24, 0xF4	; 244
    22de:	91 e0       	ldi	r25, 0x01	; 1
    22e0:	0e 94 68 30 	call	0x60d0	; 0x60d0 <vTaskDelay>
			
			//vTaskSuspendAll();
			//vTaskSuspend(keypad_task_handler);
			//vTaskResumeAll();
			
			while(g_unlock_system_flag==0)
    22e4:	80 91 c9 01 	lds	r24, 0x01C9
    22e8:	88 23       	and	r24, r24
    22ea:	c1 f3       	breq	.-16     	; 0x22dc <vTerminal_task+0x592>
			{
				vTaskDelay(500);
			}
			invalid_locked_count=0;
    22ec:	10 92 dd 01 	sts	0x01DD, r1
			admin_invalid_count=0;
    22f0:	10 92 cf 01 	sts	0x01CF, r1
			g_unlock_system_flag=0;
    22f4:	10 92 c9 01 	sts	0x01C9, r1
			vEXTERNAL_EEPROM_unlock_state();
    22f8:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <vEXTERNAL_EEPROM_unlock_state>
			//xTaskResumeAll();
			//vTaskResume(keypad_task_handler);
			task_state=TERMINAL_TASK_LOGGED_OFF_STATE;
    22fc:	70 92 60 00 	sts	0x0060, r7
    2300:	58 cd       	rjmp	.-1360   	; 0x1db2 <vTerminal_task+0x68>
		vUartTransmitString_program(PSTR("###"));
		returned_key=u8Get_at_char();
		if(returned_key == AT_KEY)
		{
			//change to check password state
			task_state=TERMINAL_TASK_CHECK_ADMIN_PASS_STATE;
    2302:	82 e0       	ldi	r24, 0x02	; 2
    2304:	80 93 60 00 	sts	0x0060, r24
    2308:	54 cd       	rjmp	.-1368   	; 0x1db2 <vTerminal_task+0x68>

0000230a <vSet_terminal_task_state>:
{
	return task_state;
}
void vSet_terminal_task_state(u8 state)
{
	task_state=state;
    230a:	80 93 60 00 	sts	0x0060, r24
    230e:	08 95       	ret

00002310 <list_users>:
#include "terminal_user_menu.h"



void list_users(void)
{
    2310:	af 92       	push	r10
    2312:	bf 92       	push	r11
    2314:	cf 92       	push	r12
    2316:	df 92       	push	r13
    2318:	ef 92       	push	r14
    231a:	ff 92       	push	r15
    231c:	0f 93       	push	r16
    231e:	1f 93       	push	r17
    2320:	cf 93       	push	r28
    2322:	df 93       	push	r29
    2324:	cd b7       	in	r28, 0x3d	; 61
    2326:	de b7       	in	r29, 0x3e	; 62
    2328:	68 97       	sbiw	r28, 0x18	; 24
    232a:	0f b6       	in	r0, 0x3f	; 63
    232c:	f8 94       	cli
    232e:	de bf       	out	0x3e, r29	; 62
    2330:	0f be       	out	0x3f, r0	; 63
    2332:	cd bf       	out	0x3d, r28	; 61
	user_t user;
	u8 id,index;
	eeprom_memory_control_block_t memory;
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2334:	6f ef       	ldi	r22, 0xFF	; 255
    2336:	7f ef       	ldi	r23, 0xFF	; 255
    2338:	80 91 2f 08 	lds	r24, 0x082F
    233c:	90 91 30 08 	lds	r25, 0x0830
    2340:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	
	vGet_current_MCB(&memory);
    2344:	ce 01       	movw	r24, r28
    2346:	41 96       	adiw	r24, 0x11	; 17
    2348:	0e 94 31 1c 	call	0x3862	; 0x3862 <vGet_current_MCB>
	
	vUartTransmit(ENTER_KEY);
    234c:	8d e0       	ldi	r24, 0x0D	; 13
    234e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("--------------------------------------------------"));
    2352:	8b e5       	ldi	r24, 0x5B	; 91
    2354:	95 e0       	ldi	r25, 0x05	; 5
    2356:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    235a:	8d e0       	ldi	r24, 0x0D	; 13
    235c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("CURRENT USERS OF THE SYSTEM"));
    2360:	8e e8       	ldi	r24, 0x8E	; 142
    2362:	95 e0       	ldi	r25, 0x05	; 5
    2364:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    2368:	8d e0       	ldi	r24, 0x0D	; 13
    236a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("--------------------------"));
    236e:	8a ea       	ldi	r24, 0xAA	; 170
    2370:	95 e0       	ldi	r25, 0x05	; 5
    2372:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    2376:	8d e0       	ldi	r24, 0x0D	; 13
    2378:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    237c:	00 e0       	ldi	r16, 0x00	; 0
    237e:	10 e0       	ldi	r17, 0x00	; 0
	
	for(id=0;id<EEPROM_MAX_USER;id++)
	{
		if(check_bit(memory.current_user_used_flag,id) ==1)
    2380:	ee 24       	eor	r14, r14
    2382:	e3 94       	inc	r14
    2384:	f1 2c       	mov	r15, r1
 */ 
#include "terminal_user_menu.h"



void list_users(void)
    2386:	6e 01       	movw	r12, r28
    2388:	8a e0       	ldi	r24, 0x0A	; 10
    238a:	c8 0e       	add	r12, r24
    238c:	d1 1c       	adc	r13, r1
	vUartTransmitString_program(PSTR("--------------------------"));
	vUartTransmit(ENTER_KEY);
	
	for(id=0;id<EEPROM_MAX_USER;id++)
	{
		if(check_bit(memory.current_user_used_flag,id) ==1)
    238e:	a7 01       	movw	r20, r14
    2390:	00 2e       	mov	r0, r16
    2392:	02 c0       	rjmp	.+4      	; 0x2398 <list_users+0x88>
    2394:	44 0f       	add	r20, r20
    2396:	55 1f       	adc	r21, r21
    2398:	0a 94       	dec	r0
    239a:	e2 f7       	brpl	.-8      	; 0x2394 <list_users+0x84>
    239c:	66 27       	eor	r22, r22
    239e:	57 fd       	sbrc	r21, 7
    23a0:	60 95       	com	r22
    23a2:	76 2f       	mov	r23, r22
    23a4:	89 89       	ldd	r24, Y+17	; 0x11
    23a6:	9a 89       	ldd	r25, Y+18	; 0x12
    23a8:	ab 89       	ldd	r26, Y+19	; 0x13
    23aa:	bc 89       	ldd	r27, Y+20	; 0x14
    23ac:	48 23       	and	r20, r24
    23ae:	59 23       	and	r21, r25
    23b0:	6a 23       	and	r22, r26
    23b2:	7b 23       	and	r23, r27
    23b4:	00 2e       	mov	r0, r16
    23b6:	04 c0       	rjmp	.+8      	; 0x23c0 <list_users+0xb0>
    23b8:	76 95       	lsr	r23
    23ba:	67 95       	ror	r22
    23bc:	57 95       	ror	r21
    23be:	47 95       	ror	r20
    23c0:	0a 94       	dec	r0
    23c2:	d2 f7       	brpl	.-12     	; 0x23b8 <list_users+0xa8>
    23c4:	41 30       	cpi	r20, 0x01	; 1
    23c6:	51 05       	cpc	r21, r1
    23c8:	61 05       	cpc	r22, r1
    23ca:	71 05       	cpc	r23, r1
    23cc:	09 f0       	breq	.+2      	; 0x23d0 <list_users+0xc0>
    23ce:	4f c0       	rjmp	.+158    	; 0x246e <list_users+0x15e>
		{
			xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    23d0:	6f ef       	ldi	r22, 0xFF	; 255
    23d2:	7f ef       	ldi	r23, 0xFF	; 255
    23d4:	80 91 2d 08 	lds	r24, 0x082D
    23d8:	90 91 2e 08 	lds	r25, 0x082E
    23dc:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
			vEXTERNAL_EEPROM_get_user(&user,id);
    23e0:	60 2f       	mov	r22, r16
    23e2:	ce 01       	movw	r24, r28
    23e4:	01 96       	adiw	r24, 0x01	; 1
    23e6:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <vEXTERNAL_EEPROM_get_user>
			xSemaphoreGive(i2c_mutex);
    23ea:	20 e0       	ldi	r18, 0x00	; 0
    23ec:	40 e0       	ldi	r20, 0x00	; 0
    23ee:	50 e0       	ldi	r21, 0x00	; 0
    23f0:	60 e0       	ldi	r22, 0x00	; 0
    23f2:	70 e0       	ldi	r23, 0x00	; 0
    23f4:	80 91 2d 08 	lds	r24, 0x082D
    23f8:	90 91 2e 08 	lds	r25, 0x082E
    23fc:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
			
			vUartTransmit(id + '0' + 1 );
    2400:	80 2f       	mov	r24, r16
    2402:	8f 5c       	subi	r24, 0xCF	; 207
    2404:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			
			vUartTransmitString_program(PSTR(" - "));
    2408:	85 ec       	ldi	r24, 0xC5	; 197
    240a:	95 e0       	ldi	r25, 0x05	; 5
    240c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			//print name
			for(index=0;index<MAX_USER_NAME;index++)
			{
				if((user.name[index]) !='\0')
    2410:	89 81       	ldd	r24, Y+1	; 0x01
    2412:	81 11       	cpse	r24, r1
    2414:	3e c0       	rjmp	.+124    	; 0x2492 <list_users+0x182>
    2416:	0a c0       	rjmp	.+20     	; 0x242c <list_users+0x11c>
    2418:	f5 01       	movw	r30, r10
    241a:	81 91       	ld	r24, Z+
    241c:	5f 01       	movw	r10, r30
    241e:	88 23       	and	r24, r24
    2420:	29 f0       	breq	.+10     	; 0x242c <list_users+0x11c>
				{
					vUartTransmit((user.name[index]));
    2422:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			
			vUartTransmit(id + '0' + 1 );
			
			vUartTransmitString_program(PSTR(" - "));
			//print name
			for(index=0;index<MAX_USER_NAME;index++)
    2426:	ac 14       	cp	r10, r12
    2428:	bd 04       	cpc	r11, r13
    242a:	b1 f7       	brne	.-20     	; 0x2418 <list_users+0x108>
				{
					break;
				}
			}
			//print type
			vUartTransmitString_program(PSTR("   -> "));
    242c:	89 ec       	ldi	r24, 0xC9	; 201
    242e:	95 e0       	ldi	r25, 0x05	; 5
    2430:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			if(user.type ==ROOT_USER)
    2434:	8f 85       	ldd	r24, Y+15	; 0x0f
    2436:	81 11       	cpse	r24, r1
    2438:	05 c0       	rjmp	.+10     	; 0x2444 <list_users+0x134>
			{
				vUartTransmitString_program(PSTR("ROOT USER "));
    243a:	80 ed       	ldi	r24, 0xD0	; 208
    243c:	95 e0       	ldi	r25, 0x05	; 5
    243e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
    2442:	0b c0       	rjmp	.+22     	; 0x245a <list_users+0x14a>
			}
			else if(user.type ==ADMIN_USER)
    2444:	81 30       	cpi	r24, 0x01	; 1
    2446:	29 f4       	brne	.+10     	; 0x2452 <list_users+0x142>
			{
				vUartTransmitString_program(PSTR("ADMIN USER "));
    2448:	8b ed       	ldi	r24, 0xDB	; 219
    244a:	95 e0       	ldi	r25, 0x05	; 5
    244c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
    2450:	04 c0       	rjmp	.+8      	; 0x245a <list_users+0x14a>
			}
			else
			{
				vUartTransmitString_program(PSTR("NORMAL USER "));
    2452:	87 ee       	ldi	r24, 0xE7	; 231
    2454:	95 e0       	ldi	r25, 0x05	; 5
    2456:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			}
			vUartTransmit(ENTER_KEY);
    245a:	8d e0       	ldi	r24, 0x0D	; 13
    245c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmitString_program(PSTR("------------------------------------------"));
    2460:	84 ef       	ldi	r24, 0xF4	; 244
    2462:	95 e0       	ldi	r25, 0x05	; 5
    2464:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
			vUartTransmit(ENTER_KEY);	
    2468:	8d e0       	ldi	r24, 0x0D	; 13
    246a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    246e:	0f 5f       	subi	r16, 0xFF	; 255
    2470:	1f 4f       	sbci	r17, 0xFF	; 255
	vUartTransmitString_program(PSTR("CURRENT USERS OF THE SYSTEM"));
	vUartTransmit(ENTER_KEY);
	vUartTransmitString_program(PSTR("--------------------------"));
	vUartTransmit(ENTER_KEY);
	
	for(id=0;id<EEPROM_MAX_USER;id++)
    2472:	09 31       	cpi	r16, 0x19	; 25
    2474:	11 05       	cpc	r17, r1
    2476:	09 f0       	breq	.+2      	; 0x247a <list_users+0x16a>
    2478:	8a cf       	rjmp	.-236    	; 0x238e <list_users+0x7e>
			vUartTransmitString_program(PSTR("------------------------------------------"));
			vUartTransmit(ENTER_KEY);	
		}
		
	}
	xSemaphoreGive(uart_mutex);
    247a:	20 e0       	ldi	r18, 0x00	; 0
    247c:	40 e0       	ldi	r20, 0x00	; 0
    247e:	50 e0       	ldi	r21, 0x00	; 0
    2480:	60 e0       	ldi	r22, 0x00	; 0
    2482:	70 e0       	ldi	r23, 0x00	; 0
    2484:	80 91 2f 08 	lds	r24, 0x082F
    2488:	90 91 30 08 	lds	r25, 0x0830
    248c:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2490:	09 c0       	rjmp	.+18     	; 0x24a4 <list_users+0x194>
			//print name
			for(index=0;index<MAX_USER_NAME;index++)
			{
				if((user.name[index]) !='\0')
				{
					vUartTransmit((user.name[index]));
    2492:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
    2496:	68 94       	set
    2498:	aa 24       	eor	r10, r10
    249a:	a1 f8       	bld	r10, 1
    249c:	b1 2c       	mov	r11, r1
    249e:	ac 0e       	add	r10, r28
    24a0:	bd 1e       	adc	r11, r29
    24a2:	ba cf       	rjmp	.-140    	; 0x2418 <list_users+0x108>
			vUartTransmit(ENTER_KEY);	
		}
		
	}
	xSemaphoreGive(uart_mutex);
}
    24a4:	68 96       	adiw	r28, 0x18	; 24
    24a6:	0f b6       	in	r0, 0x3f	; 63
    24a8:	f8 94       	cli
    24aa:	de bf       	out	0x3e, r29	; 62
    24ac:	0f be       	out	0x3f, r0	; 63
    24ae:	cd bf       	out	0x3d, r28	; 61
    24b0:	df 91       	pop	r29
    24b2:	cf 91       	pop	r28
    24b4:	1f 91       	pop	r17
    24b6:	0f 91       	pop	r16
    24b8:	ff 90       	pop	r15
    24ba:	ef 90       	pop	r14
    24bc:	df 90       	pop	r13
    24be:	cf 90       	pop	r12
    24c0:	bf 90       	pop	r11
    24c2:	af 90       	pop	r10
    24c4:	08 95       	ret

000024c6 <add_users>:
//------------------------------------------------------------------

void add_users(void)
{
    24c6:	bf 92       	push	r11
    24c8:	cf 92       	push	r12
    24ca:	df 92       	push	r13
    24cc:	ef 92       	push	r14
    24ce:	ff 92       	push	r15
    24d0:	0f 93       	push	r16
    24d2:	1f 93       	push	r17
    24d4:	cf 93       	push	r28
    24d6:	df 93       	push	r29
    24d8:	cd b7       	in	r28, 0x3d	; 61
    24da:	de b7       	in	r29, 0x3e	; 62
    24dc:	6c 97       	sbiw	r28, 0x1c	; 28
    24de:	0f b6       	in	r0, 0x3f	; 63
    24e0:	f8 94       	cli
    24e2:	de bf       	out	0x3e, r29	; 62
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	cd bf       	out	0x3d, r28	; 61
	u8 id,type;
	u8 name[10];
	func_state=ADD_USER_STATE_ADD_NAME;
	func_error_state=ADD_USER_NO_ERROR;
	
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    24e8:	6f ef       	ldi	r22, 0xFF	; 255
    24ea:	7f ef       	ldi	r23, 0xFF	; 255
    24ec:	80 91 2f 08 	lds	r24, 0x082F
    24f0:	90 91 30 08 	lds	r25, 0x0830
    24f4:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmitString_program(PSTR("--------------------------------"));
    24f8:	8f e1       	ldi	r24, 0x1F	; 31
    24fa:	96 e0       	ldi	r25, 0x06	; 6
    24fc:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    2500:	8d e0       	ldi	r24, 0x0D	; 13
    2502:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	u8 result;
	user_t user;
	u8 id,type;
	u8 name[10];
	func_state=ADD_USER_STATE_ADD_NAME;
	func_error_state=ADD_USER_NO_ERROR;
    2506:	80 e0       	ldi	r24, 0x00	; 0
	} func_error_state;
	u8 result;
	user_t user;
	u8 id,type;
	u8 name[10];
	func_state=ADD_USER_STATE_ADD_NAME;
    2508:	10 e0       	ldi	r17, 0x00	; 0
			case ADD_USER_NAME_USED_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("THIS USER NAME ALREADY USED "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    250a:	02 e0       	ldi	r16, 0x02	; 2
			case ADD_USER_INAVLID_NAME_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("USER NAME MUST BE < 9 DIGIT ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    250c:	ff 24       	eor	r15, r15
    250e:	f3 94       	inc	r15
			case ADD_USER_INAVLID_PASS_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("PASSWORD MUST BE 4 DIGIT ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    2510:	0f 2e       	mov	r0, r31
    2512:	f3 e0       	ldi	r31, 0x03	; 3
    2514:	cf 2e       	mov	r12, r31
    2516:	f0 2d       	mov	r31, r0
										//password used
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("THIS PASSWORD ALREADY USED "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    2518:	68 94       	set
    251a:	dd 24       	eor	r13, r13
    251c:	d2 f8       	bld	r13, 2
			case ADD_USER_INAVLID_TYPE_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("WRONG USER TYPE ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    251e:	0f 2e       	mov	r0, r31
    2520:	f5 e0       	ldi	r31, 0x05	; 5
    2522:	ef 2e       	mov	r14, r31
    2524:	f0 2d       	mov	r31, r0
	
	vUartTransmitString_program(PSTR("--------------------------------"));
	vUartTransmit(ENTER_KEY);
	while(1)
	{
		switch(func_state)
    2526:	11 30       	cpi	r17, 0x01	; 1
    2528:	99 f1       	breq	.+102    	; 0x2590 <add_users+0xca>
    252a:	38 f0       	brcs	.+14     	; 0x253a <add_users+0x74>
    252c:	12 30       	cpi	r17, 0x02	; 2
    252e:	09 f4       	brne	.+2      	; 0x2532 <add_users+0x6c>
    2530:	61 c0       	rjmp	.+194    	; 0x25f4 <add_users+0x12e>
    2532:	13 30       	cpi	r17, 0x03	; 3
    2534:	09 f0       	breq	.+2      	; 0x2538 <add_users+0x72>
    2536:	b6 c0       	rjmp	.+364    	; 0x26a4 <add_users+0x1de>
    2538:	6f c0       	rjmp	.+222    	; 0x2618 <add_users+0x152>
		{
			case ADD_USER_STATE_ADD_NAME :
								vUartTransmitString_program(PSTR("ENTER USER NAME (MAX 9 CHAR) : "));
    253a:	80 e4       	ldi	r24, 0x40	; 64
    253c:	96 e0       	ldi	r25, 0x06	; 6
    253e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
								result=get_user_name(&(user.name[0]));
    2542:	ce 01       	movw	r24, r28
    2544:	01 96       	adiw	r24, 0x01	; 1
    2546:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <get_user_name>
								if(result == VALID_NAME)
    254a:	81 11       	cpse	r24, r1
    254c:	1c c0       	rjmp	.+56     	; 0x2586 <add_users+0xc0>
								{
									//check if name is used
									xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    254e:	6f ef       	ldi	r22, 0xFF	; 255
    2550:	7f ef       	ldi	r23, 0xFF	; 255
    2552:	80 91 2d 08 	lds	r24, 0x082D
    2556:	90 91 2e 08 	lds	r25, 0x082E
    255a:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
									result=u8EXTERNAL_EEPROM_search_by_name(user.name);
    255e:	ce 01       	movw	r24, r28
    2560:	01 96       	adiw	r24, 0x01	; 1
    2562:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <u8EXTERNAL_EEPROM_search_by_name>
    2566:	b8 2e       	mov	r11, r24
									xSemaphoreGive(i2c_mutex);
    2568:	20 e0       	ldi	r18, 0x00	; 0
    256a:	40 e0       	ldi	r20, 0x00	; 0
    256c:	50 e0       	ldi	r21, 0x00	; 0
    256e:	60 e0       	ldi	r22, 0x00	; 0
    2570:	70 e0       	ldi	r23, 0x00	; 0
    2572:	80 91 2d 08 	lds	r24, 0x082D
    2576:	90 91 2e 08 	lds	r25, 0x082E
    257a:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
									if(result ==USER_NAME_NOT_FOUND)
    257e:	8f ef       	ldi	r24, 0xFF	; 255
    2580:	b8 12       	cpse	r11, r24
    2582:	b0 c0       	rjmp	.+352    	; 0x26e4 <add_users+0x21e>
    2584:	04 c0       	rjmp	.+8      	; 0x258e <add_users+0xc8>
										func_error_state=ADD_USER_NAME_USED_ERROR;
										break;
									}
				
								}
								else if(result==TERMINAL_RETURN_U8)
    2586:	8a 3a       	cpi	r24, 0xAA	; 170
    2588:	09 f0       	breq	.+2      	; 0x258c <add_users+0xc6>
    258a:	e8 c0       	rjmp	.+464    	; 0x275c <add_users+0x296>
    258c:	9c c0       	rjmp	.+312    	; 0x26c6 <add_users+0x200>
									result=u8EXTERNAL_EEPROM_search_by_name(user.name);
									xSemaphoreGive(i2c_mutex);
									if(result ==USER_NAME_NOT_FOUND)
									{
										func_error_state=ADD_USER_NO_ERROR;
										func_state=ADD_USER_STATE_ADD_PASS;
    258e:	1f 2d       	mov	r17, r15
									//time out
									func_error_state=ADD_USER_TIMEOUT_ERROR;
									break;
								}
			case ADD_USER_STATE_ADD_PASS :
								vUartTransmit(ENTER_KEY);
    2590:	8d e0       	ldi	r24, 0x0D	; 13
    2592:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								vUartTransmitString_program(PSTR("ENTER USER PASSWORD (4 DIGIT) : "));
    2596:	80 e6       	ldi	r24, 0x60	; 96
    2598:	96 e0       	ldi	r25, 0x06	; 6
    259a:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
								result=u8Get_user_password_arr(&(user.password[0]));
    259e:	ce 01       	movw	r24, r28
    25a0:	0b 96       	adiw	r24, 0x0b	; 11
    25a2:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <u8Get_user_password_arr>
								if(result==PASSWORD_VALID)
    25a6:	81 11       	cpse	r24, r1
    25a8:	ac c0       	rjmp	.+344    	; 0x2702 <add_users+0x23c>
								{
									xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    25aa:	6f ef       	ldi	r22, 0xFF	; 255
    25ac:	7f ef       	ldi	r23, 0xFF	; 255
    25ae:	80 91 2d 08 	lds	r24, 0x082D
    25b2:	90 91 2e 08 	lds	r25, 0x082E
    25b6:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
									result=u8EXTERNAL_EEPROM_search_by_password(user.password,name,&id,&type);
    25ba:	9e 01       	movw	r18, r28
    25bc:	2e 5e       	subi	r18, 0xEE	; 238
    25be:	3f 4f       	sbci	r19, 0xFF	; 255
    25c0:	ae 01       	movw	r20, r28
    25c2:	4f 5e       	subi	r20, 0xEF	; 239
    25c4:	5f 4f       	sbci	r21, 0xFF	; 255
    25c6:	be 01       	movw	r22, r28
    25c8:	6d 5e       	subi	r22, 0xED	; 237
    25ca:	7f 4f       	sbci	r23, 0xFF	; 255
    25cc:	ce 01       	movw	r24, r28
    25ce:	0b 96       	adiw	r24, 0x0b	; 11
    25d0:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <u8EXTERNAL_EEPROM_search_by_password>
    25d4:	b8 2e       	mov	r11, r24
									xSemaphoreGive(i2c_mutex);
    25d6:	20 e0       	ldi	r18, 0x00	; 0
    25d8:	40 e0       	ldi	r20, 0x00	; 0
    25da:	50 e0       	ldi	r21, 0x00	; 0
    25dc:	60 e0       	ldi	r22, 0x00	; 0
    25de:	70 e0       	ldi	r23, 0x00	; 0
    25e0:	80 91 2d 08 	lds	r24, 0x082D
    25e4:	90 91 2e 08 	lds	r25, 0x082E
    25e8:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
									if(result ==PASSWORD_NOT_FOUND)
    25ec:	8f ef       	ldi	r24, 0xFF	; 255
    25ee:	b8 12       	cpse	r11, r24
    25f0:	97 c0       	rjmp	.+302    	; 0x2720 <add_users+0x25a>
									{
										func_state=ADD_USER_STATE_ADD_TYPE;
    25f2:	10 2f       	mov	r17, r16
									//password not valid
									func_error_state=ADD_USER_INAVLID_PASS_ERROR;
									break;
								}
			case ADD_USER_STATE_ADD_TYPE :
								vUartTransmit(ENTER_KEY);
    25f4:	8d e0       	ldi	r24, 0x0D	; 13
    25f6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								vUartTransmitString_program(PSTR("ENTER USER TYPE (ROOT = 0) | (admin = 1) | (user = 2)  : "));
    25fa:	81 e8       	ldi	r24, 0x81	; 129
    25fc:	96 e0       	ldi	r25, 0x06	; 6
    25fe:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
								result=get_u8(&(user.type));
    2602:	ce 01       	movw	r24, r28
    2604:	0f 96       	adiw	r24, 0x0f	; 15
    2606:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
								if(result == TERMINAL_RETURN_U8)
    260a:	8a 3a       	cpi	r24, 0xAA	; 170
    260c:	09 f0       	breq	.+2      	; 0x2610 <add_users+0x14a>
    260e:	a6 c0       	rjmp	.+332    	; 0x275c <add_users+0x296>
								{
									if(user.type <=2)
    2610:	8f 85       	ldd	r24, Y+15	; 0x0f
    2612:	83 30       	cpi	r24, 0x03	; 3
    2614:	08 f0       	brcs	.+2      	; 0x2618 <add_users+0x152>
    2616:	93 c0       	rjmp	.+294    	; 0x273e <add_users+0x278>
									//invalid type
									func_error_state=ADD_USER_TIMEOUT_ERROR;
									break;
								}
			case ADD_USER_ADD_IN_MEMORY	:
								xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2618:	6f ef       	ldi	r22, 0xFF	; 255
    261a:	7f ef       	ldi	r23, 0xFF	; 255
    261c:	80 91 2d 08 	lds	r24, 0x082D
    2620:	90 91 2e 08 	lds	r25, 0x082E
    2624:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
								result=u8EXTERNAL_EEPROM_add_new_user(&user);
    2628:	ce 01       	movw	r24, r28
    262a:	01 96       	adiw	r24, 0x01	; 1
    262c:	0e 94 d8 1e 	call	0x3db0	; 0x3db0 <u8EXTERNAL_EEPROM_add_new_user>
    2630:	18 2f       	mov	r17, r24
								xSemaphoreGive(i2c_mutex);
    2632:	20 e0       	ldi	r18, 0x00	; 0
    2634:	40 e0       	ldi	r20, 0x00	; 0
    2636:	50 e0       	ldi	r21, 0x00	; 0
    2638:	60 e0       	ldi	r22, 0x00	; 0
    263a:	70 e0       	ldi	r23, 0x00	; 0
    263c:	80 91 2d 08 	lds	r24, 0x082D
    2640:	90 91 2e 08 	lds	r25, 0x082E
    2644:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
								if(result !=NO_AVAILABLE_USER)
    2648:	1f 3f       	cpi	r17, 0xFF	; 255
    264a:	b1 f0       	breq	.+44     	; 0x2678 <add_users+0x1b2>
								{
									vUartTransmit(ENTER_KEY);
    264c:	8d e0       	ldi	r24, 0x0D	; 13
    264e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									vUartTransmitString_program(PSTR("USER ADDED SUCESSFULY ........ "));
    2652:	8b eb       	ldi	r24, 0xBB	; 187
    2654:	96 e0       	ldi	r25, 0x06	; 6
    2656:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
									vUartTransmit(ENTER_KEY);
    265a:	8d e0       	ldi	r24, 0x0D	; 13
    265c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									func_error_state=ADD_USER_NO_ERROR;
									
									xSemaphoreGive(uart_mutex);
    2660:	20 e0       	ldi	r18, 0x00	; 0
    2662:	40 e0       	ldi	r20, 0x00	; 0
    2664:	50 e0       	ldi	r21, 0x00	; 0
    2666:	60 e0       	ldi	r22, 0x00	; 0
    2668:	70 e0       	ldi	r23, 0x00	; 0
    266a:	80 91 2f 08 	lds	r24, 0x082F
    266e:	90 91 30 08 	lds	r25, 0x0830
    2672:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2676:	7d c0       	rjmp	.+250    	; 0x2772 <add_users+0x2ac>
									return;
								}
								else
								{
									//print you reach max number of user
									vUartTransmit(ENTER_KEY);
    2678:	8d e0       	ldi	r24, 0x0D	; 13
    267a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									vUartTransmitString_program(PSTR("FAILED TO ADD NEW USER YOU REACH MAX NUMBER OF USER ......... "));
    267e:	8b ed       	ldi	r24, 0xDB	; 219
    2680:	96 e0       	ldi	r25, 0x06	; 6
    2682:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
									vUartTransmit(ENTER_KEY);
    2686:	8d e0       	ldi	r24, 0x0D	; 13
    2688:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									
									xSemaphoreGive(uart_mutex);
    268c:	20 e0       	ldi	r18, 0x00	; 0
    268e:	40 e0       	ldi	r20, 0x00	; 0
    2690:	50 e0       	ldi	r21, 0x00	; 0
    2692:	60 e0       	ldi	r22, 0x00	; 0
    2694:	70 e0       	ldi	r23, 0x00	; 0
    2696:	80 91 2f 08 	lds	r24, 0x082F
    269a:	90 91 30 08 	lds	r25, 0x0830
    269e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    26a2:	67 c0       	rjmp	.+206    	; 0x2772 <add_users+0x2ac>
									return;
								}
			default:break;
		}
		switch(func_error_state)
    26a4:	83 30       	cpi	r24, 0x03	; 3
    26a6:	69 f1       	breq	.+90     	; 0x2702 <add_users+0x23c>
    26a8:	30 f4       	brcc	.+12     	; 0x26b6 <add_users+0x1f0>
    26aa:	81 30       	cpi	r24, 0x01	; 1
    26ac:	61 f0       	breq	.+24     	; 0x26c6 <add_users+0x200>
    26ae:	82 30       	cpi	r24, 0x02	; 2
    26b0:	09 f0       	breq	.+2      	; 0x26b4 <add_users+0x1ee>
    26b2:	39 cf       	rjmp	.-398    	; 0x2526 <add_users+0x60>
    26b4:	17 c0       	rjmp	.+46     	; 0x26e4 <add_users+0x21e>
    26b6:	85 30       	cpi	r24, 0x05	; 5
    26b8:	09 f4       	brne	.+2      	; 0x26bc <add_users+0x1f6>
    26ba:	41 c0       	rjmp	.+130    	; 0x273e <add_users+0x278>
    26bc:	88 f1       	brcs	.+98     	; 0x2720 <add_users+0x25a>
    26be:	86 30       	cpi	r24, 0x06	; 6
    26c0:	09 f0       	breq	.+2      	; 0x26c4 <add_users+0x1fe>
    26c2:	31 cf       	rjmp	.-414    	; 0x2526 <add_users+0x60>
    26c4:	4b c0       	rjmp	.+150    	; 0x275c <add_users+0x296>
		{
			case ADD_USER_NO_ERROR :break;
			case ADD_USER_INAVLID_NAME_ERROR :
										vUartTransmit(ENTER_KEY);
    26c6:	8d e0       	ldi	r24, 0x0D	; 13
    26c8:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("USER NAME MUST BE < 9 DIGIT ......... "));
    26cc:	8a e1       	ldi	r24, 0x1A	; 26
    26ce:	97 e0       	ldi	r25, 0x07	; 7
    26d0:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    26d4:	8d e0       	ldi	r24, 0x0D	; 13
    26d6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    26da:	8d e0       	ldi	r24, 0x0D	; 13
    26dc:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    26e0:	8f 2d       	mov	r24, r15
    26e2:	21 cf       	rjmp	.-446    	; 0x2526 <add_users+0x60>
			case ADD_USER_NAME_USED_ERROR :
										vUartTransmit(ENTER_KEY);
    26e4:	8d e0       	ldi	r24, 0x0D	; 13
    26e6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("THIS USER NAME ALREADY USED "));
    26ea:	81 e4       	ldi	r24, 0x41	; 65
    26ec:	97 e0       	ldi	r25, 0x07	; 7
    26ee:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    26f2:	8d e0       	ldi	r24, 0x0D	; 13
    26f4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    26f8:	8d e0       	ldi	r24, 0x0D	; 13
    26fa:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    26fe:	80 2f       	mov	r24, r16
    2700:	12 cf       	rjmp	.-476    	; 0x2526 <add_users+0x60>
			case ADD_USER_INAVLID_PASS_ERROR :
										vUartTransmit(ENTER_KEY);
    2702:	8d e0       	ldi	r24, 0x0D	; 13
    2704:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("PASSWORD MUST BE 4 DIGIT ......... "));
    2708:	8e e5       	ldi	r24, 0x5E	; 94
    270a:	97 e0       	ldi	r25, 0x07	; 7
    270c:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2710:	8d e0       	ldi	r24, 0x0D	; 13
    2712:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2716:	8d e0       	ldi	r24, 0x0D	; 13
    2718:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    271c:	8c 2d       	mov	r24, r12
    271e:	03 cf       	rjmp	.-506    	; 0x2526 <add_users+0x60>
			case ADD_USER_INAVLID_PASS_USED :
										//password used
										vUartTransmit(ENTER_KEY);
    2720:	8d e0       	ldi	r24, 0x0D	; 13
    2722:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("THIS PASSWORD ALREADY USED "));
    2726:	82 e8       	ldi	r24, 0x82	; 130
    2728:	97 e0       	ldi	r25, 0x07	; 7
    272a:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    272e:	8d e0       	ldi	r24, 0x0D	; 13
    2730:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2734:	8d e0       	ldi	r24, 0x0D	; 13
    2736:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    273a:	8d 2d       	mov	r24, r13
    273c:	f4 ce       	rjmp	.-536    	; 0x2526 <add_users+0x60>
			case ADD_USER_INAVLID_TYPE_ERROR :
										vUartTransmit(ENTER_KEY);
    273e:	8d e0       	ldi	r24, 0x0D	; 13
    2740:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("WRONG USER TYPE ......... "));
    2744:	8e e9       	ldi	r24, 0x9E	; 158
    2746:	97 e0       	ldi	r25, 0x07	; 7
    2748:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    274c:	8d e0       	ldi	r24, 0x0D	; 13
    274e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2752:	8d e0       	ldi	r24, 0x0D	; 13
    2754:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2758:	8e 2d       	mov	r24, r14
    275a:	e5 ce       	rjmp	.-566    	; 0x2526 <add_users+0x60>
			case ADD_USER_TIMEOUT_ERROR :
			
										xSemaphoreGive(uart_mutex);
    275c:	20 e0       	ldi	r18, 0x00	; 0
    275e:	40 e0       	ldi	r20, 0x00	; 0
    2760:	50 e0       	ldi	r21, 0x00	; 0
    2762:	60 e0       	ldi	r22, 0x00	; 0
    2764:	70 e0       	ldi	r23, 0x00	; 0
    2766:	80 91 2f 08 	lds	r24, 0x082F
    276a:	90 91 30 08 	lds	r25, 0x0830
    276e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
										return;
			default:break;
		}
	}
}
    2772:	6c 96       	adiw	r28, 0x1c	; 28
    2774:	0f b6       	in	r0, 0x3f	; 63
    2776:	f8 94       	cli
    2778:	de bf       	out	0x3e, r29	; 62
    277a:	0f be       	out	0x3f, r0	; 63
    277c:	cd bf       	out	0x3d, r28	; 61
    277e:	df 91       	pop	r29
    2780:	cf 91       	pop	r28
    2782:	1f 91       	pop	r17
    2784:	0f 91       	pop	r16
    2786:	ff 90       	pop	r15
    2788:	ef 90       	pop	r14
    278a:	df 90       	pop	r13
    278c:	cf 90       	pop	r12
    278e:	bf 90       	pop	r11
    2790:	08 95       	ret

00002792 <edit_users>:
//---------------------------
void edit_users(void)
{
    2792:	8f 92       	push	r8
    2794:	9f 92       	push	r9
    2796:	af 92       	push	r10
    2798:	bf 92       	push	r11
    279a:	cf 92       	push	r12
    279c:	df 92       	push	r13
    279e:	ef 92       	push	r14
    27a0:	ff 92       	push	r15
    27a2:	0f 93       	push	r16
    27a4:	1f 93       	push	r17
    27a6:	cf 93       	push	r28
    27a8:	df 93       	push	r29
    27aa:	cd b7       	in	r28, 0x3d	; 61
    27ac:	de b7       	in	r29, 0x3e	; 62
    27ae:	a1 97       	sbiw	r28, 0x21	; 33
    27b0:	0f b6       	in	r0, 0x3f	; 63
    27b2:	f8 94       	cli
    27b4:	de bf       	out	0x3e, r29	; 62
    27b6:	0f be       	out	0x3f, r0	; 63
    27b8:	cd bf       	out	0x3d, r28	; 61
	
	func_state=EDIT_USER_STATE_ENTER_ID;
	func_last_state=EDIT_USER_STATE_ENTER_ID;
	func_error_state=EDIT_USER_NO_ERROR;
	
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    27ba:	6f ef       	ldi	r22, 0xFF	; 255
    27bc:	7f ef       	ldi	r23, 0xFF	; 255
    27be:	80 91 2f 08 	lds	r24, 0x082F
    27c2:	90 91 30 08 	lds	r25, 0x0830
    27c6:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmitString_program(PSTR("--------------------------------"));
    27ca:	89 eb       	ldi	r24, 0xB9	; 185
    27cc:	97 e0       	ldi	r25, 0x07	; 7
    27ce:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    27d2:	8d e0       	ldi	r24, 0x0D	; 13
    27d4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	u8 name[10];
	u8 pass[4];
	
	func_state=EDIT_USER_STATE_ENTER_ID;
	func_last_state=EDIT_USER_STATE_ENTER_ID;
	func_error_state=EDIT_USER_NO_ERROR;
    27d8:	80 e0       	ldi	r24, 0x00	; 0
	u8 id,type,index;
	u8 name[10];
	u8 pass[4];
	
	func_state=EDIT_USER_STATE_ENTER_ID;
	func_last_state=EDIT_USER_STATE_ENTER_ID;
    27da:	00 e0       	ldi	r16, 0x00	; 0
	user_t user;
	u8 id,type,index;
	u8 name[10];
	u8 pass[4];
	
	func_state=EDIT_USER_STATE_ENTER_ID;
    27dc:	10 e0       	ldi	r17, 0x00	; 0
			case EDIT_USER_INAVLID_TYPE_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("WRONG USER TYPE ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    27de:	0f 2e       	mov	r0, r31
    27e0:	f7 e0       	ldi	r31, 0x07	; 7
    27e2:	9f 2e       	mov	r9, r31
    27e4:	f0 2d       	mov	r31, r0
			case EDIT_USER_INAVLID_PASS_USED :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("PASSWORD USED  ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    27e6:	0f 2e       	mov	r0, r31
    27e8:	f6 e0       	ldi	r31, 0x06	; 6
    27ea:	af 2e       	mov	r10, r31
    27ec:	f0 2d       	mov	r31, r0
			case EDIT_USER_INAVLID_PASS_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("INVALID PASSWORD ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    27ee:	0f 2e       	mov	r0, r31
    27f0:	f5 e0       	ldi	r31, 0x05	; 5
    27f2:	ff 2e       	mov	r15, r31
    27f4:	f0 2d       	mov	r31, r0
			case EDIT_USER_INVALID_OPTION_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("INVALID OPTION ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    27f6:	68 94       	set
    27f8:	dd 24       	eor	r13, r13
    27fa:	d1 f8       	bld	r13, 1
			case EDIT_USER_INAVLID_ID_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("INVALID ID ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    27fc:	bb 24       	eor	r11, r11
    27fe:	b3 94       	inc	r11
										if(type <=2)
										{
											//add user in eeprom
											func_state=EDIT_USER_SAVE_IN_MEMORY;
											func_error_state=EDIT_USER_NO_ERROR;
											func_last_state=EDIT_USER_TYPE;
    2800:	68 94       	set
    2802:	ee 24       	eor	r14, r14
    2804:	e2 f8       	bld	r14, 2
										xSemaphoreGive(i2c_mutex);
										if(result ==PASSWORD_NOT_FOUND)
										{
											func_state=EDIT_USER_SAVE_IN_MEMORY;
											func_error_state=EDIT_USER_NO_ERROR;
											func_last_state=EDIT_USER_PASS;
    2806:	0f 2e       	mov	r0, r31
    2808:	f3 e0       	ldi	r31, 0x03	; 3
    280a:	cf 2e       	mov	r12, r31
    280c:	f0 2d       	mov	r31, r0
	
	vUartTransmitString_program(PSTR("--------------------------------"));
	vUartTransmit(ENTER_KEY);
	while(1)
	{
		switch(func_state)
    280e:	12 30       	cpi	r17, 0x02	; 2
    2810:	09 f4       	brne	.+2      	; 0x2814 <edit_users+0x82>
    2812:	6c c0       	rjmp	.+216    	; 0x28ec <edit_users+0x15a>
    2814:	30 f4       	brcc	.+12     	; 0x2822 <edit_users+0x90>
    2816:	11 23       	and	r17, r17
    2818:	69 f0       	breq	.+26     	; 0x2834 <edit_users+0xa2>
    281a:	11 30       	cpi	r17, 0x01	; 1
    281c:	09 f0       	breq	.+2      	; 0x2820 <edit_users+0x8e>
    281e:	63 c1       	rjmp	.+710    	; 0x2ae6 <edit_users+0x354>
    2820:	4c c0       	rjmp	.+152    	; 0x28ba <edit_users+0x128>
    2822:	14 30       	cpi	r17, 0x04	; 4
    2824:	09 f4       	brne	.+2      	; 0x2828 <edit_users+0x96>
    2826:	c1 c0       	rjmp	.+386    	; 0x29aa <edit_users+0x218>
    2828:	08 f4       	brcc	.+2      	; 0x282c <edit_users+0x9a>
    282a:	8d c0       	rjmp	.+282    	; 0x2946 <edit_users+0x1b4>
    282c:	15 30       	cpi	r17, 0x05	; 5
    282e:	09 f0       	breq	.+2      	; 0x2832 <edit_users+0xa0>
    2830:	5a c1       	rjmp	.+692    	; 0x2ae6 <edit_users+0x354>
    2832:	ce c0       	rjmp	.+412    	; 0x29d0 <edit_users+0x23e>
		{
			case EDIT_USER_STATE_ENTER_ID :
										vUartTransmit(ENTER_KEY);
    2834:	8d e0       	ldi	r24, 0x0D	; 13
    2836:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("ENTER USER ID : "));
    283a:	8a ed       	ldi	r24, 0xDA	; 218
    283c:	97 e0       	ldi	r25, 0x07	; 7
    283e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										result=get_u8(&(id));
    2842:	ce 01       	movw	r24, r28
    2844:	42 96       	adiw	r24, 0x12	; 18
    2846:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
										if(result == TERMINAL_RETURN_U8)
    284a:	8a 3a       	cpi	r24, 0xAA	; 170
    284c:	09 f0       	breq	.+2      	; 0x2850 <edit_users+0xbe>
    284e:	c7 c1       	rjmp	.+910    	; 0x2bde <edit_users+0x44c>
										{
											//check user by id
											id=id-1;
    2850:	8a 89       	ldd	r24, Y+18	; 0x12
    2852:	81 50       	subi	r24, 0x01	; 1
    2854:	8a 8b       	std	Y+18, r24	; 0x12
											xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2856:	6f ef       	ldi	r22, 0xFF	; 255
    2858:	7f ef       	ldi	r23, 0xFF	; 255
    285a:	80 91 2d 08 	lds	r24, 0x082D
    285e:	90 91 2e 08 	lds	r25, 0x082E
    2862:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
											result=u8EXTERNAL_EEPROM_search_user_byID(id);
    2866:	8a 89       	ldd	r24, Y+18	; 0x12
    2868:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <u8EXTERNAL_EEPROM_search_user_byID>
    286c:	88 2e       	mov	r8, r24
											xSemaphoreGive(i2c_mutex);
    286e:	20 e0       	ldi	r18, 0x00	; 0
    2870:	40 e0       	ldi	r20, 0x00	; 0
    2872:	50 e0       	ldi	r21, 0x00	; 0
    2874:	60 e0       	ldi	r22, 0x00	; 0
    2876:	70 e0       	ldi	r23, 0x00	; 0
    2878:	80 91 2d 08 	lds	r24, 0x082D
    287c:	90 91 2e 08 	lds	r25, 0x082E
    2880:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
											if(result ==USER_FOUND)
    2884:	81 10       	cpse	r8, r1
    2886:	42 c1       	rjmp	.+644    	; 0x2b0c <edit_users+0x37a>
											{
												//get user
												xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2888:	6f ef       	ldi	r22, 0xFF	; 255
    288a:	7f ef       	ldi	r23, 0xFF	; 255
    288c:	80 91 2d 08 	lds	r24, 0x082D
    2890:	90 91 2e 08 	lds	r25, 0x082E
    2894:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
												vEXTERNAL_EEPROM_get_user(&user,id);
    2898:	6a 89       	ldd	r22, Y+18	; 0x12
    289a:	ce 01       	movw	r24, r28
    289c:	02 96       	adiw	r24, 0x02	; 2
    289e:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <vEXTERNAL_EEPROM_get_user>
												xSemaphoreGive(i2c_mutex);
    28a2:	20 e0       	ldi	r18, 0x00	; 0
    28a4:	40 e0       	ldi	r20, 0x00	; 0
    28a6:	50 e0       	ldi	r21, 0x00	; 0
    28a8:	60 e0       	ldi	r22, 0x00	; 0
    28aa:	70 e0       	ldi	r23, 0x00	; 0
    28ac:	80 91 2d 08 	lds	r24, 0x082D
    28b0:	90 91 2e 08 	lds	r25, 0x082E
    28b4:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
												func_state=EDIT_USER_CHOOSE_EDIT;
    28b8:	1b 2d       	mov	r17, r11
											//invalid type
											func_error_state=EDIT_USER_TIMEOUT_ERROR;
											break;
										}
			case EDIT_USER_CHOOSE_EDIT :
										vUartTransmit(ENTER_KEY);
    28ba:	8d e0       	ldi	r24, 0x0D	; 13
    28bc:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("SELECT FIELD  (1 -> NAME) (2 -> PASS) (3 -> TYPE) : "));
    28c0:	8b ee       	ldi	r24, 0xEB	; 235
    28c2:	97 e0       	ldi	r25, 0x07	; 7
    28c4:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										result=get_u8(&(type));
    28c8:	ce 01       	movw	r24, r28
    28ca:	43 96       	adiw	r24, 0x13	; 19
    28cc:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
										if(result == TERMINAL_RETURN_U8)
    28d0:	8a 3a       	cpi	r24, 0xAA	; 170
    28d2:	09 f0       	breq	.+2      	; 0x28d6 <edit_users+0x144>
    28d4:	84 c1       	rjmp	.+776    	; 0x2bde <edit_users+0x44c>
										{
											if(type ==1)
    28d6:	8b 89       	ldd	r24, Y+19	; 0x13
    28d8:	81 30       	cpi	r24, 0x01	; 1
    28da:	09 f4       	brne	.+2      	; 0x28de <edit_users+0x14c>
    28dc:	8c c1       	rjmp	.+792    	; 0x2bf6 <edit_users+0x464>
											{
												//choose which
												func_state=EDIT_USER_NAME;
												func_error_state=EDIT_USER_NO_ERROR;
											}
											else if(type==2)
    28de:	82 30       	cpi	r24, 0x02	; 2
    28e0:	09 f4       	brne	.+2      	; 0x28e4 <edit_users+0x152>
    28e2:	8b c1       	rjmp	.+790    	; 0x2bfa <edit_users+0x468>
											{
												func_state=EDIT_USER_PASS;
												func_error_state=EDIT_USER_NO_ERROR;
											}
											else if(type==3)
    28e4:	83 30       	cpi	r24, 0x03	; 3
    28e6:	09 f0       	breq	.+2      	; 0x28ea <edit_users+0x158>
    28e8:	20 c1       	rjmp	.+576    	; 0x2b2a <edit_users+0x398>
    28ea:	89 c1       	rjmp	.+786    	; 0x2bfe <edit_users+0x46c>
											func_error_state=EDIT_USER_TIMEOUT_ERROR;
											break;
										}
										break;
			case EDIT_USER_NAME :
									vUartTransmit(ENTER_KEY);
    28ec:	8d e0       	ldi	r24, 0x0D	; 13
    28ee:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									vUartTransmitString_program(PSTR("ENTER USER NAME (MAX 9 CHAR) : "));
    28f2:	80 e2       	ldi	r24, 0x20	; 32
    28f4:	98 e0       	ldi	r25, 0x08	; 8
    28f6:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
									result=get_user_name(&(name[0]));
    28fa:	ce 01       	movw	r24, r28
    28fc:	44 96       	adiw	r24, 0x14	; 20
    28fe:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <get_user_name>
									if(result == VALID_NAME)
    2902:	81 11       	cpse	r24, r1
    2904:	1c c0       	rjmp	.+56     	; 0x293e <edit_users+0x1ac>
									{
										//check if name is used
										xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2906:	6f ef       	ldi	r22, 0xFF	; 255
    2908:	7f ef       	ldi	r23, 0xFF	; 255
    290a:	80 91 2d 08 	lds	r24, 0x082D
    290e:	90 91 2e 08 	lds	r25, 0x082E
    2912:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
										result=u8EXTERNAL_EEPROM_search_by_name(name);
    2916:	ce 01       	movw	r24, r28
    2918:	44 96       	adiw	r24, 0x14	; 20
    291a:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <u8EXTERNAL_EEPROM_search_by_name>
    291e:	88 2e       	mov	r8, r24
										xSemaphoreGive(i2c_mutex);
    2920:	20 e0       	ldi	r18, 0x00	; 0
    2922:	40 e0       	ldi	r20, 0x00	; 0
    2924:	50 e0       	ldi	r21, 0x00	; 0
    2926:	60 e0       	ldi	r22, 0x00	; 0
    2928:	70 e0       	ldi	r23, 0x00	; 0
    292a:	80 91 2d 08 	lds	r24, 0x082D
    292e:	90 91 2e 08 	lds	r25, 0x082E
    2932:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
										if(result ==USER_NAME_NOT_FOUND)
    2936:	8f ef       	ldi	r24, 0xFF	; 255
    2938:	88 12       	cpse	r8, r24
    293a:	15 c1       	rjmp	.+554    	; 0x2b66 <edit_users+0x3d4>
    293c:	62 c1       	rjmp	.+708    	; 0x2c02 <edit_users+0x470>
											func_error_state=EDIT_USER_NAME_USED_ERROR;
											break;
										}
				
									}
									else if(result==TERMINAL_RETURN_U8)
    293e:	8a 3a       	cpi	r24, 0xAA	; 170
    2940:	09 f0       	breq	.+2      	; 0x2944 <edit_users+0x1b2>
    2942:	4d c1       	rjmp	.+666    	; 0x2bde <edit_users+0x44c>
    2944:	01 c1       	rjmp	.+514    	; 0x2b48 <edit_users+0x3b6>
										func_error_state=EDIT_USER_TIMEOUT_ERROR;
										break;
									}
									break;
			case EDIT_USER_PASS :
									vUartTransmit(ENTER_KEY);
    2946:	8d e0       	ldi	r24, 0x0D	; 13
    2948:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									vUartTransmitString_program(PSTR("ENTER USER PASSWORD (4 DIGIT) : "));
    294c:	80 e4       	ldi	r24, 0x40	; 64
    294e:	98 e0       	ldi	r25, 0x08	; 8
    2950:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
									result=u8Get_user_password_arr(&(pass[0]));
    2954:	ce 01       	movw	r24, r28
    2956:	4e 96       	adiw	r24, 0x1e	; 30
    2958:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <u8Get_user_password_arr>
									if(result==PASSWORD_VALID)
    295c:	81 11       	cpse	r24, r1
    295e:	12 c1       	rjmp	.+548    	; 0x2b84 <edit_users+0x3f2>
									{
										xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2960:	6f ef       	ldi	r22, 0xFF	; 255
    2962:	7f ef       	ldi	r23, 0xFF	; 255
    2964:	80 91 2d 08 	lds	r24, 0x082D
    2968:	90 91 2e 08 	lds	r25, 0x082E
    296c:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
										result=u8EXTERNAL_EEPROM_search_by_password(pass,name,&temp,&type);
    2970:	9e 01       	movw	r18, r28
    2972:	2d 5e       	subi	r18, 0xED	; 237
    2974:	3f 4f       	sbci	r19, 0xFF	; 255
    2976:	ae 01       	movw	r20, r28
    2978:	4f 5f       	subi	r20, 0xFF	; 255
    297a:	5f 4f       	sbci	r21, 0xFF	; 255
    297c:	be 01       	movw	r22, r28
    297e:	6c 5e       	subi	r22, 0xEC	; 236
    2980:	7f 4f       	sbci	r23, 0xFF	; 255
    2982:	ce 01       	movw	r24, r28
    2984:	4e 96       	adiw	r24, 0x1e	; 30
    2986:	0e 94 3f 1e 	call	0x3c7e	; 0x3c7e <u8EXTERNAL_EEPROM_search_by_password>
    298a:	88 2e       	mov	r8, r24
										xSemaphoreGive(i2c_mutex);
    298c:	20 e0       	ldi	r18, 0x00	; 0
    298e:	40 e0       	ldi	r20, 0x00	; 0
    2990:	50 e0       	ldi	r21, 0x00	; 0
    2992:	60 e0       	ldi	r22, 0x00	; 0
    2994:	70 e0       	ldi	r23, 0x00	; 0
    2996:	80 91 2d 08 	lds	r24, 0x082D
    299a:	90 91 2e 08 	lds	r25, 0x082E
    299e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
										if(result ==PASSWORD_NOT_FOUND)
    29a2:	8f ef       	ldi	r24, 0xFF	; 255
    29a4:	88 12       	cpse	r8, r24
    29a6:	fd c0       	rjmp	.+506    	; 0x2ba2 <edit_users+0x410>
    29a8:	2f c1       	rjmp	.+606    	; 0x2c08 <edit_users+0x476>
										func_error_state=EDIT_USER_INAVLID_PASS_ERROR;
										break;
									}
									break;
			case EDIT_USER_TYPE :
									vUartTransmit(ENTER_KEY);
    29aa:	8d e0       	ldi	r24, 0x0D	; 13
    29ac:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									vUartTransmitString_program(PSTR("ENTER USER TYPE (ROOT = 0) | (admin = 1) | (user = 2)  : "));
    29b0:	81 e6       	ldi	r24, 0x61	; 97
    29b2:	98 e0       	ldi	r25, 0x08	; 8
    29b4:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
									result=get_u8(&(type));
    29b8:	ce 01       	movw	r24, r28
    29ba:	43 96       	adiw	r24, 0x13	; 19
    29bc:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
									if(result == TERMINAL_RETURN_U8)
    29c0:	8a 3a       	cpi	r24, 0xAA	; 170
    29c2:	09 f0       	breq	.+2      	; 0x29c6 <edit_users+0x234>
    29c4:	0c c1       	rjmp	.+536    	; 0x2bde <edit_users+0x44c>
									{
										if(type <=2)
    29c6:	8b 89       	ldd	r24, Y+19	; 0x13
    29c8:	83 30       	cpi	r24, 0x03	; 3
    29ca:	08 f4       	brcc	.+2      	; 0x29ce <edit_users+0x23c>
    29cc:	20 c1       	rjmp	.+576    	; 0x2c0e <edit_users+0x47c>
    29ce:	f8 c0       	rjmp	.+496    	; 0x2bc0 <edit_users+0x42e>
										//invalid type
										func_error_state=EDIT_USER_TIMEOUT_ERROR;
										break;
									}
			case EDIT_USER_SAVE_IN_MEMORY :
									if(func_last_state ==EDIT_USER_NAME)
    29d0:	02 30       	cpi	r16, 0x02	; 2
    29d2:	21 f5       	brne	.+72     	; 0x2a1c <edit_users+0x28a>
    29d4:	fe 01       	movw	r30, r28
    29d6:	74 96       	adiw	r30, 0x14	; 20
    29d8:	de 01       	movw	r26, r28
    29da:	12 96       	adiw	r26, 0x02	; 2
			default:break;
		}
	}
}
//---------------------------
void edit_users(void)
    29dc:	ce 01       	movw	r24, r28
    29de:	4d 96       	adiw	r24, 0x1d	; 29
									if(func_last_state ==EDIT_USER_NAME)
									{
										// id +name
										for(index=0;index<MAX_USER_NAME;index++)
										{
											user.name[index]=name[index];
    29e0:	21 91       	ld	r18, Z+
    29e2:	2d 93       	st	X+, r18
									}
			case EDIT_USER_SAVE_IN_MEMORY :
									if(func_last_state ==EDIT_USER_NAME)
									{
										// id +name
										for(index=0;index<MAX_USER_NAME;index++)
    29e4:	e8 17       	cp	r30, r24
    29e6:	f9 07       	cpc	r31, r25
    29e8:	d9 f7       	brne	.-10     	; 0x29e0 <edit_users+0x24e>
										{
											user.name[index]=name[index];
										}
										xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    29ea:	6f ef       	ldi	r22, 0xFF	; 255
    29ec:	7f ef       	ldi	r23, 0xFF	; 255
    29ee:	80 91 2d 08 	lds	r24, 0x082D
    29f2:	90 91 2e 08 	lds	r25, 0x082E
    29f6:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
										vEXTERNAL_EEPROM_edit_user(&user,id);
    29fa:	6a 89       	ldd	r22, Y+18	; 0x12
    29fc:	ce 01       	movw	r24, r28
    29fe:	02 96       	adiw	r24, 0x02	; 2
    2a00:	0e 94 b6 1f 	call	0x3f6c	; 0x3f6c <vEXTERNAL_EEPROM_edit_user>
										xSemaphoreGive(i2c_mutex);
    2a04:	20 e0       	ldi	r18, 0x00	; 0
    2a06:	40 e0       	ldi	r20, 0x00	; 0
    2a08:	50 e0       	ldi	r21, 0x00	; 0
    2a0a:	60 e0       	ldi	r22, 0x00	; 0
    2a0c:	70 e0       	ldi	r23, 0x00	; 0
    2a0e:	80 91 2d 08 	lds	r24, 0x082D
    2a12:	90 91 2e 08 	lds	r25, 0x082E
    2a16:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2a1a:	4c c0       	rjmp	.+152    	; 0x2ab4 <edit_users+0x322>
									}
									else if(func_last_state ==EDIT_USER_PASS)
    2a1c:	03 30       	cpi	r16, 0x03	; 3
    2a1e:	09 f5       	brne	.+66     	; 0x2a62 <edit_users+0x2d0>
									{
										//pass +id
										for(index=0;index<MAX_USER_PASSWORD;index++)
										{
											user.password[index]=pass[index];
    2a20:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2a22:	8c 87       	std	Y+12, r24	; 0x0c
    2a24:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2a26:	8d 87       	std	Y+13, r24	; 0x0d
    2a28:	88 a1       	ldd	r24, Y+32	; 0x20
    2a2a:	8e 87       	std	Y+14, r24	; 0x0e
    2a2c:	89 a1       	ldd	r24, Y+33	; 0x21
    2a2e:	8f 87       	std	Y+15, r24	; 0x0f
										}
										xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2a30:	6f ef       	ldi	r22, 0xFF	; 255
    2a32:	7f ef       	ldi	r23, 0xFF	; 255
    2a34:	80 91 2d 08 	lds	r24, 0x082D
    2a38:	90 91 2e 08 	lds	r25, 0x082E
    2a3c:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
										vEXTERNAL_EEPROM_edit_user(&user,id);
    2a40:	6a 89       	ldd	r22, Y+18	; 0x12
    2a42:	ce 01       	movw	r24, r28
    2a44:	02 96       	adiw	r24, 0x02	; 2
    2a46:	0e 94 b6 1f 	call	0x3f6c	; 0x3f6c <vEXTERNAL_EEPROM_edit_user>
										xSemaphoreGive(i2c_mutex);
    2a4a:	20 e0       	ldi	r18, 0x00	; 0
    2a4c:	40 e0       	ldi	r20, 0x00	; 0
    2a4e:	50 e0       	ldi	r21, 0x00	; 0
    2a50:	60 e0       	ldi	r22, 0x00	; 0
    2a52:	70 e0       	ldi	r23, 0x00	; 0
    2a54:	80 91 2d 08 	lds	r24, 0x082D
    2a58:	90 91 2e 08 	lds	r25, 0x082E
    2a5c:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2a60:	29 c0       	rjmp	.+82     	; 0x2ab4 <edit_users+0x322>
				
									}
									else if(func_last_state ==EDIT_USER_TYPE)
    2a62:	04 30       	cpi	r16, 0x04	; 4
    2a64:	d9 f4       	brne	.+54     	; 0x2a9c <edit_users+0x30a>
									{
										user.type=type;
    2a66:	8b 89       	ldd	r24, Y+19	; 0x13
    2a68:	88 8b       	std	Y+16, r24	; 0x10
										xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2a6a:	6f ef       	ldi	r22, 0xFF	; 255
    2a6c:	7f ef       	ldi	r23, 0xFF	; 255
    2a6e:	80 91 2d 08 	lds	r24, 0x082D
    2a72:	90 91 2e 08 	lds	r25, 0x082E
    2a76:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
										vEXTERNAL_EEPROM_edit_user(&user,id);
    2a7a:	6a 89       	ldd	r22, Y+18	; 0x12
    2a7c:	ce 01       	movw	r24, r28
    2a7e:	02 96       	adiw	r24, 0x02	; 2
    2a80:	0e 94 b6 1f 	call	0x3f6c	; 0x3f6c <vEXTERNAL_EEPROM_edit_user>
										xSemaphoreGive(i2c_mutex);
    2a84:	20 e0       	ldi	r18, 0x00	; 0
    2a86:	40 e0       	ldi	r20, 0x00	; 0
    2a88:	50 e0       	ldi	r21, 0x00	; 0
    2a8a:	60 e0       	ldi	r22, 0x00	; 0
    2a8c:	70 e0       	ldi	r23, 0x00	; 0
    2a8e:	80 91 2d 08 	lds	r24, 0x082D
    2a92:	90 91 2e 08 	lds	r25, 0x082E
    2a96:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2a9a:	0c c0       	rjmp	.+24     	; 0x2ab4 <edit_users+0x322>
				
									}
									else
									{
										//error
										xSemaphoreGive(uart_mutex);
    2a9c:	20 e0       	ldi	r18, 0x00	; 0
    2a9e:	40 e0       	ldi	r20, 0x00	; 0
    2aa0:	50 e0       	ldi	r21, 0x00	; 0
    2aa2:	60 e0       	ldi	r22, 0x00	; 0
    2aa4:	70 e0       	ldi	r23, 0x00	; 0
    2aa6:	80 91 2f 08 	lds	r24, 0x082F
    2aaa:	90 91 30 08 	lds	r25, 0x0830
    2aae:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2ab2:	b1 c0       	rjmp	.+354    	; 0x2c16 <edit_users+0x484>
										return;
									}
									vUartTransmit(ENTER_KEY);
    2ab4:	8d e0       	ldi	r24, 0x0D	; 13
    2ab6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									vUartTransmitString_program(PSTR("DONE EDITING ......... "));
    2aba:	8b e9       	ldi	r24, 0x9B	; 155
    2abc:	98 e0       	ldi	r25, 0x08	; 8
    2abe:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
									vUartTransmit(ENTER_KEY);
    2ac2:	8d e0       	ldi	r24, 0x0D	; 13
    2ac4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									vUartTransmit(ENTER_KEY);
    2ac8:	8d e0       	ldi	r24, 0x0D	; 13
    2aca:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
									
									xSemaphoreGive(uart_mutex);
    2ace:	20 e0       	ldi	r18, 0x00	; 0
    2ad0:	40 e0       	ldi	r20, 0x00	; 0
    2ad2:	50 e0       	ldi	r21, 0x00	; 0
    2ad4:	60 e0       	ldi	r22, 0x00	; 0
    2ad6:	70 e0       	ldi	r23, 0x00	; 0
    2ad8:	80 91 2f 08 	lds	r24, 0x082F
    2adc:	90 91 30 08 	lds	r25, 0x0830
    2ae0:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2ae4:	98 c0       	rjmp	.+304    	; 0x2c16 <edit_users+0x484>
									return;
			default :break;
		}
		switch(func_error_state)
    2ae6:	84 30       	cpi	r24, 0x04	; 4
    2ae8:	f1 f1       	breq	.+124    	; 0x2b66 <edit_users+0x3d4>
    2aea:	38 f4       	brcc	.+14     	; 0x2afa <edit_users+0x368>
    2aec:	82 30       	cpi	r24, 0x02	; 2
    2aee:	e9 f0       	breq	.+58     	; 0x2b2a <edit_users+0x398>
    2af0:	58 f5       	brcc	.+86     	; 0x2b48 <edit_users+0x3b6>
    2af2:	81 30       	cpi	r24, 0x01	; 1
    2af4:	09 f0       	breq	.+2      	; 0x2af8 <edit_users+0x366>
    2af6:	8b ce       	rjmp	.-746    	; 0x280e <edit_users+0x7c>
    2af8:	09 c0       	rjmp	.+18     	; 0x2b0c <edit_users+0x37a>
    2afa:	86 30       	cpi	r24, 0x06	; 6
    2afc:	09 f4       	brne	.+2      	; 0x2b00 <edit_users+0x36e>
    2afe:	51 c0       	rjmp	.+162    	; 0x2ba2 <edit_users+0x410>
    2b00:	08 f4       	brcc	.+2      	; 0x2b04 <edit_users+0x372>
    2b02:	40 c0       	rjmp	.+128    	; 0x2b84 <edit_users+0x3f2>
    2b04:	87 30       	cpi	r24, 0x07	; 7
    2b06:	09 f0       	breq	.+2      	; 0x2b0a <edit_users+0x378>
    2b08:	82 ce       	rjmp	.-764    	; 0x280e <edit_users+0x7c>
    2b0a:	5a c0       	rjmp	.+180    	; 0x2bc0 <edit_users+0x42e>
		{
			case EDIT_USER_NO_ERROR :break;
			case EDIT_USER_INAVLID_ID_ERROR :
										vUartTransmit(ENTER_KEY);
    2b0c:	8d e0       	ldi	r24, 0x0D	; 13
    2b0e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("INVALID ID ......... "));
    2b12:	83 eb       	ldi	r24, 0xB3	; 179
    2b14:	98 e0       	ldi	r25, 0x08	; 8
    2b16:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2b1a:	8d e0       	ldi	r24, 0x0D	; 13
    2b1c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2b20:	8d e0       	ldi	r24, 0x0D	; 13
    2b22:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2b26:	8b 2d       	mov	r24, r11
    2b28:	72 ce       	rjmp	.-796    	; 0x280e <edit_users+0x7c>
			case EDIT_USER_INVALID_OPTION_ERROR :
										vUartTransmit(ENTER_KEY);
    2b2a:	8d e0       	ldi	r24, 0x0D	; 13
    2b2c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("INVALID OPTION ......... "));
    2b30:	89 ec       	ldi	r24, 0xC9	; 201
    2b32:	98 e0       	ldi	r25, 0x08	; 8
    2b34:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2b38:	8d e0       	ldi	r24, 0x0D	; 13
    2b3a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2b3e:	8d e0       	ldi	r24, 0x0D	; 13
    2b40:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2b44:	8d 2d       	mov	r24, r13
    2b46:	63 ce       	rjmp	.-826    	; 0x280e <edit_users+0x7c>
			case EDIT_USER_NAME_INAVLID_ERROR :
										vUartTransmit(ENTER_KEY);
    2b48:	8d e0       	ldi	r24, 0x0D	; 13
    2b4a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("INVALID USER NAME ......... "));
    2b4e:	83 ee       	ldi	r24, 0xE3	; 227
    2b50:	98 e0       	ldi	r25, 0x08	; 8
    2b52:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2b56:	8d e0       	ldi	r24, 0x0D	; 13
    2b58:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2b5c:	8d e0       	ldi	r24, 0x0D	; 13
    2b5e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2b62:	8c 2d       	mov	r24, r12
    2b64:	54 ce       	rjmp	.-856    	; 0x280e <edit_users+0x7c>
			case EDIT_USER_NAME_USED_ERROR :
										vUartTransmit(ENTER_KEY);
    2b66:	8d e0       	ldi	r24, 0x0D	; 13
    2b68:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("USER NAME USED  ......... "));
    2b6c:	80 e0       	ldi	r24, 0x00	; 0
    2b6e:	99 e0       	ldi	r25, 0x09	; 9
    2b70:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2b74:	8d e0       	ldi	r24, 0x0D	; 13
    2b76:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2b7a:	8d e0       	ldi	r24, 0x0D	; 13
    2b7c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2b80:	8e 2d       	mov	r24, r14
    2b82:	45 ce       	rjmp	.-886    	; 0x280e <edit_users+0x7c>
			case EDIT_USER_INAVLID_PASS_ERROR :
										vUartTransmit(ENTER_KEY);
    2b84:	8d e0       	ldi	r24, 0x0D	; 13
    2b86:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("INVALID PASSWORD ......... "));
    2b8a:	8b e1       	ldi	r24, 0x1B	; 27
    2b8c:	99 e0       	ldi	r25, 0x09	; 9
    2b8e:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2b92:	8d e0       	ldi	r24, 0x0D	; 13
    2b94:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2b98:	8d e0       	ldi	r24, 0x0D	; 13
    2b9a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2b9e:	8f 2d       	mov	r24, r15
    2ba0:	36 ce       	rjmp	.-916    	; 0x280e <edit_users+0x7c>
			case EDIT_USER_INAVLID_PASS_USED :
										vUartTransmit(ENTER_KEY);
    2ba2:	8d e0       	ldi	r24, 0x0D	; 13
    2ba4:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("PASSWORD USED  ......... "));
    2ba8:	87 e3       	ldi	r24, 0x37	; 55
    2baa:	99 e0       	ldi	r25, 0x09	; 9
    2bac:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2bb0:	8d e0       	ldi	r24, 0x0D	; 13
    2bb2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2bb6:	8d e0       	ldi	r24, 0x0D	; 13
    2bb8:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2bbc:	8a 2d       	mov	r24, r10
    2bbe:	27 ce       	rjmp	.-946    	; 0x280e <edit_users+0x7c>
			case EDIT_USER_INAVLID_TYPE_ERROR :
										vUartTransmit(ENTER_KEY);
    2bc0:	8d e0       	ldi	r24, 0x0D	; 13
    2bc2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmitString_program(PSTR("WRONG USER TYPE ......... "));
    2bc6:	81 e5       	ldi	r24, 0x51	; 81
    2bc8:	99 e0       	ldi	r25, 0x09	; 9
    2bca:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
										vUartTransmit(ENTER_KEY);
    2bce:	8d e0       	ldi	r24, 0x0D	; 13
    2bd0:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										vUartTransmit(ENTER_KEY);
    2bd4:	8d e0       	ldi	r24, 0x0D	; 13
    2bd6:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
										break;
    2bda:	89 2d       	mov	r24, r9
    2bdc:	18 ce       	rjmp	.-976    	; 0x280e <edit_users+0x7c>
			case EDIT_USER_TIMEOUT_ERROR :
											xSemaphoreGive(uart_mutex);
    2bde:	20 e0       	ldi	r18, 0x00	; 0
    2be0:	40 e0       	ldi	r20, 0x00	; 0
    2be2:	50 e0       	ldi	r21, 0x00	; 0
    2be4:	60 e0       	ldi	r22, 0x00	; 0
    2be6:	70 e0       	ldi	r23, 0x00	; 0
    2be8:	80 91 2f 08 	lds	r24, 0x082F
    2bec:	90 91 30 08 	lds	r25, 0x0830
    2bf0:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2bf4:	10 c0       	rjmp	.+32     	; 0x2c16 <edit_users+0x484>
										if(result == TERMINAL_RETURN_U8)
										{
											if(type ==1)
											{
												//choose which
												func_state=EDIT_USER_NAME;
    2bf6:	1d 2d       	mov	r17, r13
    2bf8:	0c c0       	rjmp	.+24     	; 0x2c12 <edit_users+0x480>
												func_error_state=EDIT_USER_NO_ERROR;
											}
											else if(type==2)
											{
												func_state=EDIT_USER_PASS;
    2bfa:	1c 2d       	mov	r17, r12
    2bfc:	0a c0       	rjmp	.+20     	; 0x2c12 <edit_users+0x480>
												func_error_state=EDIT_USER_NO_ERROR;
											}
											else if(type==3)
											{
												func_state=EDIT_USER_TYPE;
    2bfe:	1e 2d       	mov	r17, r14
    2c00:	08 c0       	rjmp	.+16     	; 0x2c12 <edit_users+0x480>
										if(result ==USER_NAME_NOT_FOUND)
										{
											//save name in the user id
											func_error_state=EDIT_USER_NO_ERROR;
											func_state=EDIT_USER_SAVE_IN_MEMORY;
											func_last_state=EDIT_USER_NAME;
    2c02:	0d 2d       	mov	r16, r13
										xSemaphoreGive(i2c_mutex);
										if(result ==USER_NAME_NOT_FOUND)
										{
											//save name in the user id
											func_error_state=EDIT_USER_NO_ERROR;
											func_state=EDIT_USER_SAVE_IN_MEMORY;
    2c04:	1f 2d       	mov	r17, r15
    2c06:	05 c0       	rjmp	.+10     	; 0x2c12 <edit_users+0x480>
										xSemaphoreGive(i2c_mutex);
										if(result ==PASSWORD_NOT_FOUND)
										{
											func_state=EDIT_USER_SAVE_IN_MEMORY;
											func_error_state=EDIT_USER_NO_ERROR;
											func_last_state=EDIT_USER_PASS;
    2c08:	0c 2d       	mov	r16, r12
										xSemaphoreTake(i2c_mutex,portMAX_DELAY);
										result=u8EXTERNAL_EEPROM_search_by_password(pass,name,&temp,&type);
										xSemaphoreGive(i2c_mutex);
										if(result ==PASSWORD_NOT_FOUND)
										{
											func_state=EDIT_USER_SAVE_IN_MEMORY;
    2c0a:	1f 2d       	mov	r17, r15
    2c0c:	02 c0       	rjmp	.+4      	; 0x2c12 <edit_users+0x480>
										if(type <=2)
										{
											//add user in eeprom
											func_state=EDIT_USER_SAVE_IN_MEMORY;
											func_error_state=EDIT_USER_NO_ERROR;
											func_last_state=EDIT_USER_TYPE;
    2c0e:	0e 2d       	mov	r16, r14
									if(result == TERMINAL_RETURN_U8)
									{
										if(type <=2)
										{
											//add user in eeprom
											func_state=EDIT_USER_SAVE_IN_MEMORY;
    2c10:	1f 2d       	mov	r17, r15
			case EDIT_USER_INAVLID_TYPE_ERROR :
										vUartTransmit(ENTER_KEY);
										vUartTransmitString_program(PSTR("WRONG USER TYPE ......... "));
										vUartTransmit(ENTER_KEY);
										vUartTransmit(ENTER_KEY);
										break;
    2c12:	80 e0       	ldi	r24, 0x00	; 0
    2c14:	fc cd       	rjmp	.-1032   	; 0x280e <edit_users+0x7c>
											xSemaphoreGive(uart_mutex);
											return;
			default:break;
		}
	}
}
    2c16:	a1 96       	adiw	r28, 0x21	; 33
    2c18:	0f b6       	in	r0, 0x3f	; 63
    2c1a:	f8 94       	cli
    2c1c:	de bf       	out	0x3e, r29	; 62
    2c1e:	0f be       	out	0x3f, r0	; 63
    2c20:	cd bf       	out	0x3d, r28	; 61
    2c22:	df 91       	pop	r29
    2c24:	cf 91       	pop	r28
    2c26:	1f 91       	pop	r17
    2c28:	0f 91       	pop	r16
    2c2a:	ff 90       	pop	r15
    2c2c:	ef 90       	pop	r14
    2c2e:	df 90       	pop	r13
    2c30:	cf 90       	pop	r12
    2c32:	bf 90       	pop	r11
    2c34:	af 90       	pop	r10
    2c36:	9f 90       	pop	r9
    2c38:	8f 90       	pop	r8
    2c3a:	08 95       	ret

00002c3c <delete_users>:
//---------------------------------------------------------------------------
void delete_users(void)
{
    2c3c:	0f 93       	push	r16
    2c3e:	1f 93       	push	r17
    2c40:	cf 93       	push	r28
    2c42:	df 93       	push	r29
    2c44:	1f 92       	push	r1
    2c46:	cd b7       	in	r28, 0x3d	; 61
    2c48:	de b7       	in	r29, 0x3e	; 62
		UT_ERROR,
		ROOT_USER_ERROR,
		TIME_OUT_ERROR
	} func_error;
	
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2c4a:	6f ef       	ldi	r22, 0xFF	; 255
    2c4c:	7f ef       	ldi	r23, 0xFF	; 255
    2c4e:	80 91 2f 08 	lds	r24, 0x082F
    2c52:	90 91 30 08 	lds	r25, 0x0830
    2c56:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	
	vUartTransmit(ENTER_KEY);
    2c5a:	8d e0       	ldi	r24, 0x0D	; 13
    2c5c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("--------------------------------------------------"));
    2c60:	8c e6       	ldi	r24, 0x6C	; 108
    2c62:	99 e0       	ldi	r25, 0x09	; 9
    2c64:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	xSemaphoreGive(uart_mutex);
    2c68:	20 e0       	ldi	r18, 0x00	; 0
    2c6a:	40 e0       	ldi	r20, 0x00	; 0
    2c6c:	50 e0       	ldi	r21, 0x00	; 0
    2c6e:	60 e0       	ldi	r22, 0x00	; 0
    2c70:	70 e0       	ldi	r23, 0x00	; 0
    2c72:	80 91 2f 08 	lds	r24, 0x082F
    2c76:	90 91 30 08 	lds	r25, 0x0830
    2c7a:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
	func_state=INPUT_STATE;
    2c7e:	80 e0       	ldi	r24, 0x00	; 0
									result=u8EXTERNAL_EEPROM_search_user_byID(id);
									xSemaphoreGive(i2c_mutex);
									if(result ==USER_FOUND)
									{
										//choose which
										func_state=DELETE_STATE;
    2c80:	11 e0       	ldi	r17, 0x01	; 1
    2c82:	01 c0       	rjmp	.+2      	; 0x2c86 <delete_users+0x4a>
    2c84:	81 2f       	mov	r24, r17
	xSemaphoreGive(uart_mutex);
	func_state=INPUT_STATE;
	func_error=NO_ERROR;
	while(1)
	{
		switch(func_state)
    2c86:	88 23       	and	r24, r24
    2c88:	19 f0       	breq	.+6      	; 0x2c90 <delete_users+0x54>
    2c8a:	81 30       	cpi	r24, 0x01	; 1
    2c8c:	e1 f7       	brne	.-8      	; 0x2c86 <delete_users+0x4a>
    2c8e:	45 c0       	rjmp	.+138    	; 0x2d1a <delete_users+0xde>
		{
			case INPUT_STATE :
								xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2c90:	6f ef       	ldi	r22, 0xFF	; 255
    2c92:	7f ef       	ldi	r23, 0xFF	; 255
    2c94:	80 91 2f 08 	lds	r24, 0x082F
    2c98:	90 91 30 08 	lds	r25, 0x0830
    2c9c:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
								vUartTransmit(ENTER_KEY);
    2ca0:	8d e0       	ldi	r24, 0x0D	; 13
    2ca2:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								vUartTransmitString_program(PSTR("ENTER ID NUMBER : "));
    2ca6:	8f e9       	ldi	r24, 0x9F	; 159
    2ca8:	99 e0       	ldi	r25, 0x09	; 9
    2caa:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
								xSemaphoreGive(uart_mutex);
    2cae:	20 e0       	ldi	r18, 0x00	; 0
    2cb0:	40 e0       	ldi	r20, 0x00	; 0
    2cb2:	50 e0       	ldi	r21, 0x00	; 0
    2cb4:	60 e0       	ldi	r22, 0x00	; 0
    2cb6:	70 e0       	ldi	r23, 0x00	; 0
    2cb8:	80 91 2f 08 	lds	r24, 0x082F
    2cbc:	90 91 30 08 	lds	r25, 0x0830
    2cc0:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
								result=get_u8(&(id));
    2cc4:	ce 01       	movw	r24, r28
    2cc6:	01 96       	adiw	r24, 0x01	; 1
    2cc8:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <get_u8>
								if(result == TERMINAL_RETURN_U8)
    2ccc:	8a 3a       	cpi	r24, 0xAA	; 170
    2cce:	09 f0       	breq	.+2      	; 0x2cd2 <delete_users+0x96>
    2cd0:	73 c0       	rjmp	.+230    	; 0x2db8 <delete_users+0x17c>
								{
									//check user by id
									id=id-1;
    2cd2:	89 81       	ldd	r24, Y+1	; 0x01
    2cd4:	81 50       	subi	r24, 0x01	; 1
    2cd6:	89 83       	std	Y+1, r24	; 0x01
									if(id ==0)
    2cd8:	88 23       	and	r24, r24
    2cda:	09 f4       	brne	.+2      	; 0x2cde <delete_users+0xa2>
    2cdc:	55 c0       	rjmp	.+170    	; 0x2d88 <delete_users+0x14c>
									{
										func_error=ROOT_USER_ERROR;
										break;
									}
									if(id >=EEPROM_MAX_USER)
    2cde:	89 31       	cpi	r24, 0x19	; 25
    2ce0:	08 f0       	brcs	.+2      	; 0x2ce4 <delete_users+0xa8>
    2ce2:	52 c0       	rjmp	.+164    	; 0x2d88 <delete_users+0x14c>
									{
										func_error=INVALID_INPUT_ERROR;
										break;
									}
									xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2ce4:	6f ef       	ldi	r22, 0xFF	; 255
    2ce6:	7f ef       	ldi	r23, 0xFF	; 255
    2ce8:	80 91 2d 08 	lds	r24, 0x082D
    2cec:	90 91 2e 08 	lds	r25, 0x082E
    2cf0:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
									result=u8EXTERNAL_EEPROM_search_user_byID(id);
    2cf4:	89 81       	ldd	r24, Y+1	; 0x01
    2cf6:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <u8EXTERNAL_EEPROM_search_user_byID>
    2cfa:	08 2f       	mov	r16, r24
									xSemaphoreGive(i2c_mutex);
    2cfc:	20 e0       	ldi	r18, 0x00	; 0
    2cfe:	40 e0       	ldi	r20, 0x00	; 0
    2d00:	50 e0       	ldi	r21, 0x00	; 0
    2d02:	60 e0       	ldi	r22, 0x00	; 0
    2d04:	70 e0       	ldi	r23, 0x00	; 0
    2d06:	80 91 2d 08 	lds	r24, 0x082D
    2d0a:	90 91 2e 08 	lds	r25, 0x082E
    2d0e:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
									if(result ==USER_FOUND)
    2d12:	00 23       	and	r16, r16
    2d14:	09 f4       	brne	.+2      	; 0x2d18 <delete_users+0xdc>
    2d16:	b6 cf       	rjmp	.-148    	; 0x2c84 <delete_users+0x48>
    2d18:	37 c0       	rjmp	.+110    	; 0x2d88 <delete_users+0x14c>
									func_error=TIME_OUT_ERROR;
									break;
								}
								break;
			case DELETE_STATE :
								xSemaphoreTake(i2c_mutex,portMAX_DELAY);
    2d1a:	6f ef       	ldi	r22, 0xFF	; 255
    2d1c:	7f ef       	ldi	r23, 0xFF	; 255
    2d1e:	80 91 2d 08 	lds	r24, 0x082D
    2d22:	90 91 2e 08 	lds	r25, 0x082E
    2d26:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
								vEXTERNAL_EEPROM_delete_user(id);
    2d2a:	89 81       	ldd	r24, Y+1	; 0x01
    2d2c:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <vEXTERNAL_EEPROM_delete_user>
								xSemaphoreGive(i2c_mutex);
    2d30:	20 e0       	ldi	r18, 0x00	; 0
    2d32:	40 e0       	ldi	r20, 0x00	; 0
    2d34:	50 e0       	ldi	r21, 0x00	; 0
    2d36:	60 e0       	ldi	r22, 0x00	; 0
    2d38:	70 e0       	ldi	r23, 0x00	; 0
    2d3a:	80 91 2d 08 	lds	r24, 0x082D
    2d3e:	90 91 2e 08 	lds	r25, 0x082E
    2d42:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
								func_error=NO_ERROR;
								
								xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2d46:	6f ef       	ldi	r22, 0xFF	; 255
    2d48:	7f ef       	ldi	r23, 0xFF	; 255
    2d4a:	80 91 2f 08 	lds	r24, 0x082F
    2d4e:	90 91 30 08 	lds	r25, 0x0830
    2d52:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
								vUartTransmit(ENTER_KEY);
    2d56:	8d e0       	ldi	r24, 0x0D	; 13
    2d58:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								vUartTransmitString_program(PSTR("USER DELETED successfully .........."));
    2d5c:	82 eb       	ldi	r24, 0xB2	; 178
    2d5e:	99 e0       	ldi	r25, 0x09	; 9
    2d60:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
								vUartTransmit(ENTER_KEY);
    2d64:	8d e0       	ldi	r24, 0x0D	; 13
    2d66:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								vUartTransmit(ENTER_KEY);
    2d6a:	8d e0       	ldi	r24, 0x0D	; 13
    2d6c:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								xSemaphoreGive(uart_mutex);
    2d70:	20 e0       	ldi	r18, 0x00	; 0
    2d72:	40 e0       	ldi	r20, 0x00	; 0
    2d74:	50 e0       	ldi	r21, 0x00	; 0
    2d76:	60 e0       	ldi	r22, 0x00	; 0
    2d78:	70 e0       	ldi	r23, 0x00	; 0
    2d7a:	80 91 2f 08 	lds	r24, 0x082F
    2d7e:	90 91 30 08 	lds	r25, 0x0830
    2d82:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2d86:	18 c0       	rjmp	.+48     	; 0x2db8 <delete_users+0x17c>
		switch(func_error)
		{
			case NO_ERROR :break;
			case INVALID_INPUT_ERROR :
			case ROOT_USER_ERROR :
								vUartTransmit(ENTER_KEY);
    2d88:	8d e0       	ldi	r24, 0x0D	; 13
    2d8a:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								vUartTransmitString_program(PSTR("INVALID USER .........."));
    2d8e:	87 ed       	ldi	r24, 0xD7	; 215
    2d90:	99 e0       	ldi	r25, 0x09	; 9
    2d92:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
								vUartTransmit(ENTER_KEY);
    2d96:	8d e0       	ldi	r24, 0x0D	; 13
    2d98:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								vUartTransmit(ENTER_KEY);
    2d9c:	8d e0       	ldi	r24, 0x0D	; 13
    2d9e:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
								xSemaphoreGive(uart_mutex);
    2da2:	20 e0       	ldi	r18, 0x00	; 0
    2da4:	40 e0       	ldi	r20, 0x00	; 0
    2da6:	50 e0       	ldi	r21, 0x00	; 0
    2da8:	60 e0       	ldi	r22, 0x00	; 0
    2daa:	70 e0       	ldi	r23, 0x00	; 0
    2dac:	80 91 2f 08 	lds	r24, 0x082F
    2db0:	90 91 30 08 	lds	r25, 0x0830
    2db4:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
								//xSemaphoreGive(uart_mutex);
								return;
			default:break;
		}
	}
}
    2db8:	0f 90       	pop	r0
    2dba:	df 91       	pop	r29
    2dbc:	cf 91       	pop	r28
    2dbe:	1f 91       	pop	r17
    2dc0:	0f 91       	pop	r16
    2dc2:	08 95       	ret

00002dc4 <factory_reset>:
//------------------------------
void factory_reset(void)
{
	vSet_terminal_task_state(TERMINAL_TASK_FACTORY_STATE);
    2dc4:	80 e0       	ldi	r24, 0x00	; 0
    2dc6:	0e 94 85 11 	call	0x230a	; 0x230a <vSet_terminal_task_state>
	xSemaphoreTake(uart_mutex,portMAX_DELAY);
    2dca:	6f ef       	ldi	r22, 0xFF	; 255
    2dcc:	7f ef       	ldi	r23, 0xFF	; 255
    2dce:	80 91 2f 08 	lds	r24, 0x082F
    2dd2:	90 91 30 08 	lds	r25, 0x0830
    2dd6:	0e 94 ba 2c 	call	0x5974	; 0x5974 <xQueueSemaphoreTake>
	vUartTransmit(ENTER_KEY);
    2dda:	8d e0       	ldi	r24, 0x0D	; 13
    2ddc:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmitString_program(PSTR("RESET SYSTEM DONE ......"));
    2de0:	8f ee       	ldi	r24, 0xEF	; 239
    2de2:	99 e0       	ldi	r25, 0x09	; 9
    2de4:	0e 94 96 27 	call	0x4f2c	; 0x4f2c <vUartTransmitString_program>
	vUartTransmit(ENTER_KEY);
    2de8:	8d e0       	ldi	r24, 0x0D	; 13
    2dea:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	vUartTransmit(ENTER_KEY);
    2dee:	8d e0       	ldi	r24, 0x0D	; 13
    2df0:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
	xSemaphoreGive(uart_mutex);
    2df4:	20 e0       	ldi	r18, 0x00	; 0
    2df6:	40 e0       	ldi	r20, 0x00	; 0
    2df8:	50 e0       	ldi	r21, 0x00	; 0
    2dfa:	60 e0       	ldi	r22, 0x00	; 0
    2dfc:	70 e0       	ldi	r23, 0x00	; 0
    2dfe:	80 91 2f 08 	lds	r24, 0x082F
    2e02:	90 91 30 08 	lds	r25, 0x0830
    2e06:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>
    2e0a:	08 95       	ret

00002e0c <vEcu_Buzzer_init>:
 */
//-------------------------------------------------------------- 
#include "ecu_buzzer.h"
//---------------------------------------------------------------
void vEcu_Buzzer_init(ecu_buzzer_t * buzzer_param)
{
    2e0c:	cf 93       	push	r28
    2e0e:	df 93       	push	r29
    2e10:	00 d0       	rcall	.+0      	; 0x2e12 <vEcu_Buzzer_init+0x6>
    2e12:	00 d0       	rcall	.+0      	; 0x2e14 <vEcu_Buzzer_init+0x8>
    2e14:	cd b7       	in	r28, 0x3d	; 61
    2e16:	de b7       	in	r29, 0x3e	; 62
    2e18:	fc 01       	movw	r30, r24
		gpio_init_param_t temp;
		temp.direction=GPIO_OUTPUT;
    2e1a:	81 e0       	ldi	r24, 0x01	; 1
    2e1c:	8b 83       	std	Y+3, r24	; 0x03
		temp.output_init_value=buzzer_param->output;
    2e1e:	82 81       	ldd	r24, Z+2	; 0x02
    2e20:	8c 83       	std	Y+4, r24	; 0x04
		temp.pin=buzzer_param->pin;
    2e22:	81 81       	ldd	r24, Z+1	; 0x01
    2e24:	8a 83       	std	Y+2, r24	; 0x02
		temp.port=buzzer_param->port;
    2e26:	80 81       	ld	r24, Z
    2e28:	89 83       	std	Y+1, r24	; 0x01
		vGpio_Init(&temp);
    2e2a:	ce 01       	movw	r24, r28
    2e2c:	01 96       	adiw	r24, 0x01	; 1
    2e2e:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
}
    2e32:	0f 90       	pop	r0
    2e34:	0f 90       	pop	r0
    2e36:	0f 90       	pop	r0
    2e38:	0f 90       	pop	r0
    2e3a:	df 91       	pop	r29
    2e3c:	cf 91       	pop	r28
    2e3e:	08 95       	ret

00002e40 <vEcu_Buzzer_stop>:
		vGpio_Write(buzzer_param);
}
//---------------------------------------------------------------
void vEcu_Buzzer_stop(ecu_buzzer_t * buzzer_param)
{
	buzzer_param->output=STD_LOGIC_LOW;
    2e40:	fc 01       	movw	r30, r24
    2e42:	12 82       	std	Z+2, r1	; 0x02
	vGpio_Write(buzzer_param);
    2e44:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    2e48:	08 95       	ret

00002e4a <vEcu_Buzzer_toggle>:
}
//-------------------------------------------------------------
void vEcu_Buzzer_toggle(ecu_buzzer_t * buzzer_param)
{
    2e4a:	0f 93       	push	r16
    2e4c:	1f 93       	push	r17
    2e4e:	cf 93       	push	r28
    2e50:	df 93       	push	r29
    2e52:	00 d0       	rcall	.+0      	; 0x2e54 <vEcu_Buzzer_toggle+0xa>
    2e54:	cd b7       	in	r28, 0x3d	; 61
    2e56:	de b7       	in	r29, 0x3e	; 62
    2e58:	8c 01       	movw	r16, r24
	gpio_read_param_t temp;
	boolean val;
	temp.pin=buzzer_param->pin;
    2e5a:	fc 01       	movw	r30, r24
    2e5c:	81 81       	ldd	r24, Z+1	; 0x01
    2e5e:	8a 83       	std	Y+2, r24	; 0x02
	temp.port=buzzer_param->port;
    2e60:	80 81       	ld	r24, Z
    2e62:	89 83       	std	Y+1, r24	; 0x01
	val=Gpio_Read(&temp);
    2e64:	ce 01       	movw	r24, r28
    2e66:	01 96       	adiw	r24, 0x01	; 1
    2e68:	0e 94 58 23 	call	0x46b0	; 0x46b0 <Gpio_Read>
	buzzer_param->output= !(val);
    2e6c:	91 e0       	ldi	r25, 0x01	; 1
    2e6e:	81 11       	cpse	r24, r1
    2e70:	90 e0       	ldi	r25, 0x00	; 0
    2e72:	f8 01       	movw	r30, r16
    2e74:	92 83       	std	Z+2, r25	; 0x02
	vGpio_Write(buzzer_param);
    2e76:	c8 01       	movw	r24, r16
    2e78:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
}
    2e7c:	0f 90       	pop	r0
    2e7e:	0f 90       	pop	r0
    2e80:	df 91       	pop	r29
    2e82:	cf 91       	pop	r28
    2e84:	1f 91       	pop	r17
    2e86:	0f 91       	pop	r16
    2e88:	08 95       	ret

00002e8a <vEcu_KeypadInit>:
													  {'4','5','6','*'},
													  {'7','8','9','-'},
													  {'*','0','#','+'}};
//-----------------------------------------------------------------------
void vEcu_KeypadInit(ecu_keypad_init_param_t* param)
{
    2e8a:	cf 93       	push	r28
    2e8c:	df 93       	push	r29
    2e8e:	ec 01       	movw	r28, r24
	//make output =1 no output state
	param->row0->output_init_value=STD_LOGIC_HIGH;
    2e90:	e8 81       	ld	r30, Y
    2e92:	f9 81       	ldd	r31, Y+1	; 0x01
    2e94:	81 e0       	ldi	r24, 0x01	; 1
    2e96:	83 83       	std	Z+3, r24	; 0x03
	param->row1->output_init_value=STD_LOGIC_HIGH;
    2e98:	ea 81       	ldd	r30, Y+2	; 0x02
    2e9a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e9c:	83 83       	std	Z+3, r24	; 0x03
	param->row2->output_init_value=STD_LOGIC_HIGH;
    2e9e:	ec 81       	ldd	r30, Y+4	; 0x04
    2ea0:	fd 81       	ldd	r31, Y+5	; 0x05
    2ea2:	83 83       	std	Z+3, r24	; 0x03
	param->row2->output_init_value=STD_LOGIC_HIGH;
    2ea4:	ec 81       	ldd	r30, Y+4	; 0x04
    2ea6:	fd 81       	ldd	r31, Y+5	; 0x05
    2ea8:	83 83       	std	Z+3, r24	; 0x03
	//make input pullup
	vGpio_Init((param->row0));
    2eaa:	88 81       	ld	r24, Y
    2eac:	99 81       	ldd	r25, Y+1	; 0x01
    2eae:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init((param->row1));
    2eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb4:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb6:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init((param->row2));
    2eba:	8c 81       	ldd	r24, Y+4	; 0x04
    2ebc:	9d 81       	ldd	r25, Y+5	; 0x05
    2ebe:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init((param->row3));
    2ec2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ec4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ec6:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init((param->col0));
    2eca:	88 85       	ldd	r24, Y+8	; 0x08
    2ecc:	99 85       	ldd	r25, Y+9	; 0x09
    2ece:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init((param->col1));
    2ed2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ed4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ed6:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init((param->col2));
    2eda:	8c 85       	ldd	r24, Y+12	; 0x0c
    2edc:	9d 85       	ldd	r25, Y+13	; 0x0d
    2ede:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init((param->col3));
    2ee2:	8e 85       	ldd	r24, Y+14	; 0x0e
    2ee4:	9f 85       	ldd	r25, Y+15	; 0x0f
    2ee6:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	
}
    2eea:	df 91       	pop	r29
    2eec:	cf 91       	pop	r28
    2eee:	08 95       	ret

00002ef0 <ucEcu_KeypadScan>:
//----------------------------------------------------------------------
unsigned char ucEcu_KeypadScan(ecu_keypad_init_param_t* param)
{
    2ef0:	bf 92       	push	r11
    2ef2:	cf 92       	push	r12
    2ef4:	df 92       	push	r13
    2ef6:	ef 92       	push	r14
    2ef8:	ff 92       	push	r15
    2efa:	0f 93       	push	r16
    2efc:	1f 93       	push	r17
    2efe:	cf 93       	push	r28
    2f00:	df 93       	push	r29
    2f02:	00 d0       	rcall	.+0      	; 0x2f04 <ucEcu_KeypadScan+0x14>
    2f04:	00 d0       	rcall	.+0      	; 0x2f06 <ucEcu_KeypadScan+0x16>
    2f06:	1f 92       	push	r1
    2f08:	cd b7       	in	r28, 0x3d	; 61
    2f0a:	de b7       	in	r29, 0x3e	; 62
    2f0c:	8c 01       	movw	r16, r24
	unsigned char result = NO_VALID_INPUT;
	gpio_write_param_t temp;
	gpio_read_param_t temp2;
	u8 col_0,col_1,col_2,col_3;
	//loop on rows
	for (row=0;row<4;row++)
    2f0e:	f1 2c       	mov	r15, r1
	{
		//set rows output to no output state(1)
		//make output =1 no output state
		temp.port=param->row0->port;
		temp.pin=param->row0->pin;
		temp.output=STD_LOGIC_HIGH;
    2f10:	ee 24       	eor	r14, r14
    2f12:	e3 94       	inc	r14
	//loop on rows
	for (row=0;row<4;row++)
	{
		//set rows output to no output state(1)
		//make output =1 no output state
		temp.port=param->row0->port;
    2f14:	d8 01       	movw	r26, r16
    2f16:	ed 91       	ld	r30, X+
    2f18:	fc 91       	ld	r31, X
    2f1a:	80 81       	ld	r24, Z
    2f1c:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=param->row0->pin;
    2f1e:	81 81       	ldd	r24, Z+1	; 0x01
    2f20:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    2f22:	eb 82       	std	Y+3, r14	; 0x03
		vGpio_Write(&temp);
    2f24:	ce 01       	movw	r24, r28
    2f26:	01 96       	adiw	r24, 0x01	; 1
    2f28:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
		
		temp.port=param->row1->port;
    2f2c:	d8 01       	movw	r26, r16
    2f2e:	12 96       	adiw	r26, 0x02	; 2
    2f30:	ed 91       	ld	r30, X+
    2f32:	fc 91       	ld	r31, X
    2f34:	13 97       	sbiw	r26, 0x03	; 3
    2f36:	80 81       	ld	r24, Z
    2f38:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=param->row1->pin;
    2f3a:	81 81       	ldd	r24, Z+1	; 0x01
    2f3c:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    2f3e:	eb 82       	std	Y+3, r14	; 0x03
		vGpio_Write(&temp);
    2f40:	ce 01       	movw	r24, r28
    2f42:	01 96       	adiw	r24, 0x01	; 1
    2f44:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
		
		temp.port=param->row2->port;
    2f48:	d8 01       	movw	r26, r16
    2f4a:	14 96       	adiw	r26, 0x04	; 4
    2f4c:	ed 91       	ld	r30, X+
    2f4e:	fc 91       	ld	r31, X
    2f50:	15 97       	sbiw	r26, 0x05	; 5
    2f52:	80 81       	ld	r24, Z
    2f54:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=param->row2->pin;
    2f56:	81 81       	ldd	r24, Z+1	; 0x01
    2f58:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    2f5a:	eb 82       	std	Y+3, r14	; 0x03
		vGpio_Write(&temp);
    2f5c:	ce 01       	movw	r24, r28
    2f5e:	01 96       	adiw	r24, 0x01	; 1
    2f60:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
				
		temp.port=param->row3->port;
    2f64:	d8 01       	movw	r26, r16
    2f66:	16 96       	adiw	r26, 0x06	; 6
    2f68:	ed 91       	ld	r30, X+
    2f6a:	fc 91       	ld	r31, X
    2f6c:	17 97       	sbiw	r26, 0x07	; 7
    2f6e:	80 81       	ld	r24, Z
    2f70:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=param->row3->pin;
    2f72:	81 81       	ldd	r24, Z+1	; 0x01
    2f74:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    2f76:	eb 82       	std	Y+3, r14	; 0x03
		vGpio_Write(&temp);
    2f78:	ce 01       	movw	r24, r28
    2f7a:	01 96       	adiw	r24, 0x01	; 1
    2f7c:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
		
		//set certain row to output state (0)
		switch(row)
    2f80:	b1 e0       	ldi	r27, 0x01	; 1
    2f82:	fb 16       	cp	r15, r27
    2f84:	b1 f0       	breq	.+44     	; 0x2fb2 <ucEcu_KeypadScan+0xc2>
    2f86:	fb 16       	cp	r15, r27
    2f88:	38 f0       	brcs	.+14     	; 0x2f98 <ucEcu_KeypadScan+0xa8>
    2f8a:	82 e0       	ldi	r24, 0x02	; 2
    2f8c:	f8 16       	cp	r15, r24
    2f8e:	01 f1       	breq	.+64     	; 0x2fd0 <ucEcu_KeypadScan+0xe0>
    2f90:	a3 e0       	ldi	r26, 0x03	; 3
    2f92:	fa 12       	cpse	r15, r26
    2f94:	3a c0       	rjmp	.+116    	; 0x300a <ucEcu_KeypadScan+0x11a>
    2f96:	2b c0       	rjmp	.+86     	; 0x2fee <ucEcu_KeypadScan+0xfe>
		{
			case 0:
							temp.port=param->row0->port;
    2f98:	d8 01       	movw	r26, r16
    2f9a:	ed 91       	ld	r30, X+
    2f9c:	fc 91       	ld	r31, X
    2f9e:	80 81       	ld	r24, Z
    2fa0:	89 83       	std	Y+1, r24	; 0x01
							temp.pin=param->row0->pin;
    2fa2:	81 81       	ldd	r24, Z+1	; 0x01
    2fa4:	8a 83       	std	Y+2, r24	; 0x02
							temp.output=STD_LOGIC_LOW;
    2fa6:	1b 82       	std	Y+3, r1	; 0x03
							vGpio_Write(&temp);
    2fa8:	ce 01       	movw	r24, r28
    2faa:	01 96       	adiw	r24, 0x01	; 1
    2fac:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
							break;
    2fb0:	2c c0       	rjmp	.+88     	; 0x300a <ucEcu_KeypadScan+0x11a>
			case 1:
							temp.port=param->row1->port;
    2fb2:	d8 01       	movw	r26, r16
    2fb4:	12 96       	adiw	r26, 0x02	; 2
    2fb6:	ed 91       	ld	r30, X+
    2fb8:	fc 91       	ld	r31, X
    2fba:	13 97       	sbiw	r26, 0x03	; 3
    2fbc:	80 81       	ld	r24, Z
    2fbe:	89 83       	std	Y+1, r24	; 0x01
							temp.pin=param->row1->pin;
    2fc0:	81 81       	ldd	r24, Z+1	; 0x01
    2fc2:	8a 83       	std	Y+2, r24	; 0x02
							temp.output=STD_LOGIC_LOW;
    2fc4:	1b 82       	std	Y+3, r1	; 0x03
							vGpio_Write(&temp);
    2fc6:	ce 01       	movw	r24, r28
    2fc8:	01 96       	adiw	r24, 0x01	; 1
    2fca:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
							break;
    2fce:	1d c0       	rjmp	.+58     	; 0x300a <ucEcu_KeypadScan+0x11a>
			case 2:
							temp.port=param->row2->port;
    2fd0:	d8 01       	movw	r26, r16
    2fd2:	14 96       	adiw	r26, 0x04	; 4
    2fd4:	ed 91       	ld	r30, X+
    2fd6:	fc 91       	ld	r31, X
    2fd8:	15 97       	sbiw	r26, 0x05	; 5
    2fda:	80 81       	ld	r24, Z
    2fdc:	89 83       	std	Y+1, r24	; 0x01
							temp.pin=param->row2->pin;
    2fde:	81 81       	ldd	r24, Z+1	; 0x01
    2fe0:	8a 83       	std	Y+2, r24	; 0x02
							temp.output=STD_LOGIC_LOW;
    2fe2:	1b 82       	std	Y+3, r1	; 0x03
							vGpio_Write(&temp);
    2fe4:	ce 01       	movw	r24, r28
    2fe6:	01 96       	adiw	r24, 0x01	; 1
    2fe8:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
							break;
    2fec:	0e c0       	rjmp	.+28     	; 0x300a <ucEcu_KeypadScan+0x11a>
			case 3:
							temp.port=param->row3->port;
    2fee:	d8 01       	movw	r26, r16
    2ff0:	16 96       	adiw	r26, 0x06	; 6
    2ff2:	ed 91       	ld	r30, X+
    2ff4:	fc 91       	ld	r31, X
    2ff6:	17 97       	sbiw	r26, 0x07	; 7
    2ff8:	80 81       	ld	r24, Z
    2ffa:	89 83       	std	Y+1, r24	; 0x01
							temp.pin=param->row3->pin;
    2ffc:	81 81       	ldd	r24, Z+1	; 0x01
    2ffe:	8a 83       	std	Y+2, r24	; 0x02
							temp.output=STD_LOGIC_LOW;
    3000:	1b 82       	std	Y+3, r1	; 0x03
							vGpio_Write(&temp);
    3002:	ce 01       	movw	r24, r28
    3004:	01 96       	adiw	r24, 0x01	; 1
    3006:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
							break;
			default:break;
		}
		//check on lines
		temp2.port=param->col0->port;
    300a:	d8 01       	movw	r26, r16
    300c:	18 96       	adiw	r26, 0x08	; 8
    300e:	ed 91       	ld	r30, X+
    3010:	fc 91       	ld	r31, X
    3012:	19 97       	sbiw	r26, 0x09	; 9
    3014:	80 81       	ld	r24, Z
    3016:	8c 83       	std	Y+4, r24	; 0x04
		temp2.pin=param->col0->pin;
    3018:	81 81       	ldd	r24, Z+1	; 0x01
    301a:	8d 83       	std	Y+5, r24	; 0x05
		col_0=Gpio_Read(&temp2);
    301c:	ce 01       	movw	r24, r28
    301e:	04 96       	adiw	r24, 0x04	; 4
    3020:	0e 94 58 23 	call	0x46b0	; 0x46b0 <Gpio_Read>
    3024:	d8 2e       	mov	r13, r24
		
		temp2.port=param->col1->port;
    3026:	d8 01       	movw	r26, r16
    3028:	1a 96       	adiw	r26, 0x0a	; 10
    302a:	ed 91       	ld	r30, X+
    302c:	fc 91       	ld	r31, X
    302e:	1b 97       	sbiw	r26, 0x0b	; 11
    3030:	80 81       	ld	r24, Z
    3032:	8c 83       	std	Y+4, r24	; 0x04
		temp2.pin=param->col1->pin;
    3034:	81 81       	ldd	r24, Z+1	; 0x01
    3036:	8d 83       	std	Y+5, r24	; 0x05
		col_1=Gpio_Read(&temp2);
    3038:	ce 01       	movw	r24, r28
    303a:	04 96       	adiw	r24, 0x04	; 4
    303c:	0e 94 58 23 	call	0x46b0	; 0x46b0 <Gpio_Read>
    3040:	c8 2e       	mov	r12, r24
				
		temp2.port=param->col2->port;
    3042:	d8 01       	movw	r26, r16
    3044:	1c 96       	adiw	r26, 0x0c	; 12
    3046:	ed 91       	ld	r30, X+
    3048:	fc 91       	ld	r31, X
    304a:	1d 97       	sbiw	r26, 0x0d	; 13
    304c:	90 81       	ld	r25, Z
    304e:	9c 83       	std	Y+4, r25	; 0x04
		temp2.pin=param->col2->pin;
    3050:	91 81       	ldd	r25, Z+1	; 0x01
    3052:	9d 83       	std	Y+5, r25	; 0x05
		col_2=Gpio_Read(&temp2);
    3054:	ce 01       	movw	r24, r28
    3056:	04 96       	adiw	r24, 0x04	; 4
    3058:	0e 94 58 23 	call	0x46b0	; 0x46b0 <Gpio_Read>
    305c:	b8 2e       	mov	r11, r24
						
		temp2.port=param->col3->port;
    305e:	d8 01       	movw	r26, r16
    3060:	1e 96       	adiw	r26, 0x0e	; 14
    3062:	ed 91       	ld	r30, X+
    3064:	fc 91       	ld	r31, X
    3066:	1f 97       	sbiw	r26, 0x0f	; 15
    3068:	90 81       	ld	r25, Z
    306a:	9c 83       	std	Y+4, r25	; 0x04
		temp2.pin=param->col3->pin;
    306c:	91 81       	ldd	r25, Z+1	; 0x01
    306e:	9d 83       	std	Y+5, r25	; 0x05
		col_3=Gpio_Read(&temp2);
    3070:	ce 01       	movw	r24, r28
    3072:	04 96       	adiw	r24, 0x04	; 4
    3074:	0e 94 58 23 	call	0x46b0	; 0x46b0 <Gpio_Read>
		
		if (col_0==IS_VALID){line=0;}
    3078:	dd 20       	and	r13, r13
    307a:	61 f0       	breq	.+24     	; 0x3094 <ucEcu_KeypadScan+0x1a4>
		else if (col_1==IS_VALID){line=1;}
    307c:	cc 20       	and	r12, r12
    307e:	61 f0       	breq	.+24     	; 0x3098 <ucEcu_KeypadScan+0x1a8>
		else if (col_2==IS_VALID){line=2;}
    3080:	bb 20       	and	r11, r11
    3082:	61 f0       	breq	.+24     	; 0x309c <ucEcu_KeypadScan+0x1ac>
		else if (col_3==IS_VALID){line=3;}
    3084:	88 23       	and	r24, r24
    3086:	61 f0       	breq	.+24     	; 0x30a0 <ucEcu_KeypadScan+0x1b0>
	unsigned char result = NO_VALID_INPUT;
	gpio_write_param_t temp;
	gpio_read_param_t temp2;
	u8 col_0,col_1,col_2,col_3;
	//loop on rows
	for (row=0;row<4;row++)
    3088:	f3 94       	inc	r15
    308a:	b4 e0       	ldi	r27, 0x04	; 4
    308c:	fb 12       	cpse	r15, r27
    308e:	42 cf       	rjmp	.-380    	; 0x2f14 <ucEcu_KeypadScan+0x24>
unsigned char ucEcu_KeypadScan(ecu_keypad_init_param_t* param)
{
	//pseudo code
	uint8_t row=0;
	uint8_t line = NO_VALID_INPUT;
	unsigned char result = NO_VALID_INPUT;
    3090:	8f ef       	ldi	r24, 0xFF	; 255
    3092:	10 c0       	rjmp	.+32     	; 0x30b4 <ucEcu_KeypadScan+0x1c4>
						
		temp2.port=param->col3->port;
		temp2.pin=param->col3->pin;
		col_3=Gpio_Read(&temp2);
		
		if (col_0==IS_VALID){line=0;}
    3094:	e0 e0       	ldi	r30, 0x00	; 0
    3096:	05 c0       	rjmp	.+10     	; 0x30a2 <ucEcu_KeypadScan+0x1b2>
		else if (col_1==IS_VALID){line=1;}
    3098:	e1 e0       	ldi	r30, 0x01	; 1
    309a:	03 c0       	rjmp	.+6      	; 0x30a2 <ucEcu_KeypadScan+0x1b2>
		else if (col_2==IS_VALID){line=2;}
    309c:	e2 e0       	ldi	r30, 0x02	; 2
    309e:	01 c0       	rjmp	.+2      	; 0x30a2 <ucEcu_KeypadScan+0x1b2>
		else if (col_3==IS_VALID){line=3;}
    30a0:	e3 e0       	ldi	r30, 0x03	; 3
		else {/* MISRA */}
		//check for input validity
		if (line != NO_VALID_INPUT)
		{	
			//save the mapped key[row][line]
			result = s_keypad_mapping[row][line];
    30a2:	f0 e0       	ldi	r31, 0x00	; 0
    30a4:	84 e0       	ldi	r24, 0x04	; 4
    30a6:	f8 9e       	mul	r15, r24
    30a8:	e0 0d       	add	r30, r0
    30aa:	f1 1d       	adc	r31, r1
    30ac:	11 24       	eor	r1, r1
    30ae:	eb 5f       	subi	r30, 0xFB	; 251
    30b0:	fe 4f       	sbci	r31, 0xFE	; 254
    30b2:	80 81       	ld	r24, Z
		}
		
	}
	//return the mapped key
	return result;
}
    30b4:	0f 90       	pop	r0
    30b6:	0f 90       	pop	r0
    30b8:	0f 90       	pop	r0
    30ba:	0f 90       	pop	r0
    30bc:	0f 90       	pop	r0
    30be:	df 91       	pop	r29
    30c0:	cf 91       	pop	r28
    30c2:	1f 91       	pop	r17
    30c4:	0f 91       	pop	r16
    30c6:	ff 90       	pop	r15
    30c8:	ef 90       	pop	r14
    30ca:	df 90       	pop	r13
    30cc:	cf 90       	pop	r12
    30ce:	bf 90       	pop	r11
    30d0:	08 95       	ret

000030d2 <ucEcu_KeypadScanState>:
//-----------------------------------------------------------------------
keypad_switch_state_t ucEcu_KeypadScanState(ecu_keypad_init_param_t* param,unsigned char* button)
{
    30d2:	cf 93       	push	r28
    30d4:	df 93       	push	r29
    30d6:	9c 01       	movw	r18, r24
    30d8:	eb 01       	movw	r28, r22
		 static keypad_switch_state_t last_state=KP_SWITCH_RELEASED_STATE;
		 static unsigned char buttonval=NO_VALID_INPUT;
		 unsigned char value_read=NO_VALID_INPUT;
		 
		 switch(last_state)
    30da:	80 91 de 01 	lds	r24, 0x01DE
    30de:	81 30       	cpi	r24, 0x01	; 1
    30e0:	99 f0       	breq	.+38     	; 0x3108 <ucEcu_KeypadScanState+0x36>
    30e2:	28 f0       	brcs	.+10     	; 0x30ee <ucEcu_KeypadScanState+0x1c>
    30e4:	82 30       	cpi	r24, 0x02	; 2
    30e6:	e9 f0       	breq	.+58     	; 0x3122 <ucEcu_KeypadScanState+0x50>
    30e8:	83 30       	cpi	r24, 0x03	; 3
    30ea:	a9 f5       	brne	.+106    	; 0x3156 <ucEcu_KeypadScanState+0x84>
    30ec:	27 c0       	rjmp	.+78     	; 0x313c <ucEcu_KeypadScanState+0x6a>
		 {
			 case KP_SWITCH_RELEASED_STATE :
			 value_read=ucEcu_KeypadScan(param);
    30ee:	c9 01       	movw	r24, r18
    30f0:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <ucEcu_KeypadScan>
    30f4:	98 2f       	mov	r25, r24
			 if(value_read ==(NO_VALID_INPUT))
    30f6:	8f 3f       	cpi	r24, 0xFF	; 255
    30f8:	19 f4       	brne	.+6      	; 0x3100 <ucEcu_KeypadScanState+0x2e>
			 {
				 last_state=KP_SWITCH_RELEASED_STATE;
    30fa:	10 92 de 01 	sts	0x01DE, r1
    30fe:	3b c0       	rjmp	.+118    	; 0x3176 <ucEcu_KeypadScanState+0xa4>
			 }
			 else
			 {
				 last_state=KP_SWITCH_PRE_PRESSED_STATE;
    3100:	81 e0       	ldi	r24, 0x01	; 1
    3102:	80 93 de 01 	sts	0x01DE, r24
    3106:	34 c0       	rjmp	.+104    	; 0x3170 <ucEcu_KeypadScanState+0x9e>
			 }
			 break;
			 case KP_SWITCH_PRE_PRESSED_STATE:
			 value_read=ucEcu_KeypadScan(param);
    3108:	c9 01       	movw	r24, r18
    310a:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <ucEcu_KeypadScan>
			 if(value_read ==(NO_VALID_INPUT))
    310e:	8f 3f       	cpi	r24, 0xFF	; 255
    3110:	21 f4       	brne	.+8      	; 0x311a <ucEcu_KeypadScanState+0x48>
			 {
				 last_state=KP_SWITCH_PRE_RELEASED_STATE;
    3112:	83 e0       	ldi	r24, 0x03	; 3
    3114:	80 93 de 01 	sts	0x01DE, r24
    3118:	2e c0       	rjmp	.+92     	; 0x3176 <ucEcu_KeypadScanState+0xa4>
			 }
			 else
			 {
				 last_state=KP_SWITCH_PRESSED_STATE;
    311a:	82 e0       	ldi	r24, 0x02	; 2
    311c:	80 93 de 01 	sts	0x01DE, r24
    3120:	2a c0       	rjmp	.+84     	; 0x3176 <ucEcu_KeypadScanState+0xa4>
			 }
			 break;
			 case KP_SWITCH_PRESSED_STATE:
			 value_read=ucEcu_KeypadScan(param);
    3122:	c9 01       	movw	r24, r18
    3124:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <ucEcu_KeypadScan>
			 if(value_read ==(NO_VALID_INPUT))
    3128:	8f 3f       	cpi	r24, 0xFF	; 255
    312a:	21 f4       	brne	.+8      	; 0x3134 <ucEcu_KeypadScanState+0x62>
			 {
				 last_state=KP_SWITCH_PRE_RELEASED_STATE;
    312c:	83 e0       	ldi	r24, 0x03	; 3
    312e:	80 93 de 01 	sts	0x01DE, r24
    3132:	21 c0       	rjmp	.+66     	; 0x3176 <ucEcu_KeypadScanState+0xa4>
			 }
			 else
			 {
				 last_state=KP_SWITCH_PRESSED_STATE;
    3134:	82 e0       	ldi	r24, 0x02	; 2
    3136:	80 93 de 01 	sts	0x01DE, r24
    313a:	1d c0       	rjmp	.+58     	; 0x3176 <ucEcu_KeypadScanState+0xa4>
			 }
			 break;
			 case KP_SWITCH_PRE_RELEASED_STATE:
			 value_read=ucEcu_KeypadScan(param);
    313c:	c9 01       	movw	r24, r18
    313e:	0e 94 78 17 	call	0x2ef0	; 0x2ef0 <ucEcu_KeypadScan>
    3142:	98 2f       	mov	r25, r24
			 if(value_read ==(NO_VALID_INPUT))
    3144:	8f 3f       	cpi	r24, 0xFF	; 255
    3146:	19 f4       	brne	.+6      	; 0x314e <ucEcu_KeypadScanState+0x7c>
			 {
				 last_state=KP_SWITCH_RELEASED_STATE;
    3148:	10 92 de 01 	sts	0x01DE, r1
    314c:	14 c0       	rjmp	.+40     	; 0x3176 <ucEcu_KeypadScanState+0xa4>
			 }
			 else
			 {
				 last_state=KP_SWITCH_PRE_PRESSED_STATE;
    314e:	81 e0       	ldi	r24, 0x01	; 1
    3150:	80 93 de 01 	sts	0x01DE, r24
    3154:	0d c0       	rjmp	.+26     	; 0x3170 <ucEcu_KeypadScanState+0x9e>
			 }
			 break;
			 default:break;
		 }
		 //for pre pressed value be the same pre released value
		 if(last_state==KP_SWITCH_PRE_PRESSED_STATE)
    3156:	81 30       	cpi	r24, 0x01	; 1
    3158:	29 f4       	brne	.+10     	; 0x3164 <ucEcu_KeypadScanState+0x92>
//-----------------------------------------------------------------------
keypad_switch_state_t ucEcu_KeypadScanState(ecu_keypad_init_param_t* param,unsigned char* button)
{
		 static keypad_switch_state_t last_state=KP_SWITCH_RELEASED_STATE;
		 static unsigned char buttonval=NO_VALID_INPUT;
		 unsigned char value_read=NO_VALID_INPUT;
    315a:	9f ef       	ldi	r25, 0xFF	; 255
			 default:break;
		 }
		 //for pre pressed value be the same pre released value
		 if(last_state==KP_SWITCH_PRE_PRESSED_STATE)
		 {
			 buttonval=value_read;
    315c:	90 93 7c 00 	sts	0x007C, r25
			 *button=buttonval;
    3160:	98 83       	st	Y, r25
    3162:	0c c0       	rjmp	.+24     	; 0x317c <ucEcu_KeypadScanState+0xaa>
		 }
		 if(last_state==KP_SWITCH_PRE_RELEASED_STATE)
    3164:	83 30       	cpi	r24, 0x03	; 3
    3166:	51 f4       	brne	.+20     	; 0x317c <ucEcu_KeypadScanState+0xaa>
		 {
			 
			 *button=buttonval;
    3168:	90 91 7c 00 	lds	r25, 0x007C
    316c:	98 83       	st	Y, r25
    316e:	06 c0       	rjmp	.+12     	; 0x317c <ucEcu_KeypadScanState+0xaa>
			 }
			 break;
			 default:break;
		 }
		 //for pre pressed value be the same pre released value
		 if(last_state==KP_SWITCH_PRE_PRESSED_STATE)
    3170:	80 91 de 01 	lds	r24, 0x01DE
    3174:	f3 cf       	rjmp	.-26     	; 0x315c <ucEcu_KeypadScanState+0x8a>
    3176:	80 91 de 01 	lds	r24, 0x01DE
    317a:	f4 cf       	rjmp	.-24     	; 0x3164 <ucEcu_KeypadScanState+0x92>
			 
			 *button=buttonval;
		 }
		 
		 return last_state;
}
    317c:	df 91       	pop	r29
    317e:	cf 91       	pop	r28
    3180:	08 95       	ret

00003182 <SvLatch_data>:
	//latch data
	SvLatch_data();
}
//----------------------------------------------------------
static void SvLatch_data( void )
{
    3182:	cf 93       	push	r28
    3184:	df 93       	push	r29
    3186:	00 d0       	rcall	.+0      	; 0x3188 <SvLatch_data+0x6>
    3188:	1f 92       	push	r1
    318a:	cd b7       	in	r28, 0x3d	; 61
    318c:	de b7       	in	r29, 0x3e	; 62
	//make E HIGH
	gpio_write_param_t temp;
	temp.port=g_param->e->port;
    318e:	e0 91 df 01 	lds	r30, 0x01DF
    3192:	f0 91 e0 01 	lds	r31, 0x01E0
    3196:	02 84       	ldd	r0, Z+10	; 0x0a
    3198:	f3 85       	ldd	r31, Z+11	; 0x0b
    319a:	e0 2d       	mov	r30, r0
    319c:	80 81       	ld	r24, Z
    319e:	89 83       	std	Y+1, r24	; 0x01
	temp.pin=g_param->e->pin;
    31a0:	81 81       	ldd	r24, Z+1	; 0x01
    31a2:	8a 83       	std	Y+2, r24	; 0x02
	temp.output=STD_LOGIC_HIGH;
    31a4:	81 e0       	ldi	r24, 0x01	; 1
    31a6:	8b 83       	std	Y+3, r24	; 0x03
	vGpio_Write(&temp);
    31a8:	ce 01       	movw	r24, r28
    31aa:	01 96       	adiw	r24, 0x01	; 1
    31ac:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    31b0:	8a e6       	ldi	r24, 0x6A	; 106
    31b2:	8a 95       	dec	r24
    31b4:	f1 f7       	brne	.-4      	; 0x31b2 <SvLatch_data+0x30>
    31b6:	00 c0       	rjmp	.+0      	; 0x31b8 <SvLatch_data+0x36>
	
	//delay
	_delay_us(20);
	
	//make E LOw
	temp.port=g_param->e->port;
    31b8:	e0 91 df 01 	lds	r30, 0x01DF
    31bc:	f0 91 e0 01 	lds	r31, 0x01E0
    31c0:	02 84       	ldd	r0, Z+10	; 0x0a
    31c2:	f3 85       	ldd	r31, Z+11	; 0x0b
    31c4:	e0 2d       	mov	r30, r0
    31c6:	80 81       	ld	r24, Z
    31c8:	89 83       	std	Y+1, r24	; 0x01
	temp.pin=g_param->e->pin;
    31ca:	81 81       	ldd	r24, Z+1	; 0x01
    31cc:	8a 83       	std	Y+2, r24	; 0x02
	temp.output=STD_LOGIC_LOW;
    31ce:	1b 82       	std	Y+3, r1	; 0x03
	vGpio_Write(&temp);
    31d0:	ce 01       	movw	r24, r28
    31d2:	01 96       	adiw	r24, 0x01	; 1
    31d4:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    31d8:	8a e6       	ldi	r24, 0x6A	; 106
    31da:	8a 95       	dec	r24
    31dc:	f1 f7       	brne	.-4      	; 0x31da <SvLatch_data+0x58>
    31de:	00 c0       	rjmp	.+0      	; 0x31e0 <SvLatch_data+0x5e>
	_delay_us(20);
}
    31e0:	0f 90       	pop	r0
    31e2:	0f 90       	pop	r0
    31e4:	0f 90       	pop	r0
    31e6:	df 91       	pop	r29
    31e8:	cf 91       	pop	r28
    31ea:	08 95       	ret

000031ec <SvLcdSend>:
	return LCD_NO_ERROR;
}
//----------------------------------------------------------------------
//--------------------------------------------------------------
static void SvLcdSend(u8 type,u8 data)
{
    31ec:	1f 93       	push	r17
    31ee:	cf 93       	push	r28
    31f0:	df 93       	push	r29
    31f2:	00 d0       	rcall	.+0      	; 0x31f4 <SvLcdSend+0x8>
    31f4:	1f 92       	push	r1
    31f6:	cd b7       	in	r28, 0x3d	; 61
    31f8:	de b7       	in	r29, 0x3e	; 62
    31fa:	16 2f       	mov	r17, r22
		gpio_write_param_t temp;
	//make RS =0 as cmd and = 1 as data
	if(type==CMD)
    31fc:	81 11       	cpse	r24, r1
    31fe:	11 c0       	rjmp	.+34     	; 0x3222 <SvLcdSend+0x36>
	{
		//clear rs
		temp.port=g_param->rs->port;
    3200:	e0 91 df 01 	lds	r30, 0x01DF
    3204:	f0 91 e0 01 	lds	r31, 0x01E0
    3208:	00 84       	ldd	r0, Z+8	; 0x08
    320a:	f1 85       	ldd	r31, Z+9	; 0x09
    320c:	e0 2d       	mov	r30, r0
    320e:	80 81       	ld	r24, Z
    3210:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->rs->pin;
    3212:	81 81       	ldd	r24, Z+1	; 0x01
    3214:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    3216:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    3218:	ce 01       	movw	r24, r28
    321a:	01 96       	adiw	r24, 0x01	; 1
    321c:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    3220:	11 c0       	rjmp	.+34     	; 0x3244 <SvLcdSend+0x58>
	}
	else
	{
		//set rs
		temp.port=g_param->rs->port;
    3222:	e0 91 df 01 	lds	r30, 0x01DF
    3226:	f0 91 e0 01 	lds	r31, 0x01E0
    322a:	00 84       	ldd	r0, Z+8	; 0x08
    322c:	f1 85       	ldd	r31, Z+9	; 0x09
    322e:	e0 2d       	mov	r30, r0
    3230:	80 81       	ld	r24, Z
    3232:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->rs->pin;
    3234:	81 81       	ldd	r24, Z+1	; 0x01
    3236:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    3238:	81 e0       	ldi	r24, 0x01	; 1
    323a:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    323c:	ce 01       	movw	r24, r28
    323e:	01 96       	adiw	r24, 0x01	; 1
    3240:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	
	//high nibble data send
	
	if(check_bit(data,4))
    3244:	14 ff       	sbrs	r17, 4
    3246:	14 c0       	rjmp	.+40     	; 0x3270 <SvLcdSend+0x84>
	{
		temp.port=g_param->d4->port;
    3248:	e0 91 df 01 	lds	r30, 0x01DF
    324c:	f0 91 e0 01 	lds	r31, 0x01E0
    3250:	a0 81       	ld	r26, Z
    3252:	b1 81       	ldd	r27, Z+1	; 0x01
    3254:	8c 91       	ld	r24, X
    3256:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d4->pin;
    3258:	01 90       	ld	r0, Z+
    325a:	f0 81       	ld	r31, Z
    325c:	e0 2d       	mov	r30, r0
    325e:	81 81       	ldd	r24, Z+1	; 0x01
    3260:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    3262:	81 e0       	ldi	r24, 0x01	; 1
    3264:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    3266:	ce 01       	movw	r24, r28
    3268:	01 96       	adiw	r24, 0x01	; 1
    326a:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    326e:	12 c0       	rjmp	.+36     	; 0x3294 <SvLcdSend+0xa8>
	}
	else
	{
		temp.port=g_param->d4->port;
    3270:	e0 91 df 01 	lds	r30, 0x01DF
    3274:	f0 91 e0 01 	lds	r31, 0x01E0
    3278:	a0 81       	ld	r26, Z
    327a:	b1 81       	ldd	r27, Z+1	; 0x01
    327c:	8c 91       	ld	r24, X
    327e:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d4->pin;
    3280:	01 90       	ld	r0, Z+
    3282:	f0 81       	ld	r31, Z
    3284:	e0 2d       	mov	r30, r0
    3286:	81 81       	ldd	r24, Z+1	; 0x01
    3288:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    328a:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    328c:	ce 01       	movw	r24, r28
    328e:	01 96       	adiw	r24, 0x01	; 1
    3290:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	if(check_bit(data,5))
    3294:	15 ff       	sbrs	r17, 5
    3296:	12 c0       	rjmp	.+36     	; 0x32bc <SvLcdSend+0xd0>
	{
		temp.port=g_param->d5->port;
    3298:	e0 91 df 01 	lds	r30, 0x01DF
    329c:	f0 91 e0 01 	lds	r31, 0x01E0
    32a0:	02 80       	ldd	r0, Z+2	; 0x02
    32a2:	f3 81       	ldd	r31, Z+3	; 0x03
    32a4:	e0 2d       	mov	r30, r0
    32a6:	80 81       	ld	r24, Z
    32a8:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d5->pin;
    32aa:	81 81       	ldd	r24, Z+1	; 0x01
    32ac:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    32ae:	81 e0       	ldi	r24, 0x01	; 1
    32b0:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    32b2:	ce 01       	movw	r24, r28
    32b4:	01 96       	adiw	r24, 0x01	; 1
    32b6:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    32ba:	10 c0       	rjmp	.+32     	; 0x32dc <SvLcdSend+0xf0>
	}
	else
	{
		temp.port=g_param->d5->port;
    32bc:	e0 91 df 01 	lds	r30, 0x01DF
    32c0:	f0 91 e0 01 	lds	r31, 0x01E0
    32c4:	02 80       	ldd	r0, Z+2	; 0x02
    32c6:	f3 81       	ldd	r31, Z+3	; 0x03
    32c8:	e0 2d       	mov	r30, r0
    32ca:	80 81       	ld	r24, Z
    32cc:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d5->pin;
    32ce:	81 81       	ldd	r24, Z+1	; 0x01
    32d0:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    32d2:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    32d4:	ce 01       	movw	r24, r28
    32d6:	01 96       	adiw	r24, 0x01	; 1
    32d8:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	if(check_bit(data,6))
    32dc:	16 ff       	sbrs	r17, 6
    32de:	12 c0       	rjmp	.+36     	; 0x3304 <SvLcdSend+0x118>
	{
		temp.port=g_param->d6->port;
    32e0:	e0 91 df 01 	lds	r30, 0x01DF
    32e4:	f0 91 e0 01 	lds	r31, 0x01E0
    32e8:	04 80       	ldd	r0, Z+4	; 0x04
    32ea:	f5 81       	ldd	r31, Z+5	; 0x05
    32ec:	e0 2d       	mov	r30, r0
    32ee:	80 81       	ld	r24, Z
    32f0:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d6->pin;
    32f2:	81 81       	ldd	r24, Z+1	; 0x01
    32f4:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    32f6:	81 e0       	ldi	r24, 0x01	; 1
    32f8:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    32fa:	ce 01       	movw	r24, r28
    32fc:	01 96       	adiw	r24, 0x01	; 1
    32fe:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    3302:	10 c0       	rjmp	.+32     	; 0x3324 <SvLcdSend+0x138>
	}
	else
	{
		temp.port=g_param->d6->port;
    3304:	e0 91 df 01 	lds	r30, 0x01DF
    3308:	f0 91 e0 01 	lds	r31, 0x01E0
    330c:	04 80       	ldd	r0, Z+4	; 0x04
    330e:	f5 81       	ldd	r31, Z+5	; 0x05
    3310:	e0 2d       	mov	r30, r0
    3312:	80 81       	ld	r24, Z
    3314:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d6->pin;
    3316:	81 81       	ldd	r24, Z+1	; 0x01
    3318:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    331a:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    331c:	ce 01       	movw	r24, r28
    331e:	01 96       	adiw	r24, 0x01	; 1
    3320:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	if(check_bit(data,7))
    3324:	11 23       	and	r17, r17
    3326:	94 f4       	brge	.+36     	; 0x334c <SvLcdSend+0x160>
	{
		temp.port=g_param->d7->port;
    3328:	e0 91 df 01 	lds	r30, 0x01DF
    332c:	f0 91 e0 01 	lds	r31, 0x01E0
    3330:	06 80       	ldd	r0, Z+6	; 0x06
    3332:	f7 81       	ldd	r31, Z+7	; 0x07
    3334:	e0 2d       	mov	r30, r0
    3336:	80 81       	ld	r24, Z
    3338:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d7->pin;
    333a:	81 81       	ldd	r24, Z+1	; 0x01
    333c:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    333e:	81 e0       	ldi	r24, 0x01	; 1
    3340:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    3342:	ce 01       	movw	r24, r28
    3344:	01 96       	adiw	r24, 0x01	; 1
    3346:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    334a:	10 c0       	rjmp	.+32     	; 0x336c <SvLcdSend+0x180>
	}
	else
	{
		temp.port=g_param->d7->port;
    334c:	e0 91 df 01 	lds	r30, 0x01DF
    3350:	f0 91 e0 01 	lds	r31, 0x01E0
    3354:	06 80       	ldd	r0, Z+6	; 0x06
    3356:	f7 81       	ldd	r31, Z+7	; 0x07
    3358:	e0 2d       	mov	r30, r0
    335a:	80 81       	ld	r24, Z
    335c:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d7->pin;
    335e:	81 81       	ldd	r24, Z+1	; 0x01
    3360:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    3362:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    3364:	ce 01       	movw	r24, r28
    3366:	01 96       	adiw	r24, 0x01	; 1
    3368:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	//latch data
	SvLatch_data();
    336c:	0e 94 c1 18 	call	0x3182	; 0x3182 <SvLatch_data>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3370:	8f e3       	ldi	r24, 0x3F	; 63
    3372:	9f e1       	ldi	r25, 0x1F	; 31
    3374:	01 97       	sbiw	r24, 0x01	; 1
    3376:	f1 f7       	brne	.-4      	; 0x3374 <SvLcdSend+0x188>
    3378:	00 c0       	rjmp	.+0      	; 0x337a <SvLcdSend+0x18e>
    337a:	00 00       	nop
	//delay
	_delay_ms(2);
	//lower nibble data
	if(check_bit(data,0))
    337c:	10 ff       	sbrs	r17, 0
    337e:	14 c0       	rjmp	.+40     	; 0x33a8 <SvLcdSend+0x1bc>
	{
		temp.port=g_param->d4->port;
    3380:	e0 91 df 01 	lds	r30, 0x01DF
    3384:	f0 91 e0 01 	lds	r31, 0x01E0
    3388:	a0 81       	ld	r26, Z
    338a:	b1 81       	ldd	r27, Z+1	; 0x01
    338c:	8c 91       	ld	r24, X
    338e:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d4->pin;
    3390:	01 90       	ld	r0, Z+
    3392:	f0 81       	ld	r31, Z
    3394:	e0 2d       	mov	r30, r0
    3396:	81 81       	ldd	r24, Z+1	; 0x01
    3398:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    339a:	81 e0       	ldi	r24, 0x01	; 1
    339c:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    339e:	ce 01       	movw	r24, r28
    33a0:	01 96       	adiw	r24, 0x01	; 1
    33a2:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    33a6:	12 c0       	rjmp	.+36     	; 0x33cc <SvLcdSend+0x1e0>
	}
	else
	{
		temp.port=g_param->d4->port;
    33a8:	e0 91 df 01 	lds	r30, 0x01DF
    33ac:	f0 91 e0 01 	lds	r31, 0x01E0
    33b0:	a0 81       	ld	r26, Z
    33b2:	b1 81       	ldd	r27, Z+1	; 0x01
    33b4:	8c 91       	ld	r24, X
    33b6:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d4->pin;
    33b8:	01 90       	ld	r0, Z+
    33ba:	f0 81       	ld	r31, Z
    33bc:	e0 2d       	mov	r30, r0
    33be:	81 81       	ldd	r24, Z+1	; 0x01
    33c0:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    33c2:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    33c4:	ce 01       	movw	r24, r28
    33c6:	01 96       	adiw	r24, 0x01	; 1
    33c8:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	if(check_bit(data,1))
    33cc:	11 ff       	sbrs	r17, 1
    33ce:	12 c0       	rjmp	.+36     	; 0x33f4 <SvLcdSend+0x208>
	{
		temp.port=g_param->d5->port;
    33d0:	e0 91 df 01 	lds	r30, 0x01DF
    33d4:	f0 91 e0 01 	lds	r31, 0x01E0
    33d8:	02 80       	ldd	r0, Z+2	; 0x02
    33da:	f3 81       	ldd	r31, Z+3	; 0x03
    33dc:	e0 2d       	mov	r30, r0
    33de:	80 81       	ld	r24, Z
    33e0:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d5->pin;
    33e2:	81 81       	ldd	r24, Z+1	; 0x01
    33e4:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    33e6:	81 e0       	ldi	r24, 0x01	; 1
    33e8:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    33ea:	ce 01       	movw	r24, r28
    33ec:	01 96       	adiw	r24, 0x01	; 1
    33ee:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    33f2:	10 c0       	rjmp	.+32     	; 0x3414 <SvLcdSend+0x228>
	}
	else
	{
		temp.port=g_param->d5->port;
    33f4:	e0 91 df 01 	lds	r30, 0x01DF
    33f8:	f0 91 e0 01 	lds	r31, 0x01E0
    33fc:	02 80       	ldd	r0, Z+2	; 0x02
    33fe:	f3 81       	ldd	r31, Z+3	; 0x03
    3400:	e0 2d       	mov	r30, r0
    3402:	80 81       	ld	r24, Z
    3404:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d5->pin;
    3406:	81 81       	ldd	r24, Z+1	; 0x01
    3408:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    340a:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    340c:	ce 01       	movw	r24, r28
    340e:	01 96       	adiw	r24, 0x01	; 1
    3410:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	if(check_bit(data,2))
    3414:	12 ff       	sbrs	r17, 2
    3416:	12 c0       	rjmp	.+36     	; 0x343c <SvLcdSend+0x250>
	{
		temp.port=g_param->d6->port;
    3418:	e0 91 df 01 	lds	r30, 0x01DF
    341c:	f0 91 e0 01 	lds	r31, 0x01E0
    3420:	04 80       	ldd	r0, Z+4	; 0x04
    3422:	f5 81       	ldd	r31, Z+5	; 0x05
    3424:	e0 2d       	mov	r30, r0
    3426:	80 81       	ld	r24, Z
    3428:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d6->pin;
    342a:	81 81       	ldd	r24, Z+1	; 0x01
    342c:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    342e:	81 e0       	ldi	r24, 0x01	; 1
    3430:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    3432:	ce 01       	movw	r24, r28
    3434:	01 96       	adiw	r24, 0x01	; 1
    3436:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    343a:	10 c0       	rjmp	.+32     	; 0x345c <SvLcdSend+0x270>
	}
	else
	{
		temp.port=g_param->d6->port;
    343c:	e0 91 df 01 	lds	r30, 0x01DF
    3440:	f0 91 e0 01 	lds	r31, 0x01E0
    3444:	04 80       	ldd	r0, Z+4	; 0x04
    3446:	f5 81       	ldd	r31, Z+5	; 0x05
    3448:	e0 2d       	mov	r30, r0
    344a:	80 81       	ld	r24, Z
    344c:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d6->pin;
    344e:	81 81       	ldd	r24, Z+1	; 0x01
    3450:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    3452:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    3454:	ce 01       	movw	r24, r28
    3456:	01 96       	adiw	r24, 0x01	; 1
    3458:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	if(check_bit(data,3))
    345c:	13 ff       	sbrs	r17, 3
    345e:	12 c0       	rjmp	.+36     	; 0x3484 <SvLcdSend+0x298>
	{
		temp.port=g_param->d7->port;
    3460:	e0 91 df 01 	lds	r30, 0x01DF
    3464:	f0 91 e0 01 	lds	r31, 0x01E0
    3468:	06 80       	ldd	r0, Z+6	; 0x06
    346a:	f7 81       	ldd	r31, Z+7	; 0x07
    346c:	e0 2d       	mov	r30, r0
    346e:	80 81       	ld	r24, Z
    3470:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d7->pin;
    3472:	81 81       	ldd	r24, Z+1	; 0x01
    3474:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_HIGH;
    3476:	81 e0       	ldi	r24, 0x01	; 1
    3478:	8b 83       	std	Y+3, r24	; 0x03
		vGpio_Write(&temp);
    347a:	ce 01       	movw	r24, r28
    347c:	01 96       	adiw	r24, 0x01	; 1
    347e:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    3482:	10 c0       	rjmp	.+32     	; 0x34a4 <SvLcdSend+0x2b8>
	}
	else
	{
		temp.port=g_param->d7->port;
    3484:	e0 91 df 01 	lds	r30, 0x01DF
    3488:	f0 91 e0 01 	lds	r31, 0x01E0
    348c:	06 80       	ldd	r0, Z+6	; 0x06
    348e:	f7 81       	ldd	r31, Z+7	; 0x07
    3490:	e0 2d       	mov	r30, r0
    3492:	80 81       	ld	r24, Z
    3494:	89 83       	std	Y+1, r24	; 0x01
		temp.pin=g_param->d7->pin;
    3496:	81 81       	ldd	r24, Z+1	; 0x01
    3498:	8a 83       	std	Y+2, r24	; 0x02
		temp.output=STD_LOGIC_LOW;
    349a:	1b 82       	std	Y+3, r1	; 0x03
		vGpio_Write(&temp);
    349c:	ce 01       	movw	r24, r28
    349e:	01 96       	adiw	r24, 0x01	; 1
    34a0:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
	}
	//latch data
	SvLatch_data();
    34a4:	0e 94 c1 18 	call	0x3182	; 0x3182 <SvLatch_data>
}
    34a8:	0f 90       	pop	r0
    34aa:	0f 90       	pop	r0
    34ac:	0f 90       	pop	r0
    34ae:	df 91       	pop	r29
    34b0:	cf 91       	pop	r28
    34b2:	1f 91       	pop	r17
    34b4:	08 95       	ret

000034b6 <vEcu_LcdInit>:
static ecu_lcd_init_param_t* g_param;
//---------------------------------------------------------------
void vEcu_LcdInit(ecu_lcd_init_param_t* param)
{
	//save pointer to struct
	g_param=param;
    34b6:	90 93 e0 01 	sts	0x01E0, r25
    34ba:	80 93 df 01 	sts	0x01DF, r24
	//init gpio 
	vGpio_Init(g_param->d4);
    34be:	fc 01       	movw	r30, r24
    34c0:	80 81       	ld	r24, Z
    34c2:	91 81       	ldd	r25, Z+1	; 0x01
    34c4:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init(g_param->d5);
    34c8:	e0 91 df 01 	lds	r30, 0x01DF
    34cc:	f0 91 e0 01 	lds	r31, 0x01E0
    34d0:	82 81       	ldd	r24, Z+2	; 0x02
    34d2:	93 81       	ldd	r25, Z+3	; 0x03
    34d4:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init(g_param->d6);
    34d8:	e0 91 df 01 	lds	r30, 0x01DF
    34dc:	f0 91 e0 01 	lds	r31, 0x01E0
    34e0:	84 81       	ldd	r24, Z+4	; 0x04
    34e2:	95 81       	ldd	r25, Z+5	; 0x05
    34e4:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init(g_param->d7);
    34e8:	e0 91 df 01 	lds	r30, 0x01DF
    34ec:	f0 91 e0 01 	lds	r31, 0x01E0
    34f0:	86 81       	ldd	r24, Z+6	; 0x06
    34f2:	97 81       	ldd	r25, Z+7	; 0x07
    34f4:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	
	vGpio_Init(g_param->rs);
    34f8:	e0 91 df 01 	lds	r30, 0x01DF
    34fc:	f0 91 e0 01 	lds	r31, 0x01E0
    3500:	80 85       	ldd	r24, Z+8	; 0x08
    3502:	91 85       	ldd	r25, Z+9	; 0x09
    3504:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	vGpio_Init(g_param->e);
    3508:	e0 91 df 01 	lds	r30, 0x01DF
    350c:	f0 91 e0 01 	lds	r31, 0x01E0
    3510:	82 85       	ldd	r24, Z+10	; 0x0a
    3512:	93 85       	ldd	r25, Z+11	; 0x0b
    3514:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
    3518:	ff ef       	ldi	r31, 0xFF	; 255
    351a:	29 ef       	ldi	r18, 0xF9	; 249
    351c:	80 e0       	ldi	r24, 0x00	; 0
    351e:	f1 50       	subi	r31, 0x01	; 1
    3520:	20 40       	sbci	r18, 0x00	; 0
    3522:	80 40       	sbci	r24, 0x00	; 0
    3524:	e1 f7       	brne	.-8      	; 0x351e <vEcu_LcdInit+0x68>
    3526:	00 c0       	rjmp	.+0      	; 0x3528 <vEcu_LcdInit+0x72>
    3528:	00 00       	nop
	//delay to reach vcc level
	_delay_ms(20);
	//send init cmds
	SvLcdSend(CMD,LCD_CMD_MODE4_INIT0);
    352a:	63 e3       	ldi	r22, 0x33	; 51
    352c:	80 e0       	ldi	r24, 0x00	; 0
    352e:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
	SvLcdSend(CMD,LCD_CMD_MODE4_INIT1);
    3532:	62 e3       	ldi	r22, 0x32	; 50
    3534:	80 e0       	ldi	r24, 0x00	; 0
    3536:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
	SvLcdSend(CMD,LCD_CMD_MODE4_2LINES);
    353a:	68 e2       	ldi	r22, 0x28	; 40
    353c:	80 e0       	ldi	r24, 0x00	; 0
    353e:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
	SvLcdSend(CMD,LCD_CMD_DISPLAY_ON_CURSOR_OFF);
    3542:	6c e0       	ldi	r22, 0x0C	; 12
    3544:	80 e0       	ldi	r24, 0x00	; 0
    3546:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
    354a:	08 95       	ret

0000354c <vEcu_LcdSendChar>:
}
//--------------------------------------------------------------------
void vEcu_LcdSendChar(char data)
{
	SvLcdSend(DATA,data);
    354c:	68 2f       	mov	r22, r24
    354e:	81 e0       	ldi	r24, 0x01	; 1
    3550:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
    3554:	08 95       	ret

00003556 <u8Ecu_LcdSendString>:
}
//------------------------------------------------------------------
u8 u8Ecu_LcdSendString(char* str_ptr)
{
    3556:	cf 93       	push	r28
    3558:	df 93       	push	r29
	//check if no char send
	if(str_ptr ==NULL)
    355a:	00 97       	sbiw	r24, 0x00	; 0
    355c:	71 f0       	breq	.+28     	; 0x357a <u8Ecu_LcdSendString+0x24>
	{
		return LCD_NO_CHAR_TO_PRINT ;
	}
	else
	{   //print till null char
		while(*str_ptr !='\0')
    355e:	fc 01       	movw	r30, r24
    3560:	60 81       	ld	r22, Z
    3562:	66 23       	and	r22, r22
    3564:	61 f0       	breq	.+24     	; 0x357e <u8Ecu_LcdSendString+0x28>
void vEcu_LcdSendChar(char data)
{
	SvLcdSend(DATA,data);
}
//------------------------------------------------------------------
u8 u8Ecu_LcdSendString(char* str_ptr)
    3566:	ec 01       	movw	r28, r24
    3568:	21 96       	adiw	r28, 0x01	; 1
	}
	else
	{   //print till null char
		while(*str_ptr !='\0')
		{
			SvLcdSend(DATA,*str_ptr);
    356a:	81 e0       	ldi	r24, 0x01	; 1
    356c:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
	{
		return LCD_NO_CHAR_TO_PRINT ;
	}
	else
	{   //print till null char
		while(*str_ptr !='\0')
    3570:	69 91       	ld	r22, Y+
    3572:	61 11       	cpse	r22, r1
    3574:	fa cf       	rjmp	.-12     	; 0x356a <u8Ecu_LcdSendString+0x14>
		{
			SvLcdSend(DATA,*str_ptr);
			str_ptr++;
		}
		return LCD_NO_ERROR ;
    3576:	80 e0       	ldi	r24, 0x00	; 0
    3578:	03 c0       	rjmp	.+6      	; 0x3580 <u8Ecu_LcdSendString+0x2a>
u8 u8Ecu_LcdSendString(char* str_ptr)
{
	//check if no char send
	if(str_ptr ==NULL)
	{
		return LCD_NO_CHAR_TO_PRINT ;
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	01 c0       	rjmp	.+2      	; 0x3580 <u8Ecu_LcdSendString+0x2a>
		while(*str_ptr !='\0')
		{
			SvLcdSend(DATA,*str_ptr);
			str_ptr++;
		}
		return LCD_NO_ERROR ;
    357e:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    3580:	df 91       	pop	r29
    3582:	cf 91       	pop	r28
    3584:	08 95       	ret

00003586 <vEcu_LcdSendCmd>:
//------------------------------------------------------------------
void vEcu_LcdSendCmd(char data)
{
	SvLcdSend(CMD,data);
    3586:	68 2f       	mov	r22, r24
    3588:	80 e0       	ldi	r24, 0x00	; 0
    358a:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
    358e:	08 95       	ret

00003590 <vEcu_LcdClearDisplay>:
}
//------------------------------------------------------------------
void vEcu_LcdClearDisplay(void)
{
	SvLcdSend(CMD,LCD_CMD_CLEAR_DISPLAY);
    3590:	61 e0       	ldi	r22, 0x01	; 1
    3592:	80 e0       	ldi	r24, 0x00	; 0
    3594:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
    3598:	2f ef       	ldi	r18, 0xFF	; 255
    359a:	81 ee       	ldi	r24, 0xE1	; 225
    359c:	94 e0       	ldi	r25, 0x04	; 4
    359e:	21 50       	subi	r18, 0x01	; 1
    35a0:	80 40       	sbci	r24, 0x00	; 0
    35a2:	90 40       	sbci	r25, 0x00	; 0
    35a4:	e1 f7       	brne	.-8      	; 0x359e <vEcu_LcdClearDisplay+0xe>
    35a6:	00 c0       	rjmp	.+0      	; 0x35a8 <vEcu_LcdClearDisplay+0x18>
    35a8:	00 00       	nop
    35aa:	08 95       	ret

000035ac <u8Ecu_LcdGoToXy>:
}
//-----------------------------------------------------------------
u8 u8Ecu_LcdGoToXy(u8 line,u8 column)
{
	//limit check
	switch(line)
    35ac:	88 23       	and	r24, r24
    35ae:	19 f0       	breq	.+6      	; 0x35b6 <u8Ecu_LcdGoToXy+0xa>
    35b0:	81 30       	cpi	r24, 0x01	; 1
    35b2:	89 f4       	brne	.+34     	; 0x35d6 <u8Ecu_LcdGoToXy+0x2a>
    35b4:	08 c0       	rjmp	.+16     	; 0x35c6 <u8Ecu_LcdGoToXy+0x1a>
	{
		case LCD_FIRST_LINE :
		if(column >=0 && column <=15)
    35b6:	60 31       	cpi	r22, 0x10	; 16
    35b8:	80 f4       	brcc	.+32     	; 0x35da <u8Ecu_LcdGoToXy+0x2e>
		{
			SvLcdSend(CMD,FIRST_LINE_ADDRESS + column);
    35ba:	60 58       	subi	r22, 0x80	; 128
    35bc:	80 e0       	ldi	r24, 0x00	; 0
    35be:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
			return LCD_ERROR_COLUMN_OUT_OF_RANGE ;
		}
		break;
		default:return LCD_ERROR_ROW_OUT_OF_RANGE ;
	}
	return LCD_NO_ERROR ;
    35c2:	80 e0       	ldi	r24, 0x00	; 0
		}
		else
		{
			return LCD_ERROR_COLUMN_OUT_OF_RANGE ;
		}
		break;
    35c4:	08 95       	ret
		case LCD_SECOND_LINE :
		if(column >=0 && column <=15)
    35c6:	60 31       	cpi	r22, 0x10	; 16
    35c8:	50 f4       	brcc	.+20     	; 0x35de <u8Ecu_LcdGoToXy+0x32>
		{
			SvLcdSend(CMD,SECOND_LINE_ADDRESS + column);
    35ca:	60 54       	subi	r22, 0x40	; 64
    35cc:	80 e0       	ldi	r24, 0x00	; 0
    35ce:	0e 94 f6 18 	call	0x31ec	; 0x31ec <SvLcdSend>
			return LCD_ERROR_COLUMN_OUT_OF_RANGE ;
		}
		break;
		default:return LCD_ERROR_ROW_OUT_OF_RANGE ;
	}
	return LCD_NO_ERROR ;
    35d2:	80 e0       	ldi	r24, 0x00	; 0
		}
		else
		{
			return LCD_ERROR_COLUMN_OUT_OF_RANGE ;
		}
		break;
    35d4:	08 95       	ret
		default:return LCD_ERROR_ROW_OUT_OF_RANGE ;
    35d6:	82 e0       	ldi	r24, 0x02	; 2
    35d8:	08 95       	ret
		{
			SvLcdSend(CMD,FIRST_LINE_ADDRESS + column);
		}
		else
		{
			return LCD_ERROR_COLUMN_OUT_OF_RANGE ;
    35da:	83 e0       	ldi	r24, 0x03	; 3
    35dc:	08 95       	ret
		{
			SvLcdSend(CMD,SECOND_LINE_ADDRESS + column);
		}
		else
		{
			return LCD_ERROR_COLUMN_OUT_OF_RANGE ;
    35de:	83 e0       	ldi	r24, 0x03	; 3
		}
		break;
		default:return LCD_ERROR_ROW_OUT_OF_RANGE ;
	}
	return LCD_NO_ERROR ;
}
    35e0:	08 95       	ret

000035e2 <vEcu_LcdSendPassword>:
	_delay_us(20);
}
//--------------------------------------------------------------------
void vEcu_LcdSendPassword(char data)
{
	vEcu_LcdSendChar(data);
    35e2:	0e 94 a6 1a 	call	0x354c	; 0x354c <vEcu_LcdSendChar>
    35e6:	2f ef       	ldi	r18, 0xFF	; 255
    35e8:	85 ea       	ldi	r24, 0xA5	; 165
    35ea:	9e e0       	ldi	r25, 0x0E	; 14
    35ec:	21 50       	subi	r18, 0x01	; 1
    35ee:	80 40       	sbci	r24, 0x00	; 0
    35f0:	90 40       	sbci	r25, 0x00	; 0
    35f2:	e1 f7       	brne	.-8      	; 0x35ec <vEcu_LcdSendPassword+0xa>
    35f4:	00 c0       	rjmp	.+0      	; 0x35f6 <vEcu_LcdSendPassword+0x14>
    35f6:	00 00       	nop
	_delay_ms(300);
	vEcu_LcdSendCmd(LCD_CMD_CURSOR_MOVE_LEFT);
    35f8:	80 e1       	ldi	r24, 0x10	; 16
    35fa:	0e 94 c3 1a 	call	0x3586	; 0x3586 <vEcu_LcdSendCmd>
    35fe:	2f ef       	ldi	r18, 0xFF	; 255
    3600:	89 ef       	ldi	r24, 0xF9	; 249
    3602:	90 e0       	ldi	r25, 0x00	; 0
    3604:	21 50       	subi	r18, 0x01	; 1
    3606:	80 40       	sbci	r24, 0x00	; 0
    3608:	90 40       	sbci	r25, 0x00	; 0
    360a:	e1 f7       	brne	.-8      	; 0x3604 <vEcu_LcdSendPassword+0x22>
    360c:	00 c0       	rjmp	.+0      	; 0x360e <vEcu_LcdSendPassword+0x2c>
    360e:	00 00       	nop
	_delay_ms(20);
	vEcu_LcdSendChar(' ');
    3610:	80 e2       	ldi	r24, 0x20	; 32
    3612:	0e 94 a6 1a 	call	0x354c	; 0x354c <vEcu_LcdSendChar>
    3616:	2f ef       	ldi	r18, 0xFF	; 255
    3618:	85 ea       	ldi	r24, 0xA5	; 165
    361a:	9e e0       	ldi	r25, 0x0E	; 14
    361c:	21 50       	subi	r18, 0x01	; 1
    361e:	80 40       	sbci	r24, 0x00	; 0
    3620:	90 40       	sbci	r25, 0x00	; 0
    3622:	e1 f7       	brne	.-8      	; 0x361c <vEcu_LcdSendPassword+0x3a>
    3624:	00 c0       	rjmp	.+0      	; 0x3626 <vEcu_LcdSendPassword+0x44>
    3626:	00 00       	nop
	_delay_ms(300);
	vEcu_LcdSendCmd(LCD_CMD_CURSOR_MOVE_LEFT);
    3628:	80 e1       	ldi	r24, 0x10	; 16
    362a:	0e 94 c3 1a 	call	0x3586	; 0x3586 <vEcu_LcdSendCmd>
    362e:	2f ef       	ldi	r18, 0xFF	; 255
    3630:	89 ef       	ldi	r24, 0xF9	; 249
    3632:	90 e0       	ldi	r25, 0x00	; 0
    3634:	21 50       	subi	r18, 0x01	; 1
    3636:	80 40       	sbci	r24, 0x00	; 0
    3638:	90 40       	sbci	r25, 0x00	; 0
    363a:	e1 f7       	brne	.-8      	; 0x3634 <vEcu_LcdSendPassword+0x52>
    363c:	00 c0       	rjmp	.+0      	; 0x363e <vEcu_LcdSendPassword+0x5c>
    363e:	00 00       	nop
	_delay_ms(20);
	vEcu_LcdSendChar('*');
    3640:	8a e2       	ldi	r24, 0x2A	; 42
    3642:	0e 94 a6 1a 	call	0x354c	; 0x354c <vEcu_LcdSendChar>
    3646:	08 95       	ret

00003648 <vEcu_LcdRemovePassword>:
}
//----------------------------------------------------------------
void vEcu_LcdRemovePassword(void)
{
	vEcu_LcdSendCmd(LCD_CMD_CURSOR_MOVE_LEFT);
    3648:	80 e1       	ldi	r24, 0x10	; 16
    364a:	0e 94 c3 1a 	call	0x3586	; 0x3586 <vEcu_LcdSendCmd>
	vEcu_LcdSendChar(' ');
    364e:	80 e2       	ldi	r24, 0x20	; 32
    3650:	0e 94 a6 1a 	call	0x354c	; 0x354c <vEcu_LcdSendChar>
	vEcu_LcdSendCmd(LCD_CMD_CURSOR_MOVE_LEFT);
    3654:	80 e1       	ldi	r24, 0x10	; 16
    3656:	0e 94 c3 1a 	call	0x3586	; 0x3586 <vEcu_LcdSendCmd>
    365a:	08 95       	ret

0000365c <vEcu_led_init>:
//-------------------------------------------------------------- 
#include "ecu_led.h"
//---------------------------------------------------------------
//---------------------------------------------------------------
void vEcu_led_init(ecu_led_t * led_param)
{
    365c:	cf 93       	push	r28
    365e:	df 93       	push	r29
    3660:	00 d0       	rcall	.+0      	; 0x3662 <vEcu_led_init+0x6>
    3662:	00 d0       	rcall	.+0      	; 0x3664 <vEcu_led_init+0x8>
    3664:	cd b7       	in	r28, 0x3d	; 61
    3666:	de b7       	in	r29, 0x3e	; 62
    3668:	fc 01       	movw	r30, r24
	gpio_init_param_t temp;
	temp.direction=GPIO_OUTPUT;
    366a:	81 e0       	ldi	r24, 0x01	; 1
    366c:	8b 83       	std	Y+3, r24	; 0x03
	temp.output_init_value=led_param->output;
    366e:	82 81       	ldd	r24, Z+2	; 0x02
    3670:	8c 83       	std	Y+4, r24	; 0x04
	temp.pin=led_param->pin;
    3672:	81 81       	ldd	r24, Z+1	; 0x01
    3674:	8a 83       	std	Y+2, r24	; 0x02
	temp.port=led_param->port;
    3676:	80 81       	ld	r24, Z
    3678:	89 83       	std	Y+1, r24	; 0x01
	vGpio_Init(&temp);
    367a:	ce 01       	movw	r24, r28
    367c:	01 96       	adiw	r24, 0x01	; 1
    367e:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
}
    3682:	0f 90       	pop	r0
    3684:	0f 90       	pop	r0
    3686:	0f 90       	pop	r0
    3688:	0f 90       	pop	r0
    368a:	df 91       	pop	r29
    368c:	cf 91       	pop	r28
    368e:	08 95       	ret

00003690 <vEcu_set_led_on>:
//-----------------------------------------------------------------
void vEcu_set_led_on(ecu_led_t * led_param)
{
	led_param->output=STD_LOGIC_HIGH;
    3690:	21 e0       	ldi	r18, 0x01	; 1
    3692:	fc 01       	movw	r30, r24
    3694:	22 83       	std	Z+2, r18	; 0x02
	vGpio_Write(led_param);
    3696:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    369a:	08 95       	ret

0000369c <vEcu_set_led_off>:
}
//----------------------------------------------------------------
void vEcu_set_led_off(ecu_led_t * led_param)
{
	led_param->output=STD_LOGIC_LOW;
    369c:	fc 01       	movw	r30, r24
    369e:	12 82       	std	Z+2, r1	; 0x02
	vGpio_Write(led_param);
    36a0:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
    36a4:	08 95       	ret

000036a6 <vEcu_toggle_led>:
}
//----------------------------------------------------------------
void vEcu_toggle_led(ecu_led_t * led_param)
{
    36a6:	0f 93       	push	r16
    36a8:	1f 93       	push	r17
    36aa:	cf 93       	push	r28
    36ac:	df 93       	push	r29
    36ae:	00 d0       	rcall	.+0      	; 0x36b0 <vEcu_toggle_led+0xa>
    36b0:	cd b7       	in	r28, 0x3d	; 61
    36b2:	de b7       	in	r29, 0x3e	; 62
    36b4:	8c 01       	movw	r16, r24
	gpio_read_param_t temp;
	boolean val;
	temp.pin=led_param->pin;
    36b6:	fc 01       	movw	r30, r24
    36b8:	81 81       	ldd	r24, Z+1	; 0x01
    36ba:	8a 83       	std	Y+2, r24	; 0x02
	temp.port=led_param->port;
    36bc:	80 81       	ld	r24, Z
    36be:	89 83       	std	Y+1, r24	; 0x01
	val=Gpio_Read(&temp);
    36c0:	ce 01       	movw	r24, r28
    36c2:	01 96       	adiw	r24, 0x01	; 1
    36c4:	0e 94 58 23 	call	0x46b0	; 0x46b0 <Gpio_Read>
	led_param->output= !(val);
    36c8:	91 e0       	ldi	r25, 0x01	; 1
    36ca:	81 11       	cpse	r24, r1
    36cc:	90 e0       	ldi	r25, 0x00	; 0
    36ce:	f8 01       	movw	r30, r16
    36d0:	92 83       	std	Z+2, r25	; 0x02
	vGpio_Write(led_param);
    36d2:	c8 01       	movw	r24, r16
    36d4:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
}
    36d8:	0f 90       	pop	r0
    36da:	0f 90       	pop	r0
    36dc:	df 91       	pop	r29
    36de:	cf 91       	pop	r28
    36e0:	1f 91       	pop	r17
    36e2:	0f 91       	pop	r16
    36e4:	08 95       	ret

000036e6 <vExternal_EEPROM_Write>:
		return EXTRNAL_EEPROM_INIT_NO_ERROR;
	}
}
//-------------------------------------------------------
void vExternal_EEPROM_Write(external_eeprom_byte_address_t byte_address,external_eeprom_data* data,u8 count)
{
    36e6:	df 92       	push	r13
    36e8:	ef 92       	push	r14
    36ea:	ff 92       	push	r15
    36ec:	0f 93       	push	r16
    36ee:	1f 93       	push	r17
    36f0:	cf 93       	push	r28
    36f2:	df 93       	push	r29
    36f4:	ec 01       	movw	r28, r24
    36f6:	8b 01       	movw	r16, r22
	u16 index=0;
	u8 temp_address=g_ex_eeprom_address;
	for(index=0;index<count;index++)
    36f8:	e4 2e       	mov	r14, r20
    36fa:	f1 2c       	mov	r15, r1
    36fc:	e1 14       	cp	r14, r1
    36fe:	f1 04       	cpc	r15, r1
    3700:	81 f1       	breq	.+96     	; 0x3762 <vExternal_EEPROM_Write+0x7c>
	{
		return EXTRNAL_EEPROM_INIT_NO_ERROR;
	}
}
//-------------------------------------------------------
void vExternal_EEPROM_Write(external_eeprom_byte_address_t byte_address,external_eeprom_data* data,u8 count)
    3702:	e8 0e       	add	r14, r24
    3704:	f9 1e       	adc	r15, r25
{
	u16 index=0;
	u8 temp_address=g_ex_eeprom_address;
    3706:	0f 2e       	mov	r0, r31
    3708:	f0 ea       	ldi	r31, 0xA0	; 160
    370a:	df 2e       	mov	r13, r31
    370c:	f0 2d       	mov	r31, r0
	for(index=0;index<count;index++)
	{
		//send device address with p0 as
		u8I2c_Start();
    370e:	0e 94 60 24 	call	0x48c0	; 0x48c0 <u8I2c_Start>
		if(byte_address<=0x00FF)
    3712:	cf 3f       	cpi	r28, 0xFF	; 255
    3714:	d1 05       	cpc	r29, r1
    3716:	09 f0       	breq	.+2      	; 0x371a <vExternal_EEPROM_Write+0x34>
    3718:	40 f4       	brcc	.+16     	; 0x372a <vExternal_EEPROM_Write+0x44>
		{
			//page 0
			u8I2c_Send_Address(temp_address,I2C_WRITE);
    371a:	60 e0       	ldi	r22, 0x00	; 0
    371c:	8d 2d       	mov	r24, r13
    371e:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
			//send byte address
			u8I2c_Send_Data((u8)(byte_address));
    3722:	8c 2f       	mov	r24, r28
    3724:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
    3728:	0b c0       	rjmp	.+22     	; 0x3740 <vExternal_EEPROM_Write+0x5a>
		} 
		else
		{
			//page 1
			set_bit(temp_address,1);
			u8I2c_Send_Address(temp_address,I2C_WRITE);
    372a:	60 e0       	ldi	r22, 0x00	; 0
    372c:	82 ea       	ldi	r24, 0xA2	; 162
    372e:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
			//send byte address
			u8I2c_Send_Data((u8)(byte_address));
    3732:	8c 2f       	mov	r24, r28
    3734:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
			u8I2c_Send_Data((u8)(byte_address));
		} 
		else
		{
			//page 1
			set_bit(temp_address,1);
    3738:	0f 2e       	mov	r0, r31
    373a:	f2 ea       	ldi	r31, 0xA2	; 162
    373c:	df 2e       	mov	r13, r31
    373e:	f0 2d       	mov	r31, r0
			u8I2c_Send_Address(temp_address,I2C_WRITE);
			//send byte address
			u8I2c_Send_Data((u8)(byte_address));
		}
		
		u8I2c_Send_Data(*(data++));
    3740:	f8 01       	movw	r30, r16
    3742:	81 91       	ld	r24, Z+
    3744:	8f 01       	movw	r16, r30
    3746:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
		vI2c_Stop();
    374a:	0e 94 93 24 	call	0x4926	; 0x4926 <vI2c_Stop>
		byte_address++;
    374e:	21 96       	adiw	r28, 0x01	; 1
    3750:	8f e9       	ldi	r24, 0x9F	; 159
    3752:	9f e0       	ldi	r25, 0x0F	; 15
    3754:	01 97       	sbiw	r24, 0x01	; 1
    3756:	f1 f7       	brne	.-4      	; 0x3754 <vExternal_EEPROM_Write+0x6e>
    3758:	00 c0       	rjmp	.+0      	; 0x375a <vExternal_EEPROM_Write+0x74>
    375a:	00 00       	nop
//-------------------------------------------------------
void vExternal_EEPROM_Write(external_eeprom_byte_address_t byte_address,external_eeprom_data* data,u8 count)
{
	u16 index=0;
	u8 temp_address=g_ex_eeprom_address;
	for(index=0;index<count;index++)
    375c:	ce 15       	cp	r28, r14
    375e:	df 05       	cpc	r29, r15
    3760:	b1 f6       	brne	.-84     	; 0x370e <vExternal_EEPROM_Write+0x28>
		u8I2c_Send_Data(*(data++));
		vI2c_Stop();
		byte_address++;
		_delay_ms(1);
	}		 
}
    3762:	df 91       	pop	r29
    3764:	cf 91       	pop	r28
    3766:	1f 91       	pop	r17
    3768:	0f 91       	pop	r16
    376a:	ff 90       	pop	r15
    376c:	ef 90       	pop	r14
    376e:	df 90       	pop	r13
    3770:	08 95       	ret

00003772 <vExternal_EEPROM_Read>:
//--------------------------------------------------------------------------------------------------------
void vExternal_EEPROM_Read(external_eeprom_byte_address_t byte_address,external_eeprom_data* data,u8 count)
{
    3772:	df 92       	push	r13
    3774:	ef 92       	push	r14
    3776:	ff 92       	push	r15
    3778:	0f 93       	push	r16
    377a:	1f 93       	push	r17
    377c:	cf 93       	push	r28
    377e:	df 93       	push	r29
    3780:	ec 01       	movw	r28, r24
    3782:	8b 01       	movw	r16, r22
	u16 index=0;
	u8 temp_address=g_ex_eeprom_address;
	for(index=0;index<count;index++)
    3784:	e4 2e       	mov	r14, r20
    3786:	f1 2c       	mov	r15, r1
    3788:	e1 14       	cp	r14, r1
    378a:	f1 04       	cpc	r15, r1
    378c:	09 f4       	brne	.+2      	; 0x3790 <vExternal_EEPROM_Read+0x1e>
    378e:	41 c0       	rjmp	.+130    	; 0x3812 <vExternal_EEPROM_Read+0xa0>
		byte_address++;
		_delay_ms(1);
	}		 
}
//--------------------------------------------------------------------------------------------------------
void vExternal_EEPROM_Read(external_eeprom_byte_address_t byte_address,external_eeprom_data* data,u8 count)
    3790:	e8 0e       	add	r14, r24
    3792:	f9 1e       	adc	r15, r25
{
	u16 index=0;
	u8 temp_address=g_ex_eeprom_address;
    3794:	0f 2e       	mov	r0, r31
    3796:	f0 ea       	ldi	r31, 0xA0	; 160
    3798:	df 2e       	mov	r13, r31
    379a:	f0 2d       	mov	r31, r0
	for(index=0;index<count;index++)
	{
		//send device address with p0 as
		u8I2c_Start();
    379c:	0e 94 60 24 	call	0x48c0	; 0x48c0 <u8I2c_Start>
		if(byte_address<=0x00FF)
    37a0:	cf 3f       	cpi	r28, 0xFF	; 255
    37a2:	d1 05       	cpc	r29, r1
    37a4:	09 f0       	breq	.+2      	; 0x37a8 <vExternal_EEPROM_Read+0x36>
    37a6:	90 f4       	brcc	.+36     	; 0x37cc <vExternal_EEPROM_Read+0x5a>
		{
			//page 0
			u8I2c_Send_Address(temp_address,I2C_WRITE);
    37a8:	60 e0       	ldi	r22, 0x00	; 0
    37aa:	8d 2d       	mov	r24, r13
    37ac:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
			//send byte address
			u8I2c_Send_Data((u8)(byte_address));
    37b0:	8c 2f       	mov	r24, r28
    37b2:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
			u8I2c_Restart();
    37b6:	0e 94 96 24 	call	0x492c	; 0x492c <u8I2c_Restart>
			u8I2c_Send_Address(temp_address,I2C_READ);
    37ba:	61 e0       	ldi	r22, 0x01	; 1
    37bc:	8d 2d       	mov	r24, r13
    37be:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
			u8I2c_Read_Data(data,1);
    37c2:	61 e0       	ldi	r22, 0x01	; 1
    37c4:	c8 01       	movw	r24, r16
    37c6:	0e 94 a3 24 	call	0x4946	; 0x4946 <u8I2c_Read_Data>
    37ca:	15 c0       	rjmp	.+42     	; 0x37f6 <vExternal_EEPROM_Read+0x84>
		}
		else
		{
			//page 1
			set_bit(temp_address,1);
			u8I2c_Send_Address(temp_address,I2C_WRITE);
    37cc:	60 e0       	ldi	r22, 0x00	; 0
    37ce:	82 ea       	ldi	r24, 0xA2	; 162
    37d0:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
			//send byte address
			u8I2c_Send_Data((u8)(byte_address));
    37d4:	8c 2f       	mov	r24, r28
    37d6:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
			u8I2c_Restart();
    37da:	0e 94 96 24 	call	0x492c	; 0x492c <u8I2c_Restart>
			u8I2c_Send_Address(temp_address,I2C_READ);
    37de:	61 e0       	ldi	r22, 0x01	; 1
    37e0:	82 ea       	ldi	r24, 0xA2	; 162
    37e2:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
			//read byte 
			u8I2c_Read_Data(data,1);
    37e6:	61 e0       	ldi	r22, 0x01	; 1
    37e8:	c8 01       	movw	r24, r16
    37ea:	0e 94 a3 24 	call	0x4946	; 0x4946 <u8I2c_Read_Data>
			u8I2c_Read_Data(data,1);
		}
		else
		{
			//page 1
			set_bit(temp_address,1);
    37ee:	0f 2e       	mov	r0, r31
    37f0:	f2 ea       	ldi	r31, 0xA2	; 162
    37f2:	df 2e       	mov	r13, r31
    37f4:	f0 2d       	mov	r31, r0
			u8I2c_Send_Address(temp_address,I2C_READ);
			//read byte 
			u8I2c_Read_Data(data,1);
		}
		
		data++;
    37f6:	0f 5f       	subi	r16, 0xFF	; 255
    37f8:	1f 4f       	sbci	r17, 0xFF	; 255
		byte_address++;
    37fa:	21 96       	adiw	r28, 0x01	; 1
		vI2c_Stop();
    37fc:	0e 94 93 24 	call	0x4926	; 0x4926 <vI2c_Stop>
    3800:	8f e9       	ldi	r24, 0x9F	; 159
    3802:	9f e0       	ldi	r25, 0x0F	; 15
    3804:	01 97       	sbiw	r24, 0x01	; 1
    3806:	f1 f7       	brne	.-4      	; 0x3804 <vExternal_EEPROM_Read+0x92>
    3808:	00 c0       	rjmp	.+0      	; 0x380a <vExternal_EEPROM_Read+0x98>
    380a:	00 00       	nop
//--------------------------------------------------------------------------------------------------------
void vExternal_EEPROM_Read(external_eeprom_byte_address_t byte_address,external_eeprom_data* data,u8 count)
{
	u16 index=0;
	u8 temp_address=g_ex_eeprom_address;
	for(index=0;index<count;index++)
    380c:	ce 15       	cp	r28, r14
    380e:	df 05       	cpc	r29, r15
    3810:	29 f6       	brne	.-118    	; 0x379c <vExternal_EEPROM_Read+0x2a>
		data++;
		byte_address++;
		vI2c_Stop();
		_delay_ms(1);
	}
}
    3812:	df 91       	pop	r29
    3814:	cf 91       	pop	r28
    3816:	1f 91       	pop	r17
    3818:	0f 91       	pop	r16
    381a:	ff 90       	pop	r15
    381c:	ef 90       	pop	r14
    381e:	df 90       	pop	r13
    3820:	08 95       	ret

00003822 <u8Get_current_MCB_number>:
		vExternal_EEPROM_Write(current_mcb+6,&checksum,1);
		vExternal_EEPROM_Write(current_mcb+7,&checksum,1);
}
//----------------------------------------------------------------set the pointer to mcb
u8 u8Get_current_MCB_number(void)
{
    3822:	cf 93       	push	r28
    3824:	df 93       	push	r29
    3826:	00 d0       	rcall	.+0      	; 0x3828 <u8Get_current_MCB_number+0x6>
    3828:	cd b7       	in	r28, 0x3d	; 61
    382a:	de b7       	in	r29, 0x3e	; 62
	u8 data1=0,data2=0;
    382c:	19 82       	std	Y+1, r1	; 0x01
    382e:	1a 82       	std	Y+2, r1	; 0x02
	vExternal_EEPROM_Read(EEPROM_CURRENT_PTR_MCB_BLOCK_NUMBER_ADDRESS,&data1,1);
    3830:	41 e0       	ldi	r20, 0x01	; 1
    3832:	be 01       	movw	r22, r28
    3834:	6f 5f       	subi	r22, 0xFF	; 255
    3836:	7f 4f       	sbci	r23, 0xFF	; 255
    3838:	81 e0       	ldi	r24, 0x01	; 1
    383a:	90 e0       	ldi	r25, 0x00	; 0
    383c:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	vExternal_EEPROM_Read(EEPROM_CURRENT_PTR_MCB_BLOCK_NUMBER_ADDRESS+1,&data2,1);
    3840:	41 e0       	ldi	r20, 0x01	; 1
    3842:	be 01       	movw	r22, r28
    3844:	6e 5f       	subi	r22, 0xFE	; 254
    3846:	7f 4f       	sbci	r23, 0xFF	; 255
    3848:	82 e0       	ldi	r24, 0x02	; 2
    384a:	90 e0       	ldi	r25, 0x00	; 0
    384c:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	if(data1 ==data2)
    3850:	89 81       	ldd	r24, Y+1	; 0x01
    3852:	9a 81       	ldd	r25, Y+2	; 0x02
    3854:	89 13       	cpse	r24, r25
	{
		return data1;
	}
	else
	{
		return 0;
    3856:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    3858:	0f 90       	pop	r0
    385a:	0f 90       	pop	r0
    385c:	df 91       	pop	r29
    385e:	cf 91       	pop	r28
    3860:	08 95       	ret

00003862 <vGet_current_MCB>:
		_delay_ms(1);
	}
}
//--------------------------------------------------------------------------------
void vGet_current_MCB(eeprom_memory_control_block_t* mcb)
{
    3862:	0f 93       	push	r16
    3864:	1f 93       	push	r17
    3866:	cf 93       	push	r28
    3868:	df 93       	push	r29
    386a:	ec 01       	movw	r28, r24
	u8 checksum=0;
	//get address of mcb
	u8 current_mcb=(u8Get_current_MCB_number())*EEPROM_FIRST_MCB;
    386c:	0e 94 11 1c 	call	0x3822	; 0x3822 <u8Get_current_MCB_number>
    3870:	08 2f       	mov	r16, r24
    3872:	00 0f       	add	r16, r16
    3874:	00 0f       	add	r16, r16
    3876:	00 0f       	add	r16, r16
	//read from address
	vExternal_EEPROM_Read(current_mcb,(u8 *)&(mcb->current_user_used_flag),4);
    3878:	44 e0       	ldi	r20, 0x04	; 4
    387a:	be 01       	movw	r22, r28
    387c:	80 2f       	mov	r24, r16
    387e:	90 e0       	ldi	r25, 0x00	; 0
    3880:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	vExternal_EEPROM_Read(current_mcb+4,(u8 *)&(mcb->write_count),2);
    3884:	10 e0       	ldi	r17, 0x00	; 0
    3886:	be 01       	movw	r22, r28
    3888:	6c 5f       	subi	r22, 0xFC	; 252
    388a:	7f 4f       	sbci	r23, 0xFF	; 255
    388c:	42 e0       	ldi	r20, 0x02	; 2
    388e:	c8 01       	movw	r24, r16
    3890:	04 96       	adiw	r24, 0x04	; 4
    3892:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	vExternal_EEPROM_Read(current_mcb+6,&(mcb->checksum),1);
    3896:	be 01       	movw	r22, r28
    3898:	6a 5f       	subi	r22, 0xFA	; 250
    389a:	7f 4f       	sbci	r23, 0xFF	; 255
    389c:	41 e0       	ldi	r20, 0x01	; 1
    389e:	c8 01       	movw	r24, r16
    38a0:	06 96       	adiw	r24, 0x06	; 6
    38a2:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	vExternal_EEPROM_Read(current_mcb+7,&(mcb->dummy),1);
    38a6:	be 01       	movw	r22, r28
    38a8:	69 5f       	subi	r22, 0xF9	; 249
    38aa:	7f 4f       	sbci	r23, 0xFF	; 255
    38ac:	41 e0       	ldi	r20, 0x01	; 1
    38ae:	c8 01       	movw	r24, r16
    38b0:	07 96       	adiw	r24, 0x07	; 7
    38b2:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	//calculate checksum
	checksum=(u8)(mcb->current_user_used_flag)+(u8)(((u32)mcb->current_user_used_flag)>>8)+
    38b6:	28 81       	ld	r18, Y
    38b8:	39 81       	ldd	r19, Y+1	; 0x01
    38ba:	8a 81       	ldd	r24, Y+2	; 0x02
    38bc:	9b 81       	ldd	r25, Y+3	; 0x03
    38be:	83 0f       	add	r24, r19
    38c0:	82 0f       	add	r24, r18
    38c2:	89 0f       	add	r24, r25
			(u8)(((u32)mcb->current_user_used_flag)>>16)+(u8)(((u32)mcb->current_user_used_flag)>>24);
	//check valid data		
	if(checksum !=mcb->checksum)
    38c4:	9e 81       	ldd	r25, Y+6	; 0x06
    38c6:	98 17       	cp	r25, r24
    38c8:	11 f0       	breq	.+4      	; 0x38ce <vGet_current_MCB+0x6c>
	{
		(mcb->dummy)=1;
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	8f 83       	std	Y+7, r24	; 0x07
	}			
}
    38ce:	df 91       	pop	r29
    38d0:	cf 91       	pop	r28
    38d2:	1f 91       	pop	r17
    38d4:	0f 91       	pop	r16
    38d6:	08 95       	ret

000038d8 <vSet_current_MCB_number>:
	{
		return 0;
	}
}
 void vSet_current_MCB_number(u8 number)
{
    38d8:	cf 93       	push	r28
    38da:	df 93       	push	r29
    38dc:	1f 92       	push	r1
    38de:	cd b7       	in	r28, 0x3d	; 61
    38e0:	de b7       	in	r29, 0x3e	; 62
    38e2:	89 83       	std	Y+1, r24	; 0x01
	vExternal_EEPROM_Write(EEPROM_CURRENT_PTR_MCB_BLOCK_NUMBER_ADDRESS,&number,1);
    38e4:	41 e0       	ldi	r20, 0x01	; 1
    38e6:	be 01       	movw	r22, r28
    38e8:	6f 5f       	subi	r22, 0xFF	; 255
    38ea:	7f 4f       	sbci	r23, 0xFF	; 255
    38ec:	81 e0       	ldi	r24, 0x01	; 1
    38ee:	90 e0       	ldi	r25, 0x00	; 0
    38f0:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
	vExternal_EEPROM_Write(EEPROM_CURRENT_PTR_MCB_BLOCK_NUMBER_ADDRESS+1,&number,1);
    38f4:	41 e0       	ldi	r20, 0x01	; 1
    38f6:	be 01       	movw	r22, r28
    38f8:	6f 5f       	subi	r22, 0xFF	; 255
    38fa:	7f 4f       	sbci	r23, 0xFF	; 255
    38fc:	82 e0       	ldi	r24, 0x02	; 2
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
}
    3904:	0f 90       	pop	r0
    3906:	df 91       	pop	r29
    3908:	cf 91       	pop	r28
    390a:	08 95       	ret

0000390c <vSet_current_MCB>:
	{
		(mcb->dummy)=1;
	}			
}
void vSet_current_MCB(eeprom_memory_control_block_t* mcb)
{
    390c:	ef 92       	push	r14
    390e:	ff 92       	push	r15
    3910:	0f 93       	push	r16
    3912:	1f 93       	push	r17
    3914:	cf 93       	push	r28
    3916:	df 93       	push	r29
    3918:	1f 92       	push	r1
    391a:	cd b7       	in	r28, 0x3d	; 61
    391c:	de b7       	in	r29, 0x3e	; 62
    391e:	8c 01       	movw	r16, r24
		u8 checksum=0;
    3920:	19 82       	std	Y+1, r1	; 0x01
		//get the current mcb
		u8 current_mcb=(u8Get_current_MCB_number());
    3922:	0e 94 11 1c 	call	0x3822	; 0x3822 <u8Get_current_MCB_number>
		//increment write count
		(mcb->write_count)++;
    3926:	f8 01       	movw	r30, r16
    3928:	24 81       	ldd	r18, Z+4	; 0x04
    392a:	35 81       	ldd	r19, Z+5	; 0x05
    392c:	2f 5f       	subi	r18, 0xFF	; 255
    392e:	3f 4f       	sbci	r19, 0xFF	; 255
    3930:	35 83       	std	Z+5, r19	; 0x05
    3932:	24 83       	std	Z+4, r18	; 0x04
		//check over flow and protect from corruption
		if((mcb->write_count) ==0xFFFE)
    3934:	2e 3f       	cpi	r18, 0xFE	; 254
    3936:	3f 4f       	sbci	r19, 0xFF	; 255
    3938:	31 f4       	brne	.+12     	; 0x3946 <vSet_current_MCB+0x3a>
			current_mcb=current_mcb+1;
			if(current_mcb ==14)
			{
				//error system failed
			}
			vSet_current_MCB_number(current_mcb);
    393a:	8f 5f       	subi	r24, 0xFF	; 255
    393c:	0e 94 6c 1c 	call	0x38d8	; 0x38d8 <vSet_current_MCB_number>
			(mcb->write_count)=0;
    3940:	f8 01       	movw	r30, r16
    3942:	15 82       	std	Z+5, r1	; 0x05
    3944:	14 82       	std	Z+4, r1	; 0x04
		}
		//get the new value of mcb
		current_mcb=(u8Get_current_MCB_number())*EEPROM_FIRST_MCB;
    3946:	0e 94 11 1c 	call	0x3822	; 0x3822 <u8Get_current_MCB_number>
    394a:	e8 2e       	mov	r14, r24
    394c:	ee 0c       	add	r14, r14
    394e:	ee 0c       	add	r14, r14
    3950:	ee 0c       	add	r14, r14
		//calculate checksum
		checksum=(u8)(mcb->current_user_used_flag)+(u8)(((u32)mcb->current_user_used_flag)>>8)
    3952:	f8 01       	movw	r30, r16
    3954:	80 81       	ld	r24, Z
    3956:	41 81       	ldd	r20, Z+1	; 0x01
    3958:	32 81       	ldd	r19, Z+2	; 0x02
    395a:	23 81       	ldd	r18, Z+3	; 0x03
				+(u8)(((u32)mcb->current_user_used_flag)>>16)+(u8)(((u32)mcb->current_user_used_flag)>>24)
				+(u8)(((u16)mcb->write_count)>>8) + (u8)(mcb->write_count);
    395c:	54 81       	ldd	r21, Z+4	; 0x04
    395e:	95 81       	ldd	r25, Z+5	; 0x05
			(mcb->write_count)=0;
		}
		//get the new value of mcb
		current_mcb=(u8Get_current_MCB_number())*EEPROM_FIRST_MCB;
		//calculate checksum
		checksum=(u8)(mcb->current_user_used_flag)+(u8)(((u32)mcb->current_user_used_flag)>>8)
    3960:	85 0f       	add	r24, r21
    3962:	84 0f       	add	r24, r20
    3964:	83 0f       	add	r24, r19
    3966:	82 0f       	add	r24, r18
    3968:	89 0f       	add	r24, r25
    396a:	89 83       	std	Y+1, r24	; 0x01
				+(u8)(((u32)mcb->current_user_used_flag)>>16)+(u8)(((u32)mcb->current_user_used_flag)>>24)
				+(u8)(((u16)mcb->write_count)>>8) + (u8)(mcb->write_count);
		//write to eeprom		
		vExternal_EEPROM_Write(current_mcb,(u8 *)&(mcb->current_user_used_flag),4);
    396c:	44 e0       	ldi	r20, 0x04	; 4
    396e:	b8 01       	movw	r22, r16
    3970:	8e 2d       	mov	r24, r14
    3972:	90 e0       	ldi	r25, 0x00	; 0
    3974:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
		vExternal_EEPROM_Write(current_mcb+4,(u8 *)&(mcb->write_count),2);
    3978:	f1 2c       	mov	r15, r1
    397a:	b8 01       	movw	r22, r16
    397c:	6c 5f       	subi	r22, 0xFC	; 252
    397e:	7f 4f       	sbci	r23, 0xFF	; 255
    3980:	42 e0       	ldi	r20, 0x02	; 2
    3982:	c7 01       	movw	r24, r14
    3984:	04 96       	adiw	r24, 0x04	; 4
    3986:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
		vExternal_EEPROM_Write(current_mcb+6,&checksum,1);
    398a:	41 e0       	ldi	r20, 0x01	; 1
    398c:	be 01       	movw	r22, r28
    398e:	6f 5f       	subi	r22, 0xFF	; 255
    3990:	7f 4f       	sbci	r23, 0xFF	; 255
    3992:	c7 01       	movw	r24, r14
    3994:	06 96       	adiw	r24, 0x06	; 6
    3996:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
		vExternal_EEPROM_Write(current_mcb+7,&checksum,1);
    399a:	41 e0       	ldi	r20, 0x01	; 1
    399c:	be 01       	movw	r22, r28
    399e:	6f 5f       	subi	r22, 0xFF	; 255
    39a0:	7f 4f       	sbci	r23, 0xFF	; 255
    39a2:	c7 01       	movw	r24, r14
    39a4:	07 96       	adiw	r24, 0x07	; 7
    39a6:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
}
    39aa:	0f 90       	pop	r0
    39ac:	df 91       	pop	r29
    39ae:	cf 91       	pop	r28
    39b0:	1f 91       	pop	r17
    39b2:	0f 91       	pop	r16
    39b4:	ff 90       	pop	r15
    39b6:	ef 90       	pop	r14
    39b8:	08 95       	ret

000039ba <add_user_in_mcb>:
}


//---------------------------------------------------------
static void add_user_in_mcb(u8 id)
{
    39ba:	1f 93       	push	r17
    39bc:	cf 93       	push	r28
    39be:	df 93       	push	r29
    39c0:	cd b7       	in	r28, 0x3d	; 61
    39c2:	de b7       	in	r29, 0x3e	; 62
    39c4:	28 97       	sbiw	r28, 0x08	; 8
    39c6:	0f b6       	in	r0, 0x3f	; 63
    39c8:	f8 94       	cli
    39ca:	de bf       	out	0x3e, r29	; 62
    39cc:	0f be       	out	0x3f, r0	; 63
    39ce:	cd bf       	out	0x3d, r28	; 61
    39d0:	18 2f       	mov	r17, r24
	eeprom_memory_control_block_t mcb;
	vGet_current_MCB(&mcb);
    39d2:	ce 01       	movw	r24, r28
    39d4:	01 96       	adiw	r24, 0x01	; 1
    39d6:	0e 94 31 1c 	call	0x3862	; 0x3862 <vGet_current_MCB>
	set_bit(mcb.current_user_used_flag,id);
    39da:	21 e0       	ldi	r18, 0x01	; 1
    39dc:	30 e0       	ldi	r19, 0x00	; 0
    39de:	a9 01       	movw	r20, r18
    39e0:	02 c0       	rjmp	.+4      	; 0x39e6 <add_user_in_mcb+0x2c>
    39e2:	44 0f       	add	r20, r20
    39e4:	55 1f       	adc	r21, r21
    39e6:	1a 95       	dec	r17
    39e8:	e2 f7       	brpl	.-8      	; 0x39e2 <add_user_in_mcb+0x28>
    39ea:	66 27       	eor	r22, r22
    39ec:	57 fd       	sbrc	r21, 7
    39ee:	60 95       	com	r22
    39f0:	76 2f       	mov	r23, r22
    39f2:	89 81       	ldd	r24, Y+1	; 0x01
    39f4:	9a 81       	ldd	r25, Y+2	; 0x02
    39f6:	ab 81       	ldd	r26, Y+3	; 0x03
    39f8:	bc 81       	ldd	r27, Y+4	; 0x04
    39fa:	84 2b       	or	r24, r20
    39fc:	95 2b       	or	r25, r21
    39fe:	a6 2b       	or	r26, r22
    3a00:	b7 2b       	or	r27, r23
    3a02:	89 83       	std	Y+1, r24	; 0x01
    3a04:	9a 83       	std	Y+2, r25	; 0x02
    3a06:	ab 83       	std	Y+3, r26	; 0x03
    3a08:	bc 83       	std	Y+4, r27	; 0x04
	vSet_current_MCB(&mcb);
    3a0a:	ce 01       	movw	r24, r28
    3a0c:	01 96       	adiw	r24, 0x01	; 1
    3a0e:	0e 94 86 1c 	call	0x390c	; 0x390c <vSet_current_MCB>
}
    3a12:	28 96       	adiw	r28, 0x08	; 8
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	f8 94       	cli
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	0f be       	out	0x3f, r0	; 63
    3a1c:	cd bf       	out	0x3d, r28	; 61
    3a1e:	df 91       	pop	r29
    3a20:	cf 91       	pop	r28
    3a22:	1f 91       	pop	r17
    3a24:	08 95       	ret

00003a26 <vEXTERNAL_EEPROM_set_user>:
	
}
//--------------------------------------------------------
//set user data with id
void vEXTERNAL_EEPROM_set_user(user_t * user,u8 id)
{
    3a26:	ef 92       	push	r14
    3a28:	ff 92       	push	r15
    3a2a:	0f 93       	push	r16
    3a2c:	1f 93       	push	r17
    3a2e:	cf 93       	push	r28
    3a30:	df 93       	push	r29
    3a32:	1f 92       	push	r1
    3a34:	cd b7       	in	r28, 0x3d	; 61
    3a36:	de b7       	in	r29, 0x3e	; 62
    3a38:	8c 01       	movw	r16, r24
	//calculate checksum
	u8 checksum=0;
	u16 address;
	checksum=user->name[0]+user->name[1]+user->name[2]+user->name[3]+user->name[4]+user->name[5]+user->name[6]+user->name[7]+user->name[8]+user->name[9]
    3a3a:	fc 01       	movw	r30, r24
    3a3c:	91 81       	ldd	r25, Z+1	; 0x01
    3a3e:	80 81       	ld	r24, Z
    3a40:	89 0f       	add	r24, r25
    3a42:	92 81       	ldd	r25, Z+2	; 0x02
    3a44:	89 0f       	add	r24, r25
    3a46:	93 81       	ldd	r25, Z+3	; 0x03
    3a48:	89 0f       	add	r24, r25
    3a4a:	94 81       	ldd	r25, Z+4	; 0x04
    3a4c:	89 0f       	add	r24, r25
    3a4e:	95 81       	ldd	r25, Z+5	; 0x05
    3a50:	89 0f       	add	r24, r25
    3a52:	96 81       	ldd	r25, Z+6	; 0x06
    3a54:	89 0f       	add	r24, r25
    3a56:	97 81       	ldd	r25, Z+7	; 0x07
    3a58:	89 0f       	add	r24, r25
    3a5a:	90 85       	ldd	r25, Z+8	; 0x08
    3a5c:	89 0f       	add	r24, r25
    3a5e:	91 85       	ldd	r25, Z+9	; 0x09
    3a60:	89 0f       	add	r24, r25
    3a62:	92 85       	ldd	r25, Z+10	; 0x0a
    3a64:	89 0f       	add	r24, r25
    3a66:	93 85       	ldd	r25, Z+11	; 0x0b
    3a68:	89 0f       	add	r24, r25
    3a6a:	94 85       	ldd	r25, Z+12	; 0x0c
    3a6c:	89 0f       	add	r24, r25
    3a6e:	95 85       	ldd	r25, Z+13	; 0x0d
    3a70:	89 0f       	add	r24, r25
    3a72:	96 85       	ldd	r25, Z+14	; 0x0e
    3a74:	89 0f       	add	r24, r25
    3a76:	89 83       	std	Y+1, r24	; 0x01
				+user->password[0]+user->password[1]+user->password[2]+user->password[3]+user->type;
	
	address=EEPROM_FIRST_USER+(id *sizeof(user_t));	
    3a78:	e6 2e       	mov	r14, r22
    3a7a:	f1 2c       	mov	r15, r1
    3a7c:	f7 e0       	ldi	r31, 0x07	; 7
    3a7e:	ef 0e       	add	r14, r31
    3a80:	f1 1c       	adc	r15, r1
    3a82:	ee 0c       	add	r14, r14
    3a84:	ff 1c       	adc	r15, r15
    3a86:	ee 0c       	add	r14, r14
    3a88:	ff 1c       	adc	r15, r15
    3a8a:	ee 0c       	add	r14, r14
    3a8c:	ff 1c       	adc	r15, r15
    3a8e:	ee 0c       	add	r14, r14
    3a90:	ff 1c       	adc	r15, r15
	//save in eeprom
		vExternal_EEPROM_Write(address,(u8 *)&(user->name),10);
    3a92:	4a e0       	ldi	r20, 0x0A	; 10
    3a94:	b8 01       	movw	r22, r16
    3a96:	c7 01       	movw	r24, r14
    3a98:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
		vExternal_EEPROM_Write(address+10,(u8 *)&(user->password),4);
    3a9c:	b8 01       	movw	r22, r16
    3a9e:	66 5f       	subi	r22, 0xF6	; 246
    3aa0:	7f 4f       	sbci	r23, 0xFF	; 255
    3aa2:	44 e0       	ldi	r20, 0x04	; 4
    3aa4:	c7 01       	movw	r24, r14
    3aa6:	0a 96       	adiw	r24, 0x0a	; 10
    3aa8:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
		vExternal_EEPROM_Write(address+14,&(user->type),1);
    3aac:	b8 01       	movw	r22, r16
    3aae:	62 5f       	subi	r22, 0xF2	; 242
    3ab0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ab2:	41 e0       	ldi	r20, 0x01	; 1
    3ab4:	c7 01       	movw	r24, r14
    3ab6:	0e 96       	adiw	r24, 0x0e	; 14
    3ab8:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
		vExternal_EEPROM_Write(address+15,&checksum,1);
    3abc:	41 e0       	ldi	r20, 0x01	; 1
    3abe:	be 01       	movw	r22, r28
    3ac0:	6f 5f       	subi	r22, 0xFF	; 255
    3ac2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ac4:	c7 01       	movw	r24, r14
    3ac6:	0f 96       	adiw	r24, 0x0f	; 15
    3ac8:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>

}
    3acc:	0f 90       	pop	r0
    3ace:	df 91       	pop	r29
    3ad0:	cf 91       	pop	r28
    3ad2:	1f 91       	pop	r17
    3ad4:	0f 91       	pop	r16
    3ad6:	ff 90       	pop	r15
    3ad8:	ef 90       	pop	r14
    3ada:	08 95       	ret

00003adc <u8Init_MCB>:
	vExternal_EEPROM_Write(EEPROM_CURRENT_PTR_MCB_BLOCK_NUMBER_ADDRESS,&number,1);
	vExternal_EEPROM_Write(EEPROM_CURRENT_PTR_MCB_BLOCK_NUMBER_ADDRESS+1,&number,1);
}
//----------------------------------------------------------------------
u8 u8Init_MCB(void)
{
    3adc:	cf 93       	push	r28
    3ade:	df 93       	push	r29
    3ae0:	1f 92       	push	r1
    3ae2:	cd b7       	in	r28, 0x3d	; 61
    3ae4:	de b7       	in	r29, 0x3e	; 62
	u8 first_check=00;
    3ae6:	19 82       	std	Y+1, r1	; 0x01
	
	
	//read first byte if not 0xFF
	vExternal_EEPROM_Read(0,&first_check,1);
    3ae8:	41 e0       	ldi	r20, 0x01	; 1
    3aea:	be 01       	movw	r22, r28
    3aec:	6f 5f       	subi	r22, 0xFF	; 255
    3aee:	7f 4f       	sbci	r23, 0xFF	; 255
    3af0:	80 e0       	ldi	r24, 0x00	; 0
    3af2:	90 e0       	ldi	r25, 0x00	; 0
    3af4:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	if (first_check !=MAGIC_NUMBER)
    3af8:	89 81       	ldd	r24, Y+1	; 0x01
    3afa:	8a 3a       	cpi	r24, 0xAA	; 170
    3afc:	f1 f0       	breq	.+60     	; 0x3b3a <u8Init_MCB+0x5e>
	{	
		//set flag to magic number
		first_check=MAGIC_NUMBER;
    3afe:	8a ea       	ldi	r24, 0xAA	; 170
    3b00:	89 83       	std	Y+1, r24	; 0x01
		vExternal_EEPROM_Write(0,&first_check,1);
    3b02:	41 e0       	ldi	r20, 0x01	; 1
    3b04:	be 01       	movw	r22, r28
    3b06:	6f 5f       	subi	r22, 0xFF	; 255
    3b08:	7f 4f       	sbci	r23, 0xFF	; 255
    3b0a:	80 e0       	ldi	r24, 0x00	; 0
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
		//set control block to first block
		vSet_current_MCB_number(FIRST_MCB_NUMBER);
    3b12:	81 e0       	ldi	r24, 0x01	; 1
    3b14:	0e 94 6c 1c 	call	0x38d8	; 0x38d8 <vSet_current_MCB_number>
		//set current mcb value
		vSet_current_MCB((eeprom_memory_control_block_t*)&g_init_mcb);
    3b18:	85 e1       	ldi	r24, 0x15	; 21
    3b1a:	91 e0       	ldi	r25, 0x01	; 1
    3b1c:	0e 94 86 1c 	call	0x390c	; 0x390c <vSet_current_MCB>
		//add user in block
		add_user_in_mcb(FIRST_USER_ID);
    3b20:	80 e0       	ldi	r24, 0x00	; 0
    3b22:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <add_user_in_mcb>
		//add user in memory
		vEXTERNAL_EEPROM_set_user((user_t *)&g_root_user,FIRST_USER_ID);
    3b26:	60 e0       	ldi	r22, 0x00	; 0
    3b28:	8d e1       	ldi	r24, 0x1D	; 29
    3b2a:	91 e0       	ldi	r25, 0x01	; 1
    3b2c:	0e 94 13 1d 	call	0x3a26	; 0x3a26 <vEXTERNAL_EEPROM_set_user>
		//set state of terminal task to factory reset
		vSet_terminal_task_state(TERMINAL_TASK_FACTORY_STATE);
    3b30:	80 e0       	ldi	r24, 0x00	; 0
    3b32:	0e 94 85 11 	call	0x230a	; 0x230a <vSet_terminal_task_state>
		return EEPROM_FIRST_TIME_INIT;
    3b36:	81 e0       	ldi	r24, 0x01	; 1
    3b38:	0e c0       	rjmp	.+28     	; 0x3b56 <u8Init_MCB+0x7a>
	}
	else
	{
		//check if locked or not
		vExternal_EEPROM_Read(LOCKED_STATE_ADDRESS,&first_check,1);
    3b3a:	41 e0       	ldi	r20, 0x01	; 1
    3b3c:	be 01       	movw	r22, r28
    3b3e:	6f 5f       	subi	r22, 0xFF	; 255
    3b40:	7f 4f       	sbci	r23, 0xFF	; 255
    3b42:	84 e0       	ldi	r24, 0x04	; 4
    3b44:	90 e0       	ldi	r25, 0x00	; 0
    3b46:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
		if(first_check ==MAGIC_NUMBER) 
    3b4a:	89 81       	ldd	r24, Y+1	; 0x01
    3b4c:	8a 3a       	cpi	r24, 0xAA	; 170
    3b4e:	11 f4       	brne	.+4      	; 0x3b54 <u8Init_MCB+0x78>
		{
			//locked
			return EEPROM_LOCKED_MC_STATE;
    3b50:	82 e0       	ldi	r24, 0x02	; 2
    3b52:	01 c0       	rjmp	.+2      	; 0x3b56 <u8Init_MCB+0x7a>
		}
		else
		{
			return EEPROM_ALREADY_INIT;
    3b54:	80 e0       	ldi	r24, 0x00	; 0
		}
		
	}
	
}
    3b56:	0f 90       	pop	r0
    3b58:	df 91       	pop	r29
    3b5a:	cf 91       	pop	r28
    3b5c:	08 95       	ret

00003b5e <vEXTERNAL_EEPROM_get_user>:

}
//-----------------------------------------------------------
//get user data with id
void vEXTERNAL_EEPROM_get_user(user_t * user,u8 id)
{
    3b5e:	0f 93       	push	r16
    3b60:	1f 93       	push	r17
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	8c 01       	movw	r16, r24
	u8 checksum=0;
	u16 address;	
	address=EEPROM_FIRST_USER+(id *sizeof(user_t));
    3b68:	c6 2f       	mov	r28, r22
    3b6a:	d0 e0       	ldi	r29, 0x00	; 0
    3b6c:	27 96       	adiw	r28, 0x07	; 7
    3b6e:	c2 95       	swap	r28
    3b70:	d2 95       	swap	r29
    3b72:	d0 7f       	andi	r29, 0xF0	; 240
    3b74:	dc 27       	eor	r29, r28
    3b76:	c0 7f       	andi	r28, 0xF0	; 240
    3b78:	dc 27       	eor	r29, r28
	//save in eeprom
	vExternal_EEPROM_Read(address,(u8 *)&(user->name),10);
    3b7a:	4a e0       	ldi	r20, 0x0A	; 10
    3b7c:	bc 01       	movw	r22, r24
    3b7e:	ce 01       	movw	r24, r28
    3b80:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	vExternal_EEPROM_Read(address+10,(u8 *)&(user->password),4);
    3b84:	b8 01       	movw	r22, r16
    3b86:	66 5f       	subi	r22, 0xF6	; 246
    3b88:	7f 4f       	sbci	r23, 0xFF	; 255
    3b8a:	44 e0       	ldi	r20, 0x04	; 4
    3b8c:	ce 01       	movw	r24, r28
    3b8e:	0a 96       	adiw	r24, 0x0a	; 10
    3b90:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	vExternal_EEPROM_Read(address+14,&(user->type),1);
    3b94:	b8 01       	movw	r22, r16
    3b96:	62 5f       	subi	r22, 0xF2	; 242
    3b98:	7f 4f       	sbci	r23, 0xFF	; 255
    3b9a:	41 e0       	ldi	r20, 0x01	; 1
    3b9c:	ce 01       	movw	r24, r28
    3b9e:	0e 96       	adiw	r24, 0x0e	; 14
    3ba0:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
	vExternal_EEPROM_Read(address+15,&(user->checksum),1);
    3ba4:	b8 01       	movw	r22, r16
    3ba6:	61 5f       	subi	r22, 0xF1	; 241
    3ba8:	7f 4f       	sbci	r23, 0xFF	; 255
    3baa:	41 e0       	ldi	r20, 0x01	; 1
    3bac:	ce 01       	movw	r24, r28
    3bae:	0f 96       	adiw	r24, 0x0f	; 15
    3bb0:	0e 94 b9 1b 	call	0x3772	; 0x3772 <vExternal_EEPROM_Read>
				+user->password[0]+user->password[1]+user->password[2]+user->password[3]+user->type;
	if(user->checksum !=checksum)
	{
		//error data corrupted
	}
}
    3bb4:	df 91       	pop	r29
    3bb6:	cf 91       	pop	r28
    3bb8:	1f 91       	pop	r17
    3bba:	0f 91       	pop	r16
    3bbc:	08 95       	ret

00003bbe <u8EXTERNAL_EEPROM_search_by_name>:
//-----------------------------------------------------------------
u8 u8EXTERNAL_EEPROM_search_by_name(unsigned char * name)
{
    3bbe:	bf 92       	push	r11
    3bc0:	cf 92       	push	r12
    3bc2:	df 92       	push	r13
    3bc4:	ef 92       	push	r14
    3bc6:	ff 92       	push	r15
    3bc8:	0f 93       	push	r16
    3bca:	1f 93       	push	r17
    3bcc:	cf 93       	push	r28
    3bce:	df 93       	push	r29
    3bd0:	cd b7       	in	r28, 0x3d	; 61
    3bd2:	de b7       	in	r29, 0x3e	; 62
    3bd4:	68 97       	sbiw	r28, 0x18	; 24
    3bd6:	0f b6       	in	r0, 0x3f	; 63
    3bd8:	f8 94       	cli
    3bda:	de bf       	out	0x3e, r29	; 62
    3bdc:	0f be       	out	0x3f, r0	; 63
    3bde:	cd bf       	out	0x3d, r28	; 61
    3be0:	7c 01       	movw	r14, r24
	u8 index=0;
	u8 result=0;
	user_t user;
	eeprom_memory_control_block_t memory;
	vGet_current_MCB(&memory);
    3be2:	ce 01       	movw	r24, r28
    3be4:	41 96       	adiw	r24, 0x11	; 17
    3be6:	0e 94 31 1c 	call	0x3862	; 0x3862 <vGet_current_MCB>
    3bea:	00 e0       	ldi	r16, 0x00	; 0
    3bec:	10 e0       	ldi	r17, 0x00	; 0
	//get current mcb
	
	for(index=0;index<EEPROM_MAX_USER;index++)
	{
		if(check_bit(memory.current_user_used_flag,index)== 1)
    3bee:	cc 24       	eor	r12, r12
    3bf0:	c3 94       	inc	r12
    3bf2:	d1 2c       	mov	r13, r1
    3bf4:	b0 2e       	mov	r11, r16
    3bf6:	a6 01       	movw	r20, r12
    3bf8:	00 2e       	mov	r0, r16
    3bfa:	02 c0       	rjmp	.+4      	; 0x3c00 <u8EXTERNAL_EEPROM_search_by_name+0x42>
    3bfc:	44 0f       	add	r20, r20
    3bfe:	55 1f       	adc	r21, r21
    3c00:	0a 94       	dec	r0
    3c02:	e2 f7       	brpl	.-8      	; 0x3bfc <u8EXTERNAL_EEPROM_search_by_name+0x3e>
    3c04:	66 27       	eor	r22, r22
    3c06:	57 fd       	sbrc	r21, 7
    3c08:	60 95       	com	r22
    3c0a:	76 2f       	mov	r23, r22
    3c0c:	89 89       	ldd	r24, Y+17	; 0x11
    3c0e:	9a 89       	ldd	r25, Y+18	; 0x12
    3c10:	ab 89       	ldd	r26, Y+19	; 0x13
    3c12:	bc 89       	ldd	r27, Y+20	; 0x14
    3c14:	48 23       	and	r20, r24
    3c16:	59 23       	and	r21, r25
    3c18:	6a 23       	and	r22, r26
    3c1a:	7b 23       	and	r23, r27
    3c1c:	00 2e       	mov	r0, r16
    3c1e:	04 c0       	rjmp	.+8      	; 0x3c28 <u8EXTERNAL_EEPROM_search_by_name+0x6a>
    3c20:	76 95       	lsr	r23
    3c22:	67 95       	ror	r22
    3c24:	57 95       	ror	r21
    3c26:	47 95       	ror	r20
    3c28:	0a 94       	dec	r0
    3c2a:	d2 f7       	brpl	.-12     	; 0x3c20 <u8EXTERNAL_EEPROM_search_by_name+0x62>
    3c2c:	41 30       	cpi	r20, 0x01	; 1
    3c2e:	51 05       	cpc	r21, r1
    3c30:	61 05       	cpc	r22, r1
    3c32:	71 05       	cpc	r23, r1
    3c34:	61 f4       	brne	.+24     	; 0x3c4e <u8EXTERNAL_EEPROM_search_by_name+0x90>
		{
			vEXTERNAL_EEPROM_get_user(&user,index);
    3c36:	60 2f       	mov	r22, r16
    3c38:	ce 01       	movw	r24, r28
    3c3a:	01 96       	adiw	r24, 0x01	; 1
    3c3c:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <vEXTERNAL_EEPROM_get_user>
			//check name
			result=strcmp((const char *)user.name,(const char *)name);
    3c40:	b7 01       	movw	r22, r14
    3c42:	ce 01       	movw	r24, r28
    3c44:	01 96       	adiw	r24, 0x01	; 1
    3c46:	0e 94 ff 35 	call	0x6bfe	; 0x6bfe <strcmp>
			if(result ==0)
    3c4a:	88 23       	and	r24, r24
    3c4c:	39 f0       	breq	.+14     	; 0x3c5c <u8EXTERNAL_EEPROM_search_by_name+0x9e>
    3c4e:	0f 5f       	subi	r16, 0xFF	; 255
    3c50:	1f 4f       	sbci	r17, 0xFF	; 255
	user_t user;
	eeprom_memory_control_block_t memory;
	vGet_current_MCB(&memory);
	//get current mcb
	
	for(index=0;index<EEPROM_MAX_USER;index++)
    3c52:	09 31       	cpi	r16, 0x19	; 25
    3c54:	11 05       	cpc	r17, r1
    3c56:	71 f6       	brne	.-100    	; 0x3bf4 <u8EXTERNAL_EEPROM_search_by_name+0x36>
			{
				return index;
			}
		}
	}
	return USER_NAME_NOT_FOUND;
    3c58:	bb 24       	eor	r11, r11
    3c5a:	ba 94       	dec	r11
}
    3c5c:	8b 2d       	mov	r24, r11
    3c5e:	68 96       	adiw	r28, 0x18	; 24
    3c60:	0f b6       	in	r0, 0x3f	; 63
    3c62:	f8 94       	cli
    3c64:	de bf       	out	0x3e, r29	; 62
    3c66:	0f be       	out	0x3f, r0	; 63
    3c68:	cd bf       	out	0x3d, r28	; 61
    3c6a:	df 91       	pop	r29
    3c6c:	cf 91       	pop	r28
    3c6e:	1f 91       	pop	r17
    3c70:	0f 91       	pop	r16
    3c72:	ff 90       	pop	r15
    3c74:	ef 90       	pop	r14
    3c76:	df 90       	pop	r13
    3c78:	cf 90       	pop	r12
    3c7a:	bf 90       	pop	r11
    3c7c:	08 95       	ret

00003c7e <u8EXTERNAL_EEPROM_search_by_password>:
//-------------------------------------------------------------------------
u8 u8EXTERNAL_EEPROM_search_by_password(unsigned char * password,unsigned char* name,u8 * id,u8 * type)
{
    3c7e:	2f 92       	push	r2
    3c80:	3f 92       	push	r3
    3c82:	4f 92       	push	r4
    3c84:	5f 92       	push	r5
    3c86:	6f 92       	push	r6
    3c88:	7f 92       	push	r7
    3c8a:	8f 92       	push	r8
    3c8c:	9f 92       	push	r9
    3c8e:	af 92       	push	r10
    3c90:	bf 92       	push	r11
    3c92:	cf 92       	push	r12
    3c94:	df 92       	push	r13
    3c96:	ef 92       	push	r14
    3c98:	ff 92       	push	r15
    3c9a:	0f 93       	push	r16
    3c9c:	1f 93       	push	r17
    3c9e:	cf 93       	push	r28
    3ca0:	df 93       	push	r29
    3ca2:	cd b7       	in	r28, 0x3d	; 61
    3ca4:	de b7       	in	r29, 0x3e	; 62
    3ca6:	6a 97       	sbiw	r28, 0x1a	; 26
    3ca8:	0f b6       	in	r0, 0x3f	; 63
    3caa:	f8 94       	cli
    3cac:	de bf       	out	0x3e, r29	; 62
    3cae:	0f be       	out	0x3f, r0	; 63
    3cb0:	cd bf       	out	0x3d, r28	; 61
    3cb2:	48 2e       	mov	r4, r24
    3cb4:	59 2e       	mov	r5, r25
    3cb6:	36 2e       	mov	r3, r22
    3cb8:	27 2e       	mov	r2, r23
    3cba:	4a 01       	movw	r8, r20
    3cbc:	3a 8f       	std	Y+26, r19	; 0x1a
    3cbe:	29 8f       	std	Y+25, r18	; 0x19
	u8 index=0,index2=0;
	u8 result=0;
	user_t user;
	eeprom_memory_control_block_t memory;
	//get current mcb
	vGet_current_MCB(&memory);
    3cc0:	ce 01       	movw	r24, r28
    3cc2:	41 96       	adiw	r24, 0x11	; 17
    3cc4:	0e 94 31 1c 	call	0x3862	; 0x3862 <vGet_current_MCB>
    3cc8:	00 e0       	ldi	r16, 0x00	; 0
    3cca:	10 e0       	ldi	r17, 0x00	; 0
	for(index=0;index<EEPROM_MAX_USER;index++)
	{
		if(check_bit(memory.current_user_used_flag,index)== 1)
    3ccc:	ee 24       	eor	r14, r14
    3cce:	e3 94       	inc	r14
    3cd0:	f1 2c       	mov	r15, r1
		{
			vEXTERNAL_EEPROM_get_user(&user,index);
    3cd2:	aa 24       	eor	r10, r10
    3cd4:	a3 94       	inc	r10
    3cd6:	b1 2c       	mov	r11, r1
    3cd8:	ac 0e       	add	r10, r28
    3cda:	bd 1e       	adc	r11, r29
		}
	}
	return USER_NAME_NOT_FOUND;
}
//-------------------------------------------------------------------------
u8 u8EXTERNAL_EEPROM_search_by_password(unsigned char * password,unsigned char* name,u8 * id,u8 * type)
    3cdc:	6e 01       	movw	r12, r28
    3cde:	8f e0       	ldi	r24, 0x0F	; 15
    3ce0:	c8 0e       	add	r12, r24
    3ce2:	d1 1c       	adc	r13, r1
    3ce4:	61 2c       	mov	r6, r1
    3ce6:	70 2e       	mov	r7, r16
	eeprom_memory_control_block_t memory;
	//get current mcb
	vGet_current_MCB(&memory);
	for(index=0;index<EEPROM_MAX_USER;index++)
	{
		if(check_bit(memory.current_user_used_flag,index)== 1)
    3ce8:	c7 01       	movw	r24, r14
    3cea:	00 2e       	mov	r0, r16
    3cec:	02 c0       	rjmp	.+4      	; 0x3cf2 <u8EXTERNAL_EEPROM_search_by_password+0x74>
    3cee:	88 0f       	add	r24, r24
    3cf0:	99 1f       	adc	r25, r25
    3cf2:	0a 94       	dec	r0
    3cf4:	e2 f7       	brpl	.-8      	; 0x3cee <u8EXTERNAL_EEPROM_search_by_password+0x70>
    3cf6:	aa 27       	eor	r26, r26
    3cf8:	97 fd       	sbrc	r25, 7
    3cfa:	a0 95       	com	r26
    3cfc:	ba 2f       	mov	r27, r26
    3cfe:	49 89       	ldd	r20, Y+17	; 0x11
    3d00:	5a 89       	ldd	r21, Y+18	; 0x12
    3d02:	6b 89       	ldd	r22, Y+19	; 0x13
    3d04:	7c 89       	ldd	r23, Y+20	; 0x14
    3d06:	84 23       	and	r24, r20
    3d08:	95 23       	and	r25, r21
    3d0a:	a6 23       	and	r26, r22
    3d0c:	b7 23       	and	r27, r23
    3d0e:	00 2e       	mov	r0, r16
    3d10:	04 c0       	rjmp	.+8      	; 0x3d1a <u8EXTERNAL_EEPROM_search_by_password+0x9c>
    3d12:	b6 95       	lsr	r27
    3d14:	a7 95       	ror	r26
    3d16:	97 95       	ror	r25
    3d18:	87 95       	ror	r24
    3d1a:	0a 94       	dec	r0
    3d1c:	d2 f7       	brpl	.-12     	; 0x3d12 <u8EXTERNAL_EEPROM_search_by_password+0x94>
    3d1e:	01 97       	sbiw	r24, 0x01	; 1
    3d20:	a1 05       	cpc	r26, r1
    3d22:	b1 05       	cpc	r27, r1
    3d24:	29 f5       	brne	.+74     	; 0x3d70 <u8EXTERNAL_EEPROM_search_by_password+0xf2>
		{
			vEXTERNAL_EEPROM_get_user(&user,index);
    3d26:	60 2f       	mov	r22, r16
    3d28:	c5 01       	movw	r24, r10
    3d2a:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <vEXTERNAL_EEPROM_get_user>
    3d2e:	fe 01       	movw	r30, r28
    3d30:	3b 96       	adiw	r30, 0x0b	; 11
    3d32:	a4 2d       	mov	r26, r4
    3d34:	b5 2d       	mov	r27, r5
		}
	}
	return USER_NAME_NOT_FOUND;
}
//-------------------------------------------------------------------------
u8 u8EXTERNAL_EEPROM_search_by_password(unsigned char * password,unsigned char* name,u8 * id,u8 * type)
    3d36:	c5 01       	movw	r24, r10
    3d38:	46 2d       	mov	r20, r6
		{
			vEXTERNAL_EEPROM_get_user(&user,index);
			//check password
			for(index2=0;index2<MAX_USER_PASSWORD;index2++)
			{
				if(user.password[index2] != password[index2])
    3d3a:	31 91       	ld	r19, Z+
    3d3c:	2d 91       	ld	r18, X+
    3d3e:	32 13       	cpse	r19, r18
				{
					result++;
    3d40:	4f 5f       	subi	r20, 0xFF	; 255
	{
		if(check_bit(memory.current_user_used_flag,index)== 1)
		{
			vEXTERNAL_EEPROM_get_user(&user,index);
			//check password
			for(index2=0;index2<MAX_USER_PASSWORD;index2++)
    3d42:	ec 15       	cp	r30, r12
    3d44:	fd 05       	cpc	r31, r13
    3d46:	c9 f7       	brne	.-14     	; 0x3d3a <u8EXTERNAL_EEPROM_search_by_password+0xbc>
				{
					result++;
				}
				
			}
			if(result ==0)
    3d48:	41 11       	cpse	r20, r1
    3d4a:	12 c0       	rjmp	.+36     	; 0x3d70 <u8EXTERNAL_EEPROM_search_by_password+0xf2>
			{
				*id= index;
    3d4c:	f4 01       	movw	r30, r8
    3d4e:	70 82       	st	Z, r7
				*type=user.type;
    3d50:	2f 85       	ldd	r18, Y+15	; 0x0f
    3d52:	e9 8d       	ldd	r30, Y+25	; 0x19
    3d54:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3d56:	20 83       	st	Z, r18
    3d58:	fe 01       	movw	r30, r28
    3d5a:	31 96       	adiw	r30, 0x01	; 1
    3d5c:	a3 2d       	mov	r26, r3
    3d5e:	b2 2d       	mov	r27, r2
		}
	}
	return USER_NAME_NOT_FOUND;
}
//-------------------------------------------------------------------------
u8 u8EXTERNAL_EEPROM_search_by_password(unsigned char * password,unsigned char* name,u8 * id,u8 * type)
    3d60:	09 96       	adiw	r24, 0x09	; 9
			{
				*id= index;
				*type=user.type;
				for(index2=0;index2<MAX_USER_NAME;index2++)
				{
					name[index2]=user.name[index2];
    3d62:	21 91       	ld	r18, Z+
    3d64:	2d 93       	st	X+, r18
			}
			if(result ==0)
			{
				*id= index;
				*type=user.type;
				for(index2=0;index2<MAX_USER_NAME;index2++)
    3d66:	e8 17       	cp	r30, r24
    3d68:	f9 07       	cpc	r31, r25
    3d6a:	d9 f7       	brne	.-10     	; 0x3d62 <u8EXTERNAL_EEPROM_search_by_password+0xe4>
				{
					name[index2]=user.name[index2];
				}
				return PASSWORD_FOUND;
    3d6c:	80 e0       	ldi	r24, 0x00	; 0
    3d6e:	07 c0       	rjmp	.+14     	; 0x3d7e <u8EXTERNAL_EEPROM_search_by_password+0x100>
    3d70:	0f 5f       	subi	r16, 0xFF	; 255
    3d72:	1f 4f       	sbci	r17, 0xFF	; 255
	u8 result=0;
	user_t user;
	eeprom_memory_control_block_t memory;
	//get current mcb
	vGet_current_MCB(&memory);
	for(index=0;index<EEPROM_MAX_USER;index++)
    3d74:	09 31       	cpi	r16, 0x19	; 25
    3d76:	11 05       	cpc	r17, r1
    3d78:	09 f0       	breq	.+2      	; 0x3d7c <u8EXTERNAL_EEPROM_search_by_password+0xfe>
    3d7a:	b5 cf       	rjmp	.-150    	; 0x3ce6 <u8EXTERNAL_EEPROM_search_by_password+0x68>
			}
			
		}
		result=0;
	}
	return PASSWORD_NOT_FOUND;
    3d7c:	8f ef       	ldi	r24, 0xFF	; 255
}
    3d7e:	6a 96       	adiw	r28, 0x1a	; 26
    3d80:	0f b6       	in	r0, 0x3f	; 63
    3d82:	f8 94       	cli
    3d84:	de bf       	out	0x3e, r29	; 62
    3d86:	0f be       	out	0x3f, r0	; 63
    3d88:	cd bf       	out	0x3d, r28	; 61
    3d8a:	df 91       	pop	r29
    3d8c:	cf 91       	pop	r28
    3d8e:	1f 91       	pop	r17
    3d90:	0f 91       	pop	r16
    3d92:	ff 90       	pop	r15
    3d94:	ef 90       	pop	r14
    3d96:	df 90       	pop	r13
    3d98:	cf 90       	pop	r12
    3d9a:	bf 90       	pop	r11
    3d9c:	af 90       	pop	r10
    3d9e:	9f 90       	pop	r9
    3da0:	8f 90       	pop	r8
    3da2:	7f 90       	pop	r7
    3da4:	6f 90       	pop	r6
    3da6:	5f 90       	pop	r5
    3da8:	4f 90       	pop	r4
    3daa:	3f 90       	pop	r3
    3dac:	2f 90       	pop	r2
    3dae:	08 95       	ret

00003db0 <u8EXTERNAL_EEPROM_add_new_user>:
//---------------------------------------------------
u8 u8EXTERNAL_EEPROM_add_new_user(user_t * user)
{
    3db0:	ff 92       	push	r15
    3db2:	0f 93       	push	r16
    3db4:	1f 93       	push	r17
    3db6:	cf 93       	push	r28
    3db8:	df 93       	push	r29
    3dba:	cd b7       	in	r28, 0x3d	; 61
    3dbc:	de b7       	in	r29, 0x3e	; 62
    3dbe:	28 97       	sbiw	r28, 0x08	; 8
    3dc0:	0f b6       	in	r0, 0x3f	; 63
    3dc2:	f8 94       	cli
    3dc4:	de bf       	out	0x3e, r29	; 62
    3dc6:	0f be       	out	0x3f, r0	; 63
    3dc8:	cd bf       	out	0x3d, r28	; 61
    3dca:	8c 01       	movw	r16, r24
	
	u8 index=0;
	u8 available_user=NO_AVAILABLE_USER;
	eeprom_memory_control_block_t memory;
	//get current mcb
	vGet_current_MCB(&memory);
    3dcc:	ce 01       	movw	r24, r28
    3dce:	01 96       	adiw	r24, 0x01	; 1
    3dd0:	0e 94 31 1c 	call	0x3862	; 0x3862 <vGet_current_MCB>
	//check for available user id
	for(index=0;index<EEPROM_MAX_USER;index++)
	{
		if(check_bit(memory.current_user_used_flag,index)== 0)
    3dd4:	89 81       	ldd	r24, Y+1	; 0x01
    3dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    3dd8:	ab 81       	ldd	r26, Y+3	; 0x03
    3dda:	bc 81       	ldd	r27, Y+4	; 0x04
    3ddc:	80 ff       	sbrs	r24, 0
    3dde:	2c c0       	rjmp	.+88     	; 0x3e38 <u8EXTERNAL_EEPROM_add_new_user+0x88>
    3de0:	21 e0       	ldi	r18, 0x01	; 1
    3de2:	30 e0       	ldi	r19, 0x00	; 0
    3de4:	e1 e0       	ldi	r30, 0x01	; 1
    3de6:	f0 e0       	ldi	r31, 0x00	; 0
    3de8:	f2 2e       	mov	r15, r18
    3dea:	af 01       	movw	r20, r30
    3dec:	02 2e       	mov	r0, r18
    3dee:	02 c0       	rjmp	.+4      	; 0x3df4 <u8EXTERNAL_EEPROM_add_new_user+0x44>
    3df0:	44 0f       	add	r20, r20
    3df2:	55 1f       	adc	r21, r21
    3df4:	0a 94       	dec	r0
    3df6:	e2 f7       	brpl	.-8      	; 0x3df0 <u8EXTERNAL_EEPROM_add_new_user+0x40>
    3df8:	66 27       	eor	r22, r22
    3dfa:	57 fd       	sbrc	r21, 7
    3dfc:	60 95       	com	r22
    3dfe:	76 2f       	mov	r23, r22
    3e00:	48 23       	and	r20, r24
    3e02:	59 23       	and	r21, r25
    3e04:	6a 23       	and	r22, r26
    3e06:	7b 23       	and	r23, r27
    3e08:	02 2e       	mov	r0, r18
    3e0a:	04 c0       	rjmp	.+8      	; 0x3e14 <u8EXTERNAL_EEPROM_add_new_user+0x64>
    3e0c:	76 95       	lsr	r23
    3e0e:	67 95       	ror	r22
    3e10:	57 95       	ror	r21
    3e12:	47 95       	ror	r20
    3e14:	0a 94       	dec	r0
    3e16:	d2 f7       	brpl	.-12     	; 0x3e0c <u8EXTERNAL_EEPROM_add_new_user+0x5c>
    3e18:	45 2b       	or	r20, r21
    3e1a:	46 2b       	or	r20, r22
    3e1c:	47 2b       	or	r20, r23
    3e1e:	41 f0       	breq	.+16     	; 0x3e30 <u8EXTERNAL_EEPROM_add_new_user+0x80>
    3e20:	2f 5f       	subi	r18, 0xFF	; 255
    3e22:	3f 4f       	sbci	r19, 0xFF	; 255
	u8 available_user=NO_AVAILABLE_USER;
	eeprom_memory_control_block_t memory;
	//get current mcb
	vGet_current_MCB(&memory);
	//check for available user id
	for(index=0;index<EEPROM_MAX_USER;index++)
    3e24:	29 31       	cpi	r18, 0x19	; 25
    3e26:	31 05       	cpc	r19, r1
    3e28:	f9 f6       	brne	.-66     	; 0x3de8 <u8EXTERNAL_EEPROM_add_new_user+0x38>
			break;
		}	
	}	
	if(available_user ==NO_AVAILABLE_USER)
	{
		return NO_AVAILABLE_USER;
    3e2a:	ff 24       	eor	r15, r15
    3e2c:	fa 94       	dec	r15
    3e2e:	0f c0       	rjmp	.+30     	; 0x3e4e <u8EXTERNAL_EEPROM_add_new_user+0x9e>
		{
			available_user=index;
			break;
		}	
	}	
	if(available_user ==NO_AVAILABLE_USER)
    3e30:	8f ef       	ldi	r24, 0xFF	; 255
    3e32:	28 17       	cp	r18, r24
    3e34:	51 f0       	breq	.+20     	; 0x3e4a <u8EXTERNAL_EEPROM_add_new_user+0x9a>
    3e36:	01 c0       	rjmp	.+2      	; 0x3e3a <u8EXTERNAL_EEPROM_add_new_user+0x8a>
	u8 available_user=NO_AVAILABLE_USER;
	eeprom_memory_control_block_t memory;
	//get current mcb
	vGet_current_MCB(&memory);
	//check for available user id
	for(index=0;index<EEPROM_MAX_USER;index++)
    3e38:	f1 2c       	mov	r15, r1
		return NO_AVAILABLE_USER;
	}
	else
	{
		//set user in mcb
		 add_user_in_mcb(available_user);
    3e3a:	8f 2d       	mov	r24, r15
    3e3c:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <add_user_in_mcb>
		//set user
		vEXTERNAL_EEPROM_set_user(user,available_user);
    3e40:	6f 2d       	mov	r22, r15
    3e42:	c8 01       	movw	r24, r16
    3e44:	0e 94 13 1d 	call	0x3a26	; 0x3a26 <vEXTERNAL_EEPROM_set_user>
    3e48:	02 c0       	rjmp	.+4      	; 0x3e4e <u8EXTERNAL_EEPROM_add_new_user+0x9e>
			break;
		}	
	}	
	if(available_user ==NO_AVAILABLE_USER)
	{
		return NO_AVAILABLE_USER;
    3e4a:	ff 24       	eor	r15, r15
    3e4c:	fa 94       	dec	r15
		//set user
		vEXTERNAL_EEPROM_set_user(user,available_user);
		return available_user;
	}			

}
    3e4e:	8f 2d       	mov	r24, r15
    3e50:	28 96       	adiw	r28, 0x08	; 8
    3e52:	0f b6       	in	r0, 0x3f	; 63
    3e54:	f8 94       	cli
    3e56:	de bf       	out	0x3e, r29	; 62
    3e58:	0f be       	out	0x3f, r0	; 63
    3e5a:	cd bf       	out	0x3d, r28	; 61
    3e5c:	df 91       	pop	r29
    3e5e:	cf 91       	pop	r28
    3e60:	1f 91       	pop	r17
    3e62:	0f 91       	pop	r16
    3e64:	ff 90       	pop	r15
    3e66:	08 95       	ret

00003e68 <vEXTERNAL_EEPROM_delete_user>:
	}

}
//------------------------------------------------------------------------
void vEXTERNAL_EEPROM_delete_user(u8 id)
{
    3e68:	1f 93       	push	r17
    3e6a:	cf 93       	push	r28
    3e6c:	df 93       	push	r29
    3e6e:	cd b7       	in	r28, 0x3d	; 61
    3e70:	de b7       	in	r29, 0x3e	; 62
    3e72:	28 97       	sbiw	r28, 0x08	; 8
    3e74:	0f b6       	in	r0, 0x3f	; 63
    3e76:	f8 94       	cli
    3e78:	de bf       	out	0x3e, r29	; 62
    3e7a:	0f be       	out	0x3f, r0	; 63
    3e7c:	cd bf       	out	0x3d, r28	; 61
    3e7e:	18 2f       	mov	r17, r24
	if(id!=0 && id<EEPROM_MAX_USER)
    3e80:	81 50       	subi	r24, 0x01	; 1
    3e82:	88 31       	cpi	r24, 0x18	; 24
    3e84:	20 f5       	brcc	.+72     	; 0x3ece <vEXTERNAL_EEPROM_delete_user+0x66>
	vSet_current_MCB(&mcb);
}
//----------------------------------
static void delete_user_from_mcb(u8 id)
{
	if(id !=0)
    3e86:	11 23       	and	r17, r17
    3e88:	11 f1       	breq	.+68     	; 0x3ece <vEXTERNAL_EEPROM_delete_user+0x66>
	{
		eeprom_memory_control_block_t mcb;
		vGet_current_MCB(&mcb);
    3e8a:	ce 01       	movw	r24, r28
    3e8c:	01 96       	adiw	r24, 0x01	; 1
    3e8e:	0e 94 31 1c 	call	0x3862	; 0x3862 <vGet_current_MCB>
		clear_bit(mcb.current_user_used_flag,id);
    3e92:	21 e0       	ldi	r18, 0x01	; 1
    3e94:	30 e0       	ldi	r19, 0x00	; 0
    3e96:	c9 01       	movw	r24, r18
    3e98:	02 c0       	rjmp	.+4      	; 0x3e9e <vEXTERNAL_EEPROM_delete_user+0x36>
    3e9a:	88 0f       	add	r24, r24
    3e9c:	99 1f       	adc	r25, r25
    3e9e:	1a 95       	dec	r17
    3ea0:	e2 f7       	brpl	.-8      	; 0x3e9a <vEXTERNAL_EEPROM_delete_user+0x32>
    3ea2:	80 95       	com	r24
    3ea4:	90 95       	com	r25
    3ea6:	aa 27       	eor	r26, r26
    3ea8:	97 fd       	sbrc	r25, 7
    3eaa:	a0 95       	com	r26
    3eac:	ba 2f       	mov	r27, r26
    3eae:	49 81       	ldd	r20, Y+1	; 0x01
    3eb0:	5a 81       	ldd	r21, Y+2	; 0x02
    3eb2:	6b 81       	ldd	r22, Y+3	; 0x03
    3eb4:	7c 81       	ldd	r23, Y+4	; 0x04
    3eb6:	84 23       	and	r24, r20
    3eb8:	95 23       	and	r25, r21
    3eba:	a6 23       	and	r26, r22
    3ebc:	b7 23       	and	r27, r23
    3ebe:	89 83       	std	Y+1, r24	; 0x01
    3ec0:	9a 83       	std	Y+2, r25	; 0x02
    3ec2:	ab 83       	std	Y+3, r26	; 0x03
    3ec4:	bc 83       	std	Y+4, r27	; 0x04
		vSet_current_MCB(&mcb);
    3ec6:	ce 01       	movw	r24, r28
    3ec8:	01 96       	adiw	r24, 0x01	; 1
    3eca:	0e 94 86 1c 	call	0x390c	; 0x390c <vSet_current_MCB>
	if(id!=0 && id<EEPROM_MAX_USER)
	{
		delete_user_from_mcb(id);
	}
	
}
    3ece:	28 96       	adiw	r28, 0x08	; 8
    3ed0:	0f b6       	in	r0, 0x3f	; 63
    3ed2:	f8 94       	cli
    3ed4:	de bf       	out	0x3e, r29	; 62
    3ed6:	0f be       	out	0x3f, r0	; 63
    3ed8:	cd bf       	out	0x3d, r28	; 61
    3eda:	df 91       	pop	r29
    3edc:	cf 91       	pop	r28
    3ede:	1f 91       	pop	r17
    3ee0:	08 95       	ret

00003ee2 <u8EXTERNAL_EEPROM_search_user_byID>:
//-----------------------------------
u8 u8EXTERNAL_EEPROM_search_user_byID(u8 id)
{
    3ee2:	ff 92       	push	r15
    3ee4:	0f 93       	push	r16
    3ee6:	1f 93       	push	r17
    3ee8:	cf 93       	push	r28
    3eea:	df 93       	push	r29
    3eec:	cd b7       	in	r28, 0x3d	; 61
    3eee:	de b7       	in	r29, 0x3e	; 62
    3ef0:	28 97       	sbiw	r28, 0x08	; 8
    3ef2:	0f b6       	in	r0, 0x3f	; 63
    3ef4:	f8 94       	cli
    3ef6:	de bf       	out	0x3e, r29	; 62
    3ef8:	0f be       	out	0x3f, r0	; 63
    3efa:	cd bf       	out	0x3d, r28	; 61
    3efc:	f8 2e       	mov	r15, r24
	eeprom_memory_control_block_t memory;
	if(id>=EEPROM_MAX_USER)
    3efe:	88 e1       	ldi	r24, 0x18	; 24
    3f00:	8f 15       	cp	r24, r15
    3f02:	38 f1       	brcs	.+78     	; 0x3f52 <u8EXTERNAL_EEPROM_search_user_byID+0x70>
	{
		return USER_NOT_FOUND;
	}
	else
	{
		vGet_current_MCB(&memory);
    3f04:	ce 01       	movw	r24, r28
    3f06:	01 96       	adiw	r24, 0x01	; 1
    3f08:	0e 94 31 1c 	call	0x3862	; 0x3862 <vGet_current_MCB>
		if(check_bit(memory.current_user_used_flag,id)==1)
    3f0c:	41 e0       	ldi	r20, 0x01	; 1
    3f0e:	50 e0       	ldi	r21, 0x00	; 0
    3f10:	0f 2c       	mov	r0, r15
    3f12:	02 c0       	rjmp	.+4      	; 0x3f18 <u8EXTERNAL_EEPROM_search_user_byID+0x36>
    3f14:	44 0f       	add	r20, r20
    3f16:	55 1f       	adc	r21, r21
    3f18:	0a 94       	dec	r0
    3f1a:	e2 f7       	brpl	.-8      	; 0x3f14 <u8EXTERNAL_EEPROM_search_user_byID+0x32>
    3f1c:	66 27       	eor	r22, r22
    3f1e:	57 fd       	sbrc	r21, 7
    3f20:	60 95       	com	r22
    3f22:	76 2f       	mov	r23, r22
    3f24:	09 81       	ldd	r16, Y+1	; 0x01
    3f26:	1a 81       	ldd	r17, Y+2	; 0x02
    3f28:	2b 81       	ldd	r18, Y+3	; 0x03
    3f2a:	3c 81       	ldd	r19, Y+4	; 0x04
    3f2c:	40 23       	and	r20, r16
    3f2e:	51 23       	and	r21, r17
    3f30:	62 23       	and	r22, r18
    3f32:	73 23       	and	r23, r19
    3f34:	04 c0       	rjmp	.+8      	; 0x3f3e <u8EXTERNAL_EEPROM_search_user_byID+0x5c>
    3f36:	76 95       	lsr	r23
    3f38:	67 95       	ror	r22
    3f3a:	57 95       	ror	r21
    3f3c:	47 95       	ror	r20
    3f3e:	fa 94       	dec	r15
    3f40:	d2 f7       	brpl	.-12     	; 0x3f36 <u8EXTERNAL_EEPROM_search_user_byID+0x54>
    3f42:	81 e0       	ldi	r24, 0x01	; 1
    3f44:	41 30       	cpi	r20, 0x01	; 1
    3f46:	51 05       	cpc	r21, r1
    3f48:	61 05       	cpc	r22, r1
    3f4a:	71 05       	cpc	r23, r1
    3f4c:	19 f4       	brne	.+6      	; 0x3f54 <u8EXTERNAL_EEPROM_search_user_byID+0x72>
    3f4e:	80 e0       	ldi	r24, 0x00	; 0
    3f50:	01 c0       	rjmp	.+2      	; 0x3f54 <u8EXTERNAL_EEPROM_search_user_byID+0x72>
u8 u8EXTERNAL_EEPROM_search_user_byID(u8 id)
{
	eeprom_memory_control_block_t memory;
	if(id>=EEPROM_MAX_USER)
	{
		return USER_NOT_FOUND;
    3f52:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			return USER_NOT_FOUND;
		}
	}
}
    3f54:	28 96       	adiw	r28, 0x08	; 8
    3f56:	0f b6       	in	r0, 0x3f	; 63
    3f58:	f8 94       	cli
    3f5a:	de bf       	out	0x3e, r29	; 62
    3f5c:	0f be       	out	0x3f, r0	; 63
    3f5e:	cd bf       	out	0x3d, r28	; 61
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	1f 91       	pop	r17
    3f66:	0f 91       	pop	r16
    3f68:	ff 90       	pop	r15
    3f6a:	08 95       	ret

00003f6c <vEXTERNAL_EEPROM_edit_user>:
//-------------------------------------------------------
void vEXTERNAL_EEPROM_edit_user(user_t * user,u8 id)
{
    3f6c:	1f 93       	push	r17
    3f6e:	cf 93       	push	r28
    3f70:	df 93       	push	r29
    3f72:	ec 01       	movw	r28, r24
    3f74:	16 2f       	mov	r17, r22
	//set user in mcb to increment mcb
	add_user_in_mcb(id);
    3f76:	86 2f       	mov	r24, r22
    3f78:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <add_user_in_mcb>
	//set user
	vEXTERNAL_EEPROM_set_user(user,id);
    3f7c:	61 2f       	mov	r22, r17
    3f7e:	ce 01       	movw	r24, r28
    3f80:	0e 94 13 1d 	call	0x3a26	; 0x3a26 <vEXTERNAL_EEPROM_set_user>
}
    3f84:	df 91       	pop	r29
    3f86:	cf 91       	pop	r28
    3f88:	1f 91       	pop	r17
    3f8a:	08 95       	ret

00003f8c <vEXTERNAL_EEPROM_reset>:
//-------------------------------------------------------
void vEXTERNAL_EEPROM_reset(void)
{
    3f8c:	cf 93       	push	r28
    3f8e:	df 93       	push	r29
    3f90:	1f 92       	push	r1
    3f92:	cd b7       	in	r28, 0x3d	; 61
    3f94:	de b7       	in	r29, 0x3e	; 62
	u8 first_check=MAGIC_NUMBER;
    3f96:	8a ea       	ldi	r24, 0xAA	; 170
    3f98:	89 83       	std	Y+1, r24	; 0x01
	vExternal_EEPROM_Write(0,&first_check,1);
    3f9a:	41 e0       	ldi	r20, 0x01	; 1
    3f9c:	be 01       	movw	r22, r28
    3f9e:	6f 5f       	subi	r22, 0xFF	; 255
    3fa0:	7f 4f       	sbci	r23, 0xFF	; 255
    3fa2:	80 e0       	ldi	r24, 0x00	; 0
    3fa4:	90 e0       	ldi	r25, 0x00	; 0
    3fa6:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
	//set control block to first block
	vSet_current_MCB_number(FIRST_MCB_NUMBER);
    3faa:	81 e0       	ldi	r24, 0x01	; 1
    3fac:	0e 94 6c 1c 	call	0x38d8	; 0x38d8 <vSet_current_MCB_number>
	//set current mcb value
	vSet_current_MCB((eeprom_memory_control_block_t*)&g_init_mcb);
    3fb0:	85 e1       	ldi	r24, 0x15	; 21
    3fb2:	91 e0       	ldi	r25, 0x01	; 1
    3fb4:	0e 94 86 1c 	call	0x390c	; 0x390c <vSet_current_MCB>
	//add user in block
	add_user_in_mcb(FIRST_USER_ID);
    3fb8:	80 e0       	ldi	r24, 0x00	; 0
    3fba:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <add_user_in_mcb>
	//add user in memory
	vEXTERNAL_EEPROM_set_user((user_t *)&g_root_user,FIRST_USER_ID);	
    3fbe:	60 e0       	ldi	r22, 0x00	; 0
    3fc0:	8d e1       	ldi	r24, 0x1D	; 29
    3fc2:	91 e0       	ldi	r25, 0x01	; 1
    3fc4:	0e 94 13 1d 	call	0x3a26	; 0x3a26 <vEXTERNAL_EEPROM_set_user>
}
    3fc8:	0f 90       	pop	r0
    3fca:	df 91       	pop	r29
    3fcc:	cf 91       	pop	r28
    3fce:	08 95       	ret

00003fd0 <vEXTERNAL_EEPROM_lock_state>:
//----------------------------------------------------------------------
void vEXTERNAL_EEPROM_lock_state(void)
{
    3fd0:	cf 93       	push	r28
    3fd2:	df 93       	push	r29
    3fd4:	1f 92       	push	r1
    3fd6:	cd b7       	in	r28, 0x3d	; 61
    3fd8:	de b7       	in	r29, 0x3e	; 62
	u8 data=MAGIC_NUMBER;
    3fda:	8a ea       	ldi	r24, 0xAA	; 170
    3fdc:	89 83       	std	Y+1, r24	; 0x01
	vExternal_EEPROM_Write(LOCKED_STATE_ADDRESS,&data,1);
    3fde:	41 e0       	ldi	r20, 0x01	; 1
    3fe0:	be 01       	movw	r22, r28
    3fe2:	6f 5f       	subi	r22, 0xFF	; 255
    3fe4:	7f 4f       	sbci	r23, 0xFF	; 255
    3fe6:	84 e0       	ldi	r24, 0x04	; 4
    3fe8:	90 e0       	ldi	r25, 0x00	; 0
    3fea:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
}
    3fee:	0f 90       	pop	r0
    3ff0:	df 91       	pop	r29
    3ff2:	cf 91       	pop	r28
    3ff4:	08 95       	ret

00003ff6 <vEXTERNAL_EEPROM_unlock_state>:
//---------------------------------------------------------------------------
void vEXTERNAL_EEPROM_unlock_state(void)
{
    3ff6:	cf 93       	push	r28
    3ff8:	df 93       	push	r29
    3ffa:	1f 92       	push	r1
    3ffc:	cd b7       	in	r28, 0x3d	; 61
    3ffe:	de b7       	in	r29, 0x3e	; 62
	u8 data=0xFF;
    4000:	8f ef       	ldi	r24, 0xFF	; 255
    4002:	89 83       	std	Y+1, r24	; 0x01
	vExternal_EEPROM_Write(LOCKED_STATE_ADDRESS,&data,1);
    4004:	41 e0       	ldi	r20, 0x01	; 1
    4006:	be 01       	movw	r22, r28
    4008:	6f 5f       	subi	r22, 0xFF	; 255
    400a:	7f 4f       	sbci	r23, 0xFF	; 255
    400c:	84 e0       	ldi	r24, 0x04	; 4
    400e:	90 e0       	ldi	r25, 0x00	; 0
    4010:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <vExternal_EEPROM_Write>
    4014:	0f 90       	pop	r0
    4016:	df 91       	pop	r29
    4018:	cf 91       	pop	r28
    401a:	08 95       	ret

0000401c <vMotor_driver_init>:
 */ 
#include "motor_driver.h"


void vMotor_driver_init(motor_param_t* param)
{
    401c:	ff 92       	push	r15
    401e:	0f 93       	push	r16
    4020:	1f 93       	push	r17
    4022:	cf 93       	push	r28
    4024:	df 93       	push	r29
    4026:	00 d0       	rcall	.+0      	; 0x4028 <vMotor_driver_init+0xc>
    4028:	00 d0       	rcall	.+0      	; 0x402a <vMotor_driver_init+0xe>
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
    402e:	8c 01       	movw	r16, r24
	gpio_init_param_t temp;
	//init enable 1
	temp.direction=GPIO_OUTPUT;
    4030:	ff 24       	eor	r15, r15
    4032:	f3 94       	inc	r15
    4034:	fb 82       	std	Y+3, r15	; 0x03
	temp.output_init_value=STD_LOGIC_LOW;
    4036:	1c 82       	std	Y+4, r1	; 0x04
	temp.port=param->enable1.port;
    4038:	fc 01       	movw	r30, r24
    403a:	80 81       	ld	r24, Z
    403c:	89 83       	std	Y+1, r24	; 0x01
	temp.pin=param->enable1.pin;
    403e:	81 81       	ldd	r24, Z+1	; 0x01
    4040:	8a 83       	std	Y+2, r24	; 0x02
	vGpio_Init(&temp);
    4042:	ce 01       	movw	r24, r28
    4044:	01 96       	adiw	r24, 0x01	; 1
    4046:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	//init enable 2
	temp.direction=GPIO_OUTPUT;
    404a:	fb 82       	std	Y+3, r15	; 0x03
	temp.output_init_value=STD_LOGIC_LOW;
    404c:	1c 82       	std	Y+4, r1	; 0x04
	temp.port=param->enable2.port;
    404e:	f8 01       	movw	r30, r16
    4050:	83 81       	ldd	r24, Z+3	; 0x03
    4052:	89 83       	std	Y+1, r24	; 0x01
	temp.pin=param->enable2.pin;
    4054:	84 81       	ldd	r24, Z+4	; 0x04
    4056:	8a 83       	std	Y+2, r24	; 0x02
	vGpio_Init(&temp);
    4058:	ce 01       	movw	r24, r28
    405a:	01 96       	adiw	r24, 0x01	; 1
    405c:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	//init pwm pin
	temp.direction=GPIO_OUTPUT;
    4060:	fb 82       	std	Y+3, r15	; 0x03
	temp.output_init_value=STD_LOGIC_LOW;
    4062:	1c 82       	std	Y+4, r1	; 0x04
	temp.port=param->pwm_pin.port;
    4064:	f8 01       	movw	r30, r16
    4066:	86 81       	ldd	r24, Z+6	; 0x06
    4068:	89 83       	std	Y+1, r24	; 0x01
	temp.pin=param->pwm_pin.pin;
    406a:	87 81       	ldd	r24, Z+7	; 0x07
    406c:	8a 83       	std	Y+2, r24	; 0x02
	vGpio_Init(&temp);
    406e:	ce 01       	movw	r24, r28
    4070:	01 96       	adiw	r24, 0x01	; 1
    4072:	0e 94 de 21 	call	0x43bc	; 0x43bc <vGpio_Init>
	//init pwm signal
	vPwm2_Init(param->pwm_param);
    4076:	f8 01       	movw	r30, r16
    4078:	81 85       	ldd	r24, Z+9	; 0x09
    407a:	92 85       	ldd	r25, Z+10	; 0x0a
    407c:	0e 94 74 25 	call	0x4ae8	; 0x4ae8 <vPwm2_Init>
}
    4080:	0f 90       	pop	r0
    4082:	0f 90       	pop	r0
    4084:	0f 90       	pop	r0
    4086:	0f 90       	pop	r0
    4088:	df 91       	pop	r29
    408a:	cf 91       	pop	r28
    408c:	1f 91       	pop	r17
    408e:	0f 91       	pop	r16
    4090:	ff 90       	pop	r15
    4092:	08 95       	ret

00004094 <vMotor_driver_rotate>:
//--------------------------------------------------------------------
void vMotor_driver_rotate(motor_param_t* param,u8 power,motor_direction_type direction)
{
    4094:	1f 93       	push	r17
    4096:	cf 93       	push	r28
    4098:	df 93       	push	r29
    409a:	00 d0       	rcall	.+0      	; 0x409c <vMotor_driver_rotate+0x8>
    409c:	00 d0       	rcall	.+0      	; 0x409e <vMotor_driver_rotate+0xa>
    409e:	00 d0       	rcall	.+0      	; 0x40a0 <vMotor_driver_rotate+0xc>
    40a0:	cd b7       	in	r28, 0x3d	; 61
    40a2:	de b7       	in	r29, 0x3e	; 62
    40a4:	fc 01       	movw	r30, r24
    40a6:	16 2f       	mov	r17, r22
	gpio_write_param_t temp1,temp2;
	temp1.port=param->enable1.port;
    40a8:	90 81       	ld	r25, Z
    40aa:	99 83       	std	Y+1, r25	; 0x01
	temp1.pin=param->enable1.pin;
    40ac:	91 81       	ldd	r25, Z+1	; 0x01
    40ae:	9a 83       	std	Y+2, r25	; 0x02
	temp2.port=param->enable2.port;
    40b0:	93 81       	ldd	r25, Z+3	; 0x03
    40b2:	9c 83       	std	Y+4, r25	; 0x04
	temp2.pin=param->enable2.pin;
    40b4:	94 81       	ldd	r25, Z+4	; 0x04
    40b6:	9d 83       	std	Y+5, r25	; 0x05
	switch(direction)
    40b8:	41 30       	cpi	r20, 0x01	; 1
    40ba:	89 f0       	breq	.+34     	; 0x40de <vMotor_driver_rotate+0x4a>
    40bc:	18 f0       	brcs	.+6      	; 0x40c4 <vMotor_driver_rotate+0x30>
    40be:	42 30       	cpi	r20, 0x02	; 2
    40c0:	79 f5       	brne	.+94     	; 0x4120 <vMotor_driver_rotate+0x8c>
    40c2:	1e c0       	rjmp	.+60     	; 0x4100 <vMotor_driver_rotate+0x6c>
	{
		
		case MOTOR_STOPED :			
									temp1.output=STD_LOGIC_LOW;
    40c4:	1b 82       	std	Y+3, r1	; 0x03
									temp2.output=STD_LOGIC_LOW;
    40c6:	1e 82       	std	Y+6, r1	; 0x06
									vGpio_Write(&temp1);
    40c8:	ce 01       	movw	r24, r28
    40ca:	01 96       	adiw	r24, 0x01	; 1
    40cc:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
									vGpio_Write(&temp2);
    40d0:	ce 01       	movw	r24, r28
    40d2:	04 96       	adiw	r24, 0x04	; 4
    40d4:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
									vPwm2_stop();
    40d8:	0e 94 c1 25 	call	0x4b82	; 0x4b82 <vPwm2_stop>
									break;
    40dc:	21 c0       	rjmp	.+66     	; 0x4120 <vMotor_driver_rotate+0x8c>
		case MOTOR_ROTATE_CLOCKWISE :
									temp1.output=STD_LOGIC_HIGH;
    40de:	81 e0       	ldi	r24, 0x01	; 1
    40e0:	8b 83       	std	Y+3, r24	; 0x03
									temp2.output=STD_LOGIC_LOW;
    40e2:	1e 82       	std	Y+6, r1	; 0x06
									vGpio_Write(&temp1);
    40e4:	ce 01       	movw	r24, r28
    40e6:	01 96       	adiw	r24, 0x01	; 1
    40e8:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
									vGpio_Write(&temp2);
    40ec:	ce 01       	movw	r24, r28
    40ee:	04 96       	adiw	r24, 0x04	; 4
    40f0:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
									vPwm2_restart();
    40f4:	0e 94 c5 25 	call	0x4b8a	; 0x4b8a <vPwm2_restart>
									vPwm2_set_duty(power);
    40f8:	81 2f       	mov	r24, r17
    40fa:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <vPwm2_set_duty>
									break;									
    40fe:	10 c0       	rjmp	.+32     	; 0x4120 <vMotor_driver_rotate+0x8c>
		case MOTOR_ROTATE_COUNTER_CLOCKWISE :
									temp1.output=STD_LOGIC_LOW;
    4100:	1b 82       	std	Y+3, r1	; 0x03
									temp2.output=STD_LOGIC_HIGH;
    4102:	81 e0       	ldi	r24, 0x01	; 1
    4104:	8e 83       	std	Y+6, r24	; 0x06
									vGpio_Write(&temp1);
    4106:	ce 01       	movw	r24, r28
    4108:	01 96       	adiw	r24, 0x01	; 1
    410a:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
									vGpio_Write(&temp2);
    410e:	ce 01       	movw	r24, r28
    4110:	04 96       	adiw	r24, 0x04	; 4
    4112:	0e 94 e5 22 	call	0x45ca	; 0x45ca <vGpio_Write>
									vPwm2_restart();
    4116:	0e 94 c5 25 	call	0x4b8a	; 0x4b8a <vPwm2_restart>
									vPwm2_set_duty(power);
    411a:	81 2f       	mov	r24, r17
    411c:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <vPwm2_set_duty>
									break;		
		
		default:break;
	}
    4120:	26 96       	adiw	r28, 0x06	; 6
    4122:	0f b6       	in	r0, 0x3f	; 63
    4124:	f8 94       	cli
    4126:	de bf       	out	0x3e, r29	; 62
    4128:	0f be       	out	0x3f, r0	; 63
    412a:	cd bf       	out	0x3d, r28	; 61
    412c:	df 91       	pop	r29
    412e:	cf 91       	pop	r28
    4130:	1f 91       	pop	r17
    4132:	08 95       	ret

00004134 <u8Rtc_Get_Time>:
	
	return (error);
}
//------------------------------------------------------------
rtc_error_t u8Rtc_Get_Time(rtc_time_t* time)
{
    4134:	0f 93       	push	r16
    4136:	1f 93       	push	r17
    4138:	cf 93       	push	r28
    413a:	df 93       	push	r29
    413c:	cd b7       	in	r28, 0x3d	; 61
    413e:	de b7       	in	r29, 0x3e	; 62
    4140:	27 97       	sbiw	r28, 0x07	; 7
    4142:	0f b6       	in	r0, 0x3f	; 63
    4144:	f8 94       	cli
    4146:	de bf       	out	0x3e, r29	; 62
    4148:	0f be       	out	0x3f, r0	; 63
    414a:	cd bf       	out	0x3d, r28	; 61
    414c:	8c 01       	movw	r16, r24
	u8 temp[RTC_TIME_REG];
	u8I2c_Start();
    414e:	0e 94 60 24 	call	0x48c0	; 0x48c0 <u8I2c_Start>
	u8I2c_Send_Address(RTC_ADDRESS,I2C_WRITE);
    4152:	60 e0       	ldi	r22, 0x00	; 0
    4154:	80 ed       	ldi	r24, 0xD0	; 208
    4156:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
	u8I2c_Send_Data(RTC_FIRST_REG_ADDRESS);
    415a:	80 e0       	ldi	r24, 0x00	; 0
    415c:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
	u8I2c_Restart();
    4160:	0e 94 96 24 	call	0x492c	; 0x492c <u8I2c_Restart>
	u8I2c_Send_Address(RTC_ADDRESS,I2C_READ);
    4164:	61 e0       	ldi	r22, 0x01	; 1
    4166:	80 ed       	ldi	r24, 0xD0	; 208
    4168:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
	u8I2c_Read_Data(temp,RTC_TIME_REG);
    416c:	67 e0       	ldi	r22, 0x07	; 7
    416e:	ce 01       	movw	r24, r28
    4170:	01 96       	adiw	r24, 0x01	; 1
    4172:	0e 94 a3 24 	call	0x4946	; 0x4946 <u8I2c_Read_Data>
	vI2c_Stop();
    4176:	0e 94 93 24 	call	0x4926	; 0x4926 <vI2c_Stop>
	time->seconds.raw_data= temp[0];
    417a:	89 81       	ldd	r24, Y+1	; 0x01
    417c:	f8 01       	movw	r30, r16
    417e:	80 83       	st	Z, r24
	time->minutes.raw_data=temp[1];
    4180:	8a 81       	ldd	r24, Y+2	; 0x02
    4182:	81 83       	std	Z+1, r24	; 0x01
	time->hours.raw_data  =temp[2];
    4184:	8b 81       	ldd	r24, Y+3	; 0x03
    4186:	82 83       	std	Z+2, r24	; 0x02
	time->day			  =temp[3];
    4188:	8c 81       	ldd	r24, Y+4	; 0x04
    418a:	83 83       	std	Z+3, r24	; 0x03
	time->date.raw_data   =temp[4];
    418c:	8d 81       	ldd	r24, Y+5	; 0x05
    418e:	84 83       	std	Z+4, r24	; 0x04
	time->month.raw_data  =temp[5];
    4190:	8e 81       	ldd	r24, Y+6	; 0x06
    4192:	85 83       	std	Z+5, r24	; 0x05
	time->year.raw_data   =temp[6];
    4194:	8f 81       	ldd	r24, Y+7	; 0x07
    4196:	86 83       	std	Z+6, r24	; 0x06
	return 0;
}
    4198:	80 e0       	ldi	r24, 0x00	; 0
    419a:	27 96       	adiw	r28, 0x07	; 7
    419c:	0f b6       	in	r0, 0x3f	; 63
    419e:	f8 94       	cli
    41a0:	de bf       	out	0x3e, r29	; 62
    41a2:	0f be       	out	0x3f, r0	; 63
    41a4:	cd bf       	out	0x3d, r28	; 61
    41a6:	df 91       	pop	r29
    41a8:	cf 91       	pop	r28
    41aa:	1f 91       	pop	r17
    41ac:	0f 91       	pop	r16
    41ae:	08 95       	ret

000041b0 <u8Rtc_Set_Time>:
//-----------------------------------------------------------------
rtc_error_t u8Rtc_Set_Time(rtc_time_t* time)
{
    41b0:	cf 93       	push	r28
    41b2:	df 93       	push	r29
    41b4:	cd b7       	in	r28, 0x3d	; 61
    41b6:	de b7       	in	r29, 0x3e	; 62
    41b8:	27 97       	sbiw	r28, 0x07	; 7
    41ba:	0f b6       	in	r0, 0x3f	; 63
    41bc:	f8 94       	cli
    41be:	de bf       	out	0x3e, r29	; 62
    41c0:	0f be       	out	0x3f, r0	; 63
    41c2:	cd bf       	out	0x3d, r28	; 61
    41c4:	fc 01       	movw	r30, r24
	u8 temp[RTC_TIME_REG];
	temp[0]=time->seconds.raw_data;
    41c6:	80 81       	ld	r24, Z
    41c8:	89 83       	std	Y+1, r24	; 0x01
	temp[1]=time->minutes.raw_data;
    41ca:	81 81       	ldd	r24, Z+1	; 0x01
    41cc:	8a 83       	std	Y+2, r24	; 0x02
	temp[2]=time->hours.raw_data;
    41ce:	82 81       	ldd	r24, Z+2	; 0x02
    41d0:	8b 83       	std	Y+3, r24	; 0x03
	temp[3]=time->day;
    41d2:	83 81       	ldd	r24, Z+3	; 0x03
    41d4:	8c 83       	std	Y+4, r24	; 0x04
	temp[4]=time->date.raw_data;
    41d6:	84 81       	ldd	r24, Z+4	; 0x04
    41d8:	8d 83       	std	Y+5, r24	; 0x05
	temp[5]=time->month.raw_data;
    41da:	85 81       	ldd	r24, Z+5	; 0x05
    41dc:	8e 83       	std	Y+6, r24	; 0x06
	temp[6]=time->year.raw_data;
    41de:	86 81       	ldd	r24, Z+6	; 0x06
    41e0:	8f 83       	std	Y+7, r24	; 0x07
	u8I2c_Start();
    41e2:	0e 94 60 24 	call	0x48c0	; 0x48c0 <u8I2c_Start>
	u8I2c_Send_Address(RTC_ADDRESS,I2C_WRITE);
    41e6:	60 e0       	ldi	r22, 0x00	; 0
    41e8:	80 ed       	ldi	r24, 0xD0	; 208
    41ea:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
	u8I2c_Send_Data(RTC_FIRST_REG_ADDRESS);
    41ee:	80 e0       	ldi	r24, 0x00	; 0
    41f0:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
	u8I2c_Send_Stream(temp,RTC_TIME_REG);
    41f4:	67 e0       	ldi	r22, 0x07	; 7
    41f6:	ce 01       	movw	r24, r28
    41f8:	01 96       	adiw	r24, 0x01	; 1
    41fa:	0e 94 e0 24 	call	0x49c0	; 0x49c0 <u8I2c_Send_Stream>
	vI2c_Stop();
    41fe:	0e 94 93 24 	call	0x4926	; 0x4926 <vI2c_Stop>
	return 0;
}
    4202:	80 e0       	ldi	r24, 0x00	; 0
    4204:	27 96       	adiw	r28, 0x07	; 7
    4206:	0f b6       	in	r0, 0x3f	; 63
    4208:	f8 94       	cli
    420a:	de bf       	out	0x3e, r29	; 62
    420c:	0f be       	out	0x3f, r0	; 63
    420e:	cd bf       	out	0x3d, r28	; 61
    4210:	df 91       	pop	r29
    4212:	cf 91       	pop	r28
    4214:	08 95       	ret

00004216 <u8Rtc_Set_reg>:
	u8Rtc_Set_reg(new_hour.raw_data,RTC_HOURS_REG);
	return 0;
}
//-------------------------------------------------------------------
rtc_error_t u8Rtc_Set_reg(u8 data,u8 reg_number)
{
    4216:	cf 93       	push	r28
    4218:	df 93       	push	r29
    421a:	c8 2f       	mov	r28, r24
    421c:	d6 2f       	mov	r29, r22
		u8I2c_Start();
    421e:	0e 94 60 24 	call	0x48c0	; 0x48c0 <u8I2c_Start>
		u8I2c_Send_Address(RTC_ADDRESS,I2C_WRITE);
    4222:	60 e0       	ldi	r22, 0x00	; 0
    4224:	80 ed       	ldi	r24, 0xD0	; 208
    4226:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
		u8I2c_Send_Data(reg_number);
    422a:	8d 2f       	mov	r24, r29
    422c:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
		u8I2c_Send_Data(data);
    4230:	8c 2f       	mov	r24, r28
    4232:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
		vI2c_Stop();
    4236:	0e 94 93 24 	call	0x4926	; 0x4926 <vI2c_Stop>
		return 0;
}
    423a:	80 e0       	ldi	r24, 0x00	; 0
    423c:	df 91       	pop	r29
    423e:	cf 91       	pop	r28
    4240:	08 95       	ret

00004242 <u8Rtc_get_reg>:
//-------------------------------------------------------------------
rtc_error_t u8Rtc_get_reg(u8* data,u8 reg_number)
{
    4242:	1f 93       	push	r17
    4244:	cf 93       	push	r28
    4246:	df 93       	push	r29
    4248:	ec 01       	movw	r28, r24
    424a:	16 2f       	mov	r17, r22
	u8I2c_Start();
    424c:	0e 94 60 24 	call	0x48c0	; 0x48c0 <u8I2c_Start>
	u8I2c_Send_Address(RTC_ADDRESS,I2C_WRITE);
    4250:	60 e0       	ldi	r22, 0x00	; 0
    4252:	80 ed       	ldi	r24, 0xD0	; 208
    4254:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
	u8I2c_Send_Data(reg_number);
    4258:	81 2f       	mov	r24, r17
    425a:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
	u8I2c_Restart();
    425e:	0e 94 96 24 	call	0x492c	; 0x492c <u8I2c_Restart>
	u8I2c_Send_Address(RTC_ADDRESS,I2C_READ);
    4262:	61 e0       	ldi	r22, 0x01	; 1
    4264:	80 ed       	ldi	r24, 0xD0	; 208
    4266:	0e 94 6d 24 	call	0x48da	; 0x48da <u8I2c_Send_Address>
	u8I2c_Read_Data(data,1);
    426a:	61 e0       	ldi	r22, 0x01	; 1
    426c:	ce 01       	movw	r24, r28
    426e:	0e 94 a3 24 	call	0x4946	; 0x4946 <u8I2c_Read_Data>
	vI2c_Stop();
    4272:	0e 94 93 24 	call	0x4926	; 0x4926 <vI2c_Stop>
	return 0;
    4276:	80 e0       	ldi	r24, 0x00	; 0
    4278:	df 91       	pop	r29
    427a:	cf 91       	pop	r28
    427c:	1f 91       	pop	r17
    427e:	08 95       	ret

00004280 <u8Rtc_Set_format>:
	vI2c_Stop();
	return 0;
}
//-------------------------------------------------------------------
rtc_error_t u8Rtc_Set_format(rtc_format_t format)
{
    4280:	1f 93       	push	r17
    4282:	cf 93       	push	r28
    4284:	df 93       	push	r29
    4286:	1f 92       	push	r1
    4288:	cd b7       	in	r28, 0x3d	; 61
    428a:	de b7       	in	r29, 0x3e	; 62
    428c:	18 2f       	mov	r17, r24
	//save the hour register
	rtc_hours hour,new_hour;
	u8 first_dig,second_dig;
	u8Rtc_get_reg(&(hour.raw_data),RTC_HOURS_REG);
    428e:	62 e0       	ldi	r22, 0x02	; 2
    4290:	ce 01       	movw	r24, r28
    4292:	01 96       	adiw	r24, 0x01	; 1
    4294:	0e 94 21 21 	call	0x4242	; 0x4242 <u8Rtc_get_reg>
	//set format
	//if format 12
	if(format ==RTC_12_FORMAT)
    4298:	11 30       	cpi	r17, 0x01	; 1
    429a:	09 f0       	breq	.+2      	; 0x429e <u8Rtc_Set_format+0x1e>
    429c:	48 c0       	rjmp	.+144    	; 0x432e <u8Rtc_Set_format+0xae>
	{
		//check current format
		if(hour.h12.SELECT_12_24==RTC_12_FORMAT)
    429e:	89 81       	ldd	r24, Y+1	; 0x01
    42a0:	86 fd       	sbrc	r24, 6
    42a2:	84 c0       	rjmp	.+264    	; 0x43ac <u8Rtc_Set_format+0x12c>
			return 1;
		}
		else
		{
			//convert time to 12 AM-PM FORMAT
			first_dig=hour.h24.first_digit;
    42a4:	98 2f       	mov	r25, r24
    42a6:	28 2f       	mov	r18, r24
    42a8:	2f 70       	andi	r18, 0x0F	; 15
			second_dig=hour.h24.second_digit;
    42aa:	96 95       	lsr	r25
    42ac:	96 95       	lsr	r25
    42ae:	96 95       	lsr	r25
			first_dig=first_dig+10*second_dig;
    42b0:	96 70       	andi	r25, 0x06	; 6
    42b2:	89 2f       	mov	r24, r25
    42b4:	88 0f       	add	r24, r24
    42b6:	88 0f       	add	r24, r24
    42b8:	89 0f       	add	r24, r25
    42ba:	82 0f       	add	r24, r18
			if(first_dig ==12)
    42bc:	8c 30       	cpi	r24, 0x0C	; 12
    42be:	29 f4       	brne	.+10     	; 0x42ca <u8Rtc_Set_format+0x4a>
			{
				new_hour.h12.first_digit=2;
    42c0:	82 e0       	ldi	r24, 0x02	; 2
				new_hour.h12.second_digit=1;
    42c2:	80 61       	ori	r24, 0x10	; 16
				new_hour.h12.SELECT_AM_PM=RTC_PM;
    42c4:	80 62       	ori	r24, 0x20	; 32
				new_hour.h12.SELECT_12_24=RTC_12_FORMAT;
    42c6:	80 64       	ori	r24, 0x40	; 64
    42c8:	6c c0       	rjmp	.+216    	; 0x43a2 <u8Rtc_Set_format+0x122>
			}
			else if(first_dig >12)
    42ca:	8d 30       	cpi	r24, 0x0D	; 13
    42cc:	a8 f0       	brcs	.+42     	; 0x42f8 <u8Rtc_Set_format+0x78>
			{
				//subtract 12
				first_dig=first_dig-12;
    42ce:	8c 50       	subi	r24, 0x0C	; 12
				second_dig=first_dig/10;
				first_dig=first_dig%10;
    42d0:	9d ec       	ldi	r25, 0xCD	; 205
    42d2:	89 9f       	mul	r24, r25
    42d4:	91 2d       	mov	r25, r1
    42d6:	11 24       	eor	r1, r1
    42d8:	96 95       	lsr	r25
    42da:	96 95       	lsr	r25
    42dc:	96 95       	lsr	r25
    42de:	29 2f       	mov	r18, r25
    42e0:	22 0f       	add	r18, r18
    42e2:	32 2f       	mov	r19, r18
    42e4:	33 0f       	add	r19, r19
    42e6:	33 0f       	add	r19, r19
    42e8:	23 0f       	add	r18, r19
    42ea:	82 1b       	sub	r24, r18
				new_hour.h12.first_digit=first_dig;
    42ec:	8f 70       	andi	r24, 0x0F	; 15
				new_hour.h12.second_digit=second_dig;
    42ee:	90 fb       	bst	r25, 0
    42f0:	84 f9       	bld	r24, 4
				new_hour.h12.SELECT_AM_PM=RTC_PM;
    42f2:	80 62       	ori	r24, 0x20	; 32
				new_hour.h12.SELECT_12_24=RTC_12_FORMAT;
    42f4:	80 64       	ori	r24, 0x40	; 64
    42f6:	55 c0       	rjmp	.+170    	; 0x43a2 <u8Rtc_Set_format+0x122>
											
			}
			else
			{
				//if 0 >>12am
				if(first_dig==0)
    42f8:	81 11       	cpse	r24, r1
    42fa:	05 c0       	rjmp	.+10     	; 0x4306 <u8Rtc_Set_format+0x86>
				{
					//convert to 12 am
					new_hour.h12.first_digit=2;
    42fc:	82 e0       	ldi	r24, 0x02	; 2
					new_hour.h12.second_digit=1;
    42fe:	80 61       	ori	r24, 0x10	; 16
					new_hour.h12.SELECT_AM_PM=RTC_AM;
    4300:	8f 7d       	andi	r24, 0xDF	; 223
					new_hour.h12.SELECT_12_24=RTC_12_FORMAT;
    4302:	80 64       	ori	r24, 0x40	; 64
    4304:	4e c0       	rjmp	.+156    	; 0x43a2 <u8Rtc_Set_format+0x122>
				}
				else
				{
					//if 1>>>11
					second_dig=first_dig/10;
					first_dig=first_dig%10;
    4306:	9d ec       	ldi	r25, 0xCD	; 205
    4308:	89 9f       	mul	r24, r25
    430a:	91 2d       	mov	r25, r1
    430c:	11 24       	eor	r1, r1
    430e:	96 95       	lsr	r25
    4310:	96 95       	lsr	r25
    4312:	96 95       	lsr	r25
    4314:	29 2f       	mov	r18, r25
    4316:	22 0f       	add	r18, r18
    4318:	32 2f       	mov	r19, r18
    431a:	33 0f       	add	r19, r19
    431c:	33 0f       	add	r19, r19
    431e:	23 0f       	add	r18, r19
    4320:	82 1b       	sub	r24, r18
					new_hour.h12.first_digit=first_dig;
    4322:	8f 70       	andi	r24, 0x0F	; 15
					new_hour.h12.second_digit=second_dig;
    4324:	90 fb       	bst	r25, 0
    4326:	84 f9       	bld	r24, 4
					new_hour.h12.SELECT_AM_PM=RTC_AM;
    4328:	8f 7d       	andi	r24, 0xDF	; 223
					new_hour.h12.SELECT_12_24=RTC_12_FORMAT;
    432a:	80 64       	ori	r24, 0x40	; 64
    432c:	3a c0       	rjmp	.+116    	; 0x43a2 <u8Rtc_Set_format+0x122>
		}
	}
	else
	{
		//if format 24
		if(hour.h24.SELECT_12_24==RTC_24_FORMAT)
    432e:	89 81       	ldd	r24, Y+1	; 0x01
    4330:	86 ff       	sbrs	r24, 6
    4332:	3e c0       	rjmp	.+124    	; 0x43b0 <u8Rtc_Set_format+0x130>
			return 1;
		}
		else
		{
			//check am/pm
			if(hour.h12.SELECT_AM_PM ==RTC_AM)
    4334:	85 fd       	sbrc	r24, 5
    4336:	10 c0       	rjmp	.+32     	; 0x4358 <u8Rtc_Set_format+0xd8>
			{
				//case am
				//check if  12
				if((hour.h12.first_digit==2) && (hour.h12.second_digit ==1))
    4338:	8f 71       	andi	r24, 0x1F	; 31
    433a:	82 31       	cpi	r24, 0x12	; 18
    433c:	19 f4       	brne	.+6      	; 0x4344 <u8Rtc_Set_format+0xc4>
				{
					//convert it to 0
					new_hour.h24.first_digit=0;
					new_hour.h24.second_digit=0;
    433e:	80 e0       	ldi	r24, 0x00	; 0
					new_hour.h24.SELECT_12_24=RTC_24_FORMAT;
    4340:	8f 7b       	andi	r24, 0xBF	; 191
    4342:	2f c0       	rjmp	.+94     	; 0x43a2 <u8Rtc_Set_format+0x122>
				}
				else
				{
					//any number from 1-11
					//the same hour
					new_hour.h24.first_digit=hour.h12.first_digit;
    4344:	99 81       	ldd	r25, Y+1	; 0x01
					new_hour.h24.second_digit=hour.h12.second_digit;
    4346:	94 fb       	bst	r25, 4
    4348:	88 27       	eor	r24, r24
    434a:	80 f9       	bld	r24, 0
    434c:	82 95       	swap	r24
    434e:	80 7f       	andi	r24, 0xF0	; 240
    4350:	9f 70       	andi	r25, 0x0F	; 15
    4352:	89 2b       	or	r24, r25
					new_hour.h24.SELECT_12_24=RTC_24_FORMAT;
    4354:	8f 7b       	andi	r24, 0xBF	; 191
    4356:	25 c0       	rjmp	.+74     	; 0x43a2 <u8Rtc_Set_format+0x122>
			}
			else
			{
				//case pm
				//check if  12
				if((hour.h12.first_digit==2) && (hour.h12.second_digit ==1))
    4358:	8f 71       	andi	r24, 0x1F	; 31
    435a:	82 31       	cpi	r24, 0x12	; 18
    435c:	11 f4       	brne	.+4      	; 0x4362 <u8Rtc_Set_format+0xe2>
				{
					//convert it to 12
					new_hour.h24.first_digit=2;
					new_hour.h24.second_digit=1;
					new_hour.h24.SELECT_12_24=RTC_24_FORMAT;
    435e:	8f 7b       	andi	r24, 0xBF	; 191
    4360:	20 c0       	rjmp	.+64     	; 0x43a2 <u8Rtc_Set_format+0x122>
				}
				else
				{
					//any number 1-11
					//increment 12
					first_dig=hour.h12.first_digit;
    4362:	99 81       	ldd	r25, Y+1	; 0x01
    4364:	89 2f       	mov	r24, r25
    4366:	8f 70       	andi	r24, 0x0F	; 15
					second_dig=hour.h12.second_digit;
					first_dig=first_dig+10*second_dig;
    4368:	84 5f       	subi	r24, 0xF4	; 244
				else
				{
					//any number 1-11
					//increment 12
					first_dig=hour.h12.first_digit;
					second_dig=hour.h12.second_digit;
    436a:	92 95       	swap	r25
    436c:	91 70       	andi	r25, 0x01	; 1
					first_dig=first_dig+10*second_dig;
    436e:	99 0f       	add	r25, r25
    4370:	29 2f       	mov	r18, r25
    4372:	22 0f       	add	r18, r18
    4374:	22 0f       	add	r18, r18
    4376:	92 0f       	add	r25, r18
					first_dig=first_dig+12;
    4378:	89 0f       	add	r24, r25
					second_dig=first_dig/10;
					first_dig=first_dig%10;
    437a:	9d ec       	ldi	r25, 0xCD	; 205
    437c:	89 9f       	mul	r24, r25
    437e:	91 2d       	mov	r25, r1
    4380:	11 24       	eor	r1, r1
    4382:	96 95       	lsr	r25
    4384:	96 95       	lsr	r25
    4386:	96 95       	lsr	r25
    4388:	29 2f       	mov	r18, r25
    438a:	22 0f       	add	r18, r18
    438c:	32 2f       	mov	r19, r18
    438e:	33 0f       	add	r19, r19
    4390:	33 0f       	add	r19, r19
    4392:	23 0f       	add	r18, r19
    4394:	82 1b       	sub	r24, r18
					new_hour.h24.first_digit=first_dig;
					new_hour.h24.second_digit=second_dig;
    4396:	93 70       	andi	r25, 0x03	; 3
    4398:	92 95       	swap	r25
    439a:	90 7f       	andi	r25, 0xF0	; 240
    439c:	8f 70       	andi	r24, 0x0F	; 15
    439e:	89 2b       	or	r24, r25
					new_hour.h24.SELECT_12_24=RTC_24_FORMAT;
    43a0:	8f 7b       	andi	r24, 0xBF	; 191
				}
			}
										
		}
	}
	u8Rtc_Set_reg(new_hour.raw_data,RTC_HOURS_REG);
    43a2:	62 e0       	ldi	r22, 0x02	; 2
    43a4:	0e 94 0b 21 	call	0x4216	; 0x4216 <u8Rtc_Set_reg>
	return 0;
    43a8:	80 e0       	ldi	r24, 0x00	; 0
    43aa:	03 c0       	rjmp	.+6      	; 0x43b2 <u8Rtc_Set_format+0x132>
	if(format ==RTC_12_FORMAT)
	{
		//check current format
		if(hour.h12.SELECT_12_24==RTC_12_FORMAT)
		{
			return 1;
    43ac:	81 e0       	ldi	r24, 0x01	; 1
    43ae:	01 c0       	rjmp	.+2      	; 0x43b2 <u8Rtc_Set_format+0x132>
	else
	{
		//if format 24
		if(hour.h24.SELECT_12_24==RTC_24_FORMAT)
		{
			return 1;
    43b0:	81 e0       	ldi	r24, 0x01	; 1
										
		}
	}
	u8Rtc_Set_reg(new_hour.raw_data,RTC_HOURS_REG);
	return 0;
}
    43b2:	0f 90       	pop	r0
    43b4:	df 91       	pop	r29
    43b6:	cf 91       	pop	r28
    43b8:	1f 91       	pop	r17
    43ba:	08 95       	ret

000043bc <vGpio_Init>:
 */ 
//----------------------------------------------------------------------
#include "gpio.h"
//--------------------------------------------------------------------
void vGpio_Init(gpio_init_param_t * gpio_param)
{
    43bc:	cf 92       	push	r12
    43be:	df 92       	push	r13
    43c0:	ef 92       	push	r14
    43c2:	ff 92       	push	r15
    43c4:	0f 93       	push	r16
    43c6:	1f 93       	push	r17
    43c8:	cf 93       	push	r28
    43ca:	df 93       	push	r29
    43cc:	fc 01       	movw	r30, r24
	//check port
	switch(gpio_param->port)
    43ce:	80 81       	ld	r24, Z
    43d0:	81 30       	cpi	r24, 0x01	; 1
    43d2:	09 f4       	brne	.+2      	; 0x43d6 <vGpio_Init+0x1a>
    43d4:	43 c0       	rjmp	.+134    	; 0x445c <vGpio_Init+0xa0>
    43d6:	38 f0       	brcs	.+14     	; 0x43e6 <vGpio_Init+0x2a>
    43d8:	82 30       	cpi	r24, 0x02	; 2
    43da:	09 f4       	brne	.+2      	; 0x43de <vGpio_Init+0x22>
    43dc:	7a c0       	rjmp	.+244    	; 0x44d2 <vGpio_Init+0x116>
    43de:	83 30       	cpi	r24, 0x03	; 3
    43e0:	09 f0       	breq	.+2      	; 0x43e4 <vGpio_Init+0x28>
    43e2:	ea c0       	rjmp	.+468    	; 0x45b8 <vGpio_Init+0x1fc>
    43e4:	b0 c0       	rjmp	.+352    	; 0x4546 <vGpio_Init+0x18a>
	{
	case GPIO_PORT1 :
					DDRA = (DDRA & ~(1<<gpio_param->pin)) | (((gpio_param->direction)& (0x01))<<gpio_param->pin);
    43e6:	5a b3       	in	r21, 0x1a	; 26
    43e8:	41 81       	ldd	r20, Z+1	; 0x01
    43ea:	81 e0       	ldi	r24, 0x01	; 1
    43ec:	90 e0       	ldi	r25, 0x00	; 0
    43ee:	9c 01       	movw	r18, r24
    43f0:	04 2e       	mov	r0, r20
    43f2:	02 c0       	rjmp	.+4      	; 0x43f8 <vGpio_Init+0x3c>
    43f4:	22 0f       	add	r18, r18
    43f6:	33 1f       	adc	r19, r19
    43f8:	0a 94       	dec	r0
    43fa:	e2 f7       	brpl	.-8      	; 0x43f4 <vGpio_Init+0x38>
    43fc:	20 95       	com	r18
    43fe:	25 23       	and	r18, r21
    4400:	32 81       	ldd	r19, Z+2	; 0x02
    4402:	30 fb       	bst	r19, 0
    4404:	cc 24       	eor	r12, r12
    4406:	c0 f8       	bld	r12, 0
    4408:	d1 2c       	mov	r13, r1
    440a:	02 c0       	rjmp	.+4      	; 0x4410 <vGpio_Init+0x54>
    440c:	cc 0c       	add	r12, r12
    440e:	dd 1c       	adc	r13, r13
    4410:	4a 95       	dec	r20
    4412:	e2 f7       	brpl	.-8      	; 0x440c <vGpio_Init+0x50>
    4414:	c2 2a       	or	r12, r18
    4416:	ca ba       	out	0x1a, r12	; 26
					PORTA = (PORTA & ~(1<<gpio_param->pin)) | ((((gpio_param->direction)& (0x02))>>1)<<gpio_param->pin) | (gpio_param->output_init_value<<gpio_param->pin);
    4418:	2b b3       	in	r18, 0x1b	; 27
    441a:	31 81       	ldd	r19, Z+1	; 0x01
    441c:	03 2e       	mov	r0, r19
    441e:	02 c0       	rjmp	.+4      	; 0x4424 <vGpio_Init+0x68>
    4420:	88 0f       	add	r24, r24
    4422:	99 1f       	adc	r25, r25
    4424:	0a 94       	dec	r0
    4426:	e2 f7       	brpl	.-8      	; 0x4420 <vGpio_Init+0x64>
    4428:	80 95       	com	r24
    442a:	82 23       	and	r24, r18
    442c:	92 81       	ldd	r25, Z+2	; 0x02
    442e:	91 fb       	bst	r25, 1
    4430:	ee 24       	eor	r14, r14
    4432:	e0 f8       	bld	r14, 0
    4434:	f1 2c       	mov	r15, r1
    4436:	03 2e       	mov	r0, r19
    4438:	02 c0       	rjmp	.+4      	; 0x443e <vGpio_Init+0x82>
    443a:	ee 0c       	add	r14, r14
    443c:	ff 1c       	adc	r15, r15
    443e:	0a 94       	dec	r0
    4440:	e2 f7       	brpl	.-8      	; 0x443a <vGpio_Init+0x7e>
    4442:	e8 2a       	or	r14, r24
    4444:	43 81       	ldd	r20, Z+3	; 0x03
    4446:	50 e0       	ldi	r21, 0x00	; 0
    4448:	ca 01       	movw	r24, r20
    444a:	02 c0       	rjmp	.+4      	; 0x4450 <vGpio_Init+0x94>
    444c:	88 0f       	add	r24, r24
    444e:	99 1f       	adc	r25, r25
    4450:	3a 95       	dec	r19
    4452:	e2 f7       	brpl	.-8      	; 0x444c <vGpio_Init+0x90>
    4454:	9c 01       	movw	r18, r24
    4456:	2e 29       	or	r18, r14
    4458:	2b bb       	out	0x1b, r18	; 27
					break;
    445a:	ae c0       	rjmp	.+348    	; 0x45b8 <vGpio_Init+0x1fc>
	case GPIO_PORT2 :
					DDRB = (DDRB & ~(1<<gpio_param->pin)) | (((gpio_param->direction)& (0x01))<<gpio_param->pin);
    445c:	57 b3       	in	r21, 0x17	; 23
    445e:	41 81       	ldd	r20, Z+1	; 0x01
    4460:	81 e0       	ldi	r24, 0x01	; 1
    4462:	90 e0       	ldi	r25, 0x00	; 0
    4464:	9c 01       	movw	r18, r24
    4466:	04 2e       	mov	r0, r20
    4468:	02 c0       	rjmp	.+4      	; 0x446e <vGpio_Init+0xb2>
    446a:	22 0f       	add	r18, r18
    446c:	33 1f       	adc	r19, r19
    446e:	0a 94       	dec	r0
    4470:	e2 f7       	brpl	.-8      	; 0x446a <vGpio_Init+0xae>
    4472:	20 95       	com	r18
    4474:	25 23       	and	r18, r21
    4476:	32 81       	ldd	r19, Z+2	; 0x02
    4478:	03 2f       	mov	r16, r19
    447a:	01 70       	andi	r16, 0x01	; 1
    447c:	10 e0       	ldi	r17, 0x00	; 0
    447e:	02 c0       	rjmp	.+4      	; 0x4484 <vGpio_Init+0xc8>
    4480:	00 0f       	add	r16, r16
    4482:	11 1f       	adc	r17, r17
    4484:	4a 95       	dec	r20
    4486:	e2 f7       	brpl	.-8      	; 0x4480 <vGpio_Init+0xc4>
    4488:	02 2b       	or	r16, r18
    448a:	07 bb       	out	0x17, r16	; 23
					PORTB = (PORTB & ~(1<<gpio_param->pin)) | ((((gpio_param->direction)& (0x02))>>1)<<gpio_param->pin) | (gpio_param->output_init_value<<gpio_param->pin);	
    448c:	28 b3       	in	r18, 0x18	; 24
    448e:	31 81       	ldd	r19, Z+1	; 0x01
    4490:	03 2e       	mov	r0, r19
    4492:	02 c0       	rjmp	.+4      	; 0x4498 <vGpio_Init+0xdc>
    4494:	88 0f       	add	r24, r24
    4496:	99 1f       	adc	r25, r25
    4498:	0a 94       	dec	r0
    449a:	e2 f7       	brpl	.-8      	; 0x4494 <vGpio_Init+0xd8>
    449c:	80 95       	com	r24
    449e:	82 23       	and	r24, r18
    44a0:	92 81       	ldd	r25, Z+2	; 0x02
    44a2:	96 95       	lsr	r25
    44a4:	91 70       	andi	r25, 0x01	; 1
    44a6:	c9 2f       	mov	r28, r25
    44a8:	90 e0       	ldi	r25, 0x00	; 0
    44aa:	d9 2f       	mov	r29, r25
    44ac:	03 2e       	mov	r0, r19
    44ae:	02 c0       	rjmp	.+4      	; 0x44b4 <vGpio_Init+0xf8>
    44b0:	cc 0f       	add	r28, r28
    44b2:	dd 1f       	adc	r29, r29
    44b4:	0a 94       	dec	r0
    44b6:	e2 f7       	brpl	.-8      	; 0x44b0 <vGpio_Init+0xf4>
    44b8:	c8 2b       	or	r28, r24
    44ba:	43 81       	ldd	r20, Z+3	; 0x03
    44bc:	50 e0       	ldi	r21, 0x00	; 0
    44be:	ca 01       	movw	r24, r20
    44c0:	02 c0       	rjmp	.+4      	; 0x44c6 <vGpio_Init+0x10a>
    44c2:	88 0f       	add	r24, r24
    44c4:	99 1f       	adc	r25, r25
    44c6:	3a 95       	dec	r19
    44c8:	e2 f7       	brpl	.-8      	; 0x44c2 <vGpio_Init+0x106>
    44ca:	9c 01       	movw	r18, r24
    44cc:	2c 2b       	or	r18, r28
    44ce:	28 bb       	out	0x18, r18	; 24
					break;					
    44d0:	73 c0       	rjmp	.+230    	; 0x45b8 <vGpio_Init+0x1fc>
	case GPIO_PORT3 :
					DDRC = (DDRC & ~(1<<gpio_param->pin)) | (((gpio_param->direction)& (0x01))<<gpio_param->pin);
    44d2:	54 b3       	in	r21, 0x14	; 20
    44d4:	41 81       	ldd	r20, Z+1	; 0x01
    44d6:	81 e0       	ldi	r24, 0x01	; 1
    44d8:	90 e0       	ldi	r25, 0x00	; 0
    44da:	9c 01       	movw	r18, r24
    44dc:	04 2e       	mov	r0, r20
    44de:	02 c0       	rjmp	.+4      	; 0x44e4 <vGpio_Init+0x128>
    44e0:	22 0f       	add	r18, r18
    44e2:	33 1f       	adc	r19, r19
    44e4:	0a 94       	dec	r0
    44e6:	e2 f7       	brpl	.-8      	; 0x44e0 <vGpio_Init+0x124>
    44e8:	20 95       	com	r18
    44ea:	25 23       	and	r18, r21
    44ec:	32 81       	ldd	r19, Z+2	; 0x02
    44ee:	a3 2f       	mov	r26, r19
    44f0:	a1 70       	andi	r26, 0x01	; 1
    44f2:	b0 e0       	ldi	r27, 0x00	; 0
    44f4:	02 c0       	rjmp	.+4      	; 0x44fa <vGpio_Init+0x13e>
    44f6:	aa 0f       	add	r26, r26
    44f8:	bb 1f       	adc	r27, r27
    44fa:	4a 95       	dec	r20
    44fc:	e2 f7       	brpl	.-8      	; 0x44f6 <vGpio_Init+0x13a>
    44fe:	a2 2b       	or	r26, r18
    4500:	a4 bb       	out	0x14, r26	; 20
					PORTC = (PORTC & ~(1<<gpio_param->pin)) | ((((gpio_param->direction)& (0x02))>>1)<<gpio_param->pin) | (gpio_param->output_init_value<<gpio_param->pin);	
    4502:	25 b3       	in	r18, 0x15	; 21
    4504:	31 81       	ldd	r19, Z+1	; 0x01
    4506:	03 2e       	mov	r0, r19
    4508:	02 c0       	rjmp	.+4      	; 0x450e <vGpio_Init+0x152>
    450a:	88 0f       	add	r24, r24
    450c:	99 1f       	adc	r25, r25
    450e:	0a 94       	dec	r0
    4510:	e2 f7       	brpl	.-8      	; 0x450a <vGpio_Init+0x14e>
    4512:	80 95       	com	r24
    4514:	82 23       	and	r24, r18
    4516:	92 81       	ldd	r25, Z+2	; 0x02
    4518:	91 fb       	bst	r25, 1
    451a:	66 27       	eor	r22, r22
    451c:	60 f9       	bld	r22, 0
    451e:	70 e0       	ldi	r23, 0x00	; 0
    4520:	03 2e       	mov	r0, r19
    4522:	02 c0       	rjmp	.+4      	; 0x4528 <vGpio_Init+0x16c>
    4524:	66 0f       	add	r22, r22
    4526:	77 1f       	adc	r23, r23
    4528:	0a 94       	dec	r0
    452a:	e2 f7       	brpl	.-8      	; 0x4524 <vGpio_Init+0x168>
    452c:	68 2b       	or	r22, r24
    452e:	43 81       	ldd	r20, Z+3	; 0x03
    4530:	50 e0       	ldi	r21, 0x00	; 0
    4532:	ca 01       	movw	r24, r20
    4534:	02 c0       	rjmp	.+4      	; 0x453a <vGpio_Init+0x17e>
    4536:	88 0f       	add	r24, r24
    4538:	99 1f       	adc	r25, r25
    453a:	3a 95       	dec	r19
    453c:	e2 f7       	brpl	.-8      	; 0x4536 <vGpio_Init+0x17a>
    453e:	9c 01       	movw	r18, r24
    4540:	26 2b       	or	r18, r22
    4542:	25 bb       	out	0x15, r18	; 21
					break;	
    4544:	39 c0       	rjmp	.+114    	; 0x45b8 <vGpio_Init+0x1fc>
	case GPIO_PORT4 :
					DDRD = (DDRD & ~(1<<gpio_param->pin)) | (((gpio_param->direction)& (0x01))<<gpio_param->pin);
    4546:	b1 b3       	in	r27, 0x11	; 17
    4548:	a1 81       	ldd	r26, Z+1	; 0x01
    454a:	81 e0       	ldi	r24, 0x01	; 1
    454c:	90 e0       	ldi	r25, 0x00	; 0
    454e:	bc 01       	movw	r22, r24
    4550:	0a 2e       	mov	r0, r26
    4552:	02 c0       	rjmp	.+4      	; 0x4558 <vGpio_Init+0x19c>
    4554:	66 0f       	add	r22, r22
    4556:	77 1f       	adc	r23, r23
    4558:	0a 94       	dec	r0
    455a:	e2 f7       	brpl	.-8      	; 0x4554 <vGpio_Init+0x198>
    455c:	60 95       	com	r22
    455e:	6b 23       	and	r22, r27
    4560:	72 81       	ldd	r23, Z+2	; 0x02
    4562:	47 2f       	mov	r20, r23
    4564:	41 70       	andi	r20, 0x01	; 1
    4566:	50 e0       	ldi	r21, 0x00	; 0
    4568:	02 c0       	rjmp	.+4      	; 0x456e <vGpio_Init+0x1b2>
    456a:	44 0f       	add	r20, r20
    456c:	55 1f       	adc	r21, r21
    456e:	aa 95       	dec	r26
    4570:	e2 f7       	brpl	.-8      	; 0x456a <vGpio_Init+0x1ae>
    4572:	46 2b       	or	r20, r22
    4574:	41 bb       	out	0x11, r20	; 17
					PORTD = (PORTD & ~(1<<gpio_param->pin)) | ((((gpio_param->direction)& (0x02))>>1)<<gpio_param->pin) | (gpio_param->output_init_value<<gpio_param->pin);	
    4576:	42 b3       	in	r20, 0x12	; 18
    4578:	51 81       	ldd	r21, Z+1	; 0x01
    457a:	05 2e       	mov	r0, r21
    457c:	02 c0       	rjmp	.+4      	; 0x4582 <vGpio_Init+0x1c6>
    457e:	88 0f       	add	r24, r24
    4580:	99 1f       	adc	r25, r25
    4582:	0a 94       	dec	r0
    4584:	e2 f7       	brpl	.-8      	; 0x457e <vGpio_Init+0x1c2>
    4586:	80 95       	com	r24
    4588:	84 23       	and	r24, r20
    458a:	92 81       	ldd	r25, Z+2	; 0x02
    458c:	91 fb       	bst	r25, 1
    458e:	22 27       	eor	r18, r18
    4590:	20 f9       	bld	r18, 0
    4592:	30 e0       	ldi	r19, 0x00	; 0
    4594:	05 2e       	mov	r0, r21
    4596:	02 c0       	rjmp	.+4      	; 0x459c <vGpio_Init+0x1e0>
    4598:	22 0f       	add	r18, r18
    459a:	33 1f       	adc	r19, r19
    459c:	0a 94       	dec	r0
    459e:	e2 f7       	brpl	.-8      	; 0x4598 <vGpio_Init+0x1dc>
    45a0:	28 2b       	or	r18, r24
    45a2:	63 81       	ldd	r22, Z+3	; 0x03
    45a4:	70 e0       	ldi	r23, 0x00	; 0
    45a6:	cb 01       	movw	r24, r22
    45a8:	02 c0       	rjmp	.+4      	; 0x45ae <vGpio_Init+0x1f2>
    45aa:	88 0f       	add	r24, r24
    45ac:	99 1f       	adc	r25, r25
    45ae:	5a 95       	dec	r21
    45b0:	e2 f7       	brpl	.-8      	; 0x45aa <vGpio_Init+0x1ee>
    45b2:	ac 01       	movw	r20, r24
    45b4:	42 2b       	or	r20, r18
    45b6:	42 bb       	out	0x12, r20	; 18
					break;
	default:break;
	}
}
    45b8:	df 91       	pop	r29
    45ba:	cf 91       	pop	r28
    45bc:	1f 91       	pop	r17
    45be:	0f 91       	pop	r16
    45c0:	ff 90       	pop	r15
    45c2:	ef 90       	pop	r14
    45c4:	df 90       	pop	r13
    45c6:	cf 90       	pop	r12
    45c8:	08 95       	ret

000045ca <vGpio_Write>:
//-------------------------------------------------------------------
void vGpio_Write(gpio_write_param_t * gpio_param)
{
    45ca:	fc 01       	movw	r30, r24
		//check port
		switch(gpio_param->port)
    45cc:	80 81       	ld	r24, Z
    45ce:	81 30       	cpi	r24, 0x01	; 1
    45d0:	09 f1       	breq	.+66     	; 0x4614 <vGpio_Write+0x4a>
    45d2:	30 f0       	brcs	.+12     	; 0x45e0 <vGpio_Write+0x16>
    45d4:	82 30       	cpi	r24, 0x02	; 2
    45d6:	c1 f1       	breq	.+112    	; 0x4648 <vGpio_Write+0x7e>
    45d8:	83 30       	cpi	r24, 0x03	; 3
    45da:	09 f0       	breq	.+2      	; 0x45de <vGpio_Write+0x14>
    45dc:	68 c0       	rjmp	.+208    	; 0x46ae <vGpio_Write+0xe4>
    45de:	4e c0       	rjmp	.+156    	; 0x467c <vGpio_Write+0xb2>
		{
			case GPIO_PORT1 :
							PORTA = (PORTA & ~(1<<gpio_param->pin)) | (gpio_param->output<<gpio_param->pin);
    45e0:	6b b3       	in	r22, 0x1b	; 27
    45e2:	91 81       	ldd	r25, Z+1	; 0x01
    45e4:	41 e0       	ldi	r20, 0x01	; 1
    45e6:	50 e0       	ldi	r21, 0x00	; 0
    45e8:	9a 01       	movw	r18, r20
    45ea:	09 2e       	mov	r0, r25
    45ec:	02 c0       	rjmp	.+4      	; 0x45f2 <vGpio_Write+0x28>
    45ee:	22 0f       	add	r18, r18
    45f0:	33 1f       	adc	r19, r19
    45f2:	0a 94       	dec	r0
    45f4:	e2 f7       	brpl	.-8      	; 0x45ee <vGpio_Write+0x24>
    45f6:	20 95       	com	r18
    45f8:	42 2f       	mov	r20, r18
    45fa:	46 23       	and	r20, r22
    45fc:	22 81       	ldd	r18, Z+2	; 0x02
    45fe:	30 e0       	ldi	r19, 0x00	; 0
    4600:	b9 01       	movw	r22, r18
    4602:	02 c0       	rjmp	.+4      	; 0x4608 <vGpio_Write+0x3e>
    4604:	66 0f       	add	r22, r22
    4606:	77 1f       	adc	r23, r23
    4608:	9a 95       	dec	r25
    460a:	e2 f7       	brpl	.-8      	; 0x4604 <vGpio_Write+0x3a>
    460c:	cb 01       	movw	r24, r22
    460e:	84 2b       	or	r24, r20
    4610:	8b bb       	out	0x1b, r24	; 27
							break;
    4612:	08 95       	ret
			case GPIO_PORT2 :
							PORTB = (PORTB & ~(1<<gpio_param->pin)) |  (gpio_param->output<<gpio_param->pin);
    4614:	68 b3       	in	r22, 0x18	; 24
    4616:	91 81       	ldd	r25, Z+1	; 0x01
    4618:	41 e0       	ldi	r20, 0x01	; 1
    461a:	50 e0       	ldi	r21, 0x00	; 0
    461c:	9a 01       	movw	r18, r20
    461e:	09 2e       	mov	r0, r25
    4620:	02 c0       	rjmp	.+4      	; 0x4626 <vGpio_Write+0x5c>
    4622:	22 0f       	add	r18, r18
    4624:	33 1f       	adc	r19, r19
    4626:	0a 94       	dec	r0
    4628:	e2 f7       	brpl	.-8      	; 0x4622 <vGpio_Write+0x58>
    462a:	20 95       	com	r18
    462c:	42 2f       	mov	r20, r18
    462e:	46 23       	and	r20, r22
    4630:	22 81       	ldd	r18, Z+2	; 0x02
    4632:	30 e0       	ldi	r19, 0x00	; 0
    4634:	b9 01       	movw	r22, r18
    4636:	02 c0       	rjmp	.+4      	; 0x463c <vGpio_Write+0x72>
    4638:	66 0f       	add	r22, r22
    463a:	77 1f       	adc	r23, r23
    463c:	9a 95       	dec	r25
    463e:	e2 f7       	brpl	.-8      	; 0x4638 <vGpio_Write+0x6e>
    4640:	cb 01       	movw	r24, r22
    4642:	84 2b       	or	r24, r20
    4644:	88 bb       	out	0x18, r24	; 24
							break;
    4646:	08 95       	ret
			case GPIO_PORT3 :
							PORTC = (PORTC & ~(1<<gpio_param->pin)) | (gpio_param->output<<gpio_param->pin);
    4648:	65 b3       	in	r22, 0x15	; 21
    464a:	91 81       	ldd	r25, Z+1	; 0x01
    464c:	41 e0       	ldi	r20, 0x01	; 1
    464e:	50 e0       	ldi	r21, 0x00	; 0
    4650:	9a 01       	movw	r18, r20
    4652:	09 2e       	mov	r0, r25
    4654:	02 c0       	rjmp	.+4      	; 0x465a <vGpio_Write+0x90>
    4656:	22 0f       	add	r18, r18
    4658:	33 1f       	adc	r19, r19
    465a:	0a 94       	dec	r0
    465c:	e2 f7       	brpl	.-8      	; 0x4656 <vGpio_Write+0x8c>
    465e:	20 95       	com	r18
    4660:	42 2f       	mov	r20, r18
    4662:	46 23       	and	r20, r22
    4664:	22 81       	ldd	r18, Z+2	; 0x02
    4666:	30 e0       	ldi	r19, 0x00	; 0
    4668:	b9 01       	movw	r22, r18
    466a:	02 c0       	rjmp	.+4      	; 0x4670 <vGpio_Write+0xa6>
    466c:	66 0f       	add	r22, r22
    466e:	77 1f       	adc	r23, r23
    4670:	9a 95       	dec	r25
    4672:	e2 f7       	brpl	.-8      	; 0x466c <vGpio_Write+0xa2>
    4674:	cb 01       	movw	r24, r22
    4676:	84 2b       	or	r24, r20
    4678:	85 bb       	out	0x15, r24	; 21
							break;
    467a:	08 95       	ret
			case GPIO_PORT4 :
							PORTD = (PORTD & ~(1<<gpio_param->pin)) |  (gpio_param->output<<gpio_param->pin);
    467c:	62 b3       	in	r22, 0x12	; 18
    467e:	91 81       	ldd	r25, Z+1	; 0x01
    4680:	41 e0       	ldi	r20, 0x01	; 1
    4682:	50 e0       	ldi	r21, 0x00	; 0
    4684:	9a 01       	movw	r18, r20
    4686:	09 2e       	mov	r0, r25
    4688:	02 c0       	rjmp	.+4      	; 0x468e <vGpio_Write+0xc4>
    468a:	22 0f       	add	r18, r18
    468c:	33 1f       	adc	r19, r19
    468e:	0a 94       	dec	r0
    4690:	e2 f7       	brpl	.-8      	; 0x468a <vGpio_Write+0xc0>
    4692:	20 95       	com	r18
    4694:	42 2f       	mov	r20, r18
    4696:	46 23       	and	r20, r22
    4698:	22 81       	ldd	r18, Z+2	; 0x02
    469a:	30 e0       	ldi	r19, 0x00	; 0
    469c:	b9 01       	movw	r22, r18
    469e:	02 c0       	rjmp	.+4      	; 0x46a4 <vGpio_Write+0xda>
    46a0:	66 0f       	add	r22, r22
    46a2:	77 1f       	adc	r23, r23
    46a4:	9a 95       	dec	r25
    46a6:	e2 f7       	brpl	.-8      	; 0x46a0 <vGpio_Write+0xd6>
    46a8:	cb 01       	movw	r24, r22
    46aa:	84 2b       	or	r24, r20
    46ac:	82 bb       	out	0x12, r24	; 18
    46ae:	08 95       	ret

000046b0 <Gpio_Read>:
//------------------------------------------------------------------
std_logic_t Gpio_Read(gpio_read_param_t * gpio_param)
{
	std_logic_t result=STD_LOGIC_LOW;
			//check port
			switch(gpio_param->port)
    46b0:	fc 01       	movw	r30, r24
    46b2:	20 81       	ld	r18, Z
    46b4:	21 30       	cpi	r18, 0x01	; 1
    46b6:	e1 f0       	breq	.+56     	; 0x46f0 <Gpio_Read+0x40>
    46b8:	30 f0       	brcs	.+12     	; 0x46c6 <Gpio_Read+0x16>
    46ba:	22 30       	cpi	r18, 0x02	; 2
    46bc:	71 f1       	breq	.+92     	; 0x471a <Gpio_Read+0x6a>
    46be:	23 30       	cpi	r18, 0x03	; 3
    46c0:	09 f0       	breq	.+2      	; 0x46c4 <Gpio_Read+0x14>
    46c2:	54 c0       	rjmp	.+168    	; 0x476c <Gpio_Read+0xbc>
    46c4:	3f c0       	rjmp	.+126    	; 0x4744 <Gpio_Read+0x94>
			{
				case GPIO_PORT1 :
								result=(PINA & (1<<(gpio_param->pin)))>>(gpio_param->pin);
    46c6:	29 b3       	in	r18, 0x19	; 25
    46c8:	fc 01       	movw	r30, r24
    46ca:	61 81       	ldd	r22, Z+1	; 0x01
    46cc:	41 e0       	ldi	r20, 0x01	; 1
    46ce:	50 e0       	ldi	r21, 0x00	; 0
    46d0:	ca 01       	movw	r24, r20
    46d2:	06 2e       	mov	r0, r22
    46d4:	02 c0       	rjmp	.+4      	; 0x46da <Gpio_Read+0x2a>
    46d6:	88 0f       	add	r24, r24
    46d8:	99 1f       	adc	r25, r25
    46da:	0a 94       	dec	r0
    46dc:	e2 f7       	brpl	.-8      	; 0x46d6 <Gpio_Read+0x26>
    46de:	30 e0       	ldi	r19, 0x00	; 0
    46e0:	82 23       	and	r24, r18
    46e2:	93 23       	and	r25, r19
    46e4:	02 c0       	rjmp	.+4      	; 0x46ea <Gpio_Read+0x3a>
    46e6:	95 95       	asr	r25
    46e8:	87 95       	ror	r24
    46ea:	6a 95       	dec	r22
    46ec:	e2 f7       	brpl	.-8      	; 0x46e6 <Gpio_Read+0x36>
								break;
    46ee:	08 95       	ret
				case GPIO_PORT2 :
								result=(PINB & (1<<(gpio_param->pin)))>>(gpio_param->pin);
    46f0:	26 b3       	in	r18, 0x16	; 22
    46f2:	fc 01       	movw	r30, r24
    46f4:	61 81       	ldd	r22, Z+1	; 0x01
    46f6:	41 e0       	ldi	r20, 0x01	; 1
    46f8:	50 e0       	ldi	r21, 0x00	; 0
    46fa:	ca 01       	movw	r24, r20
    46fc:	06 2e       	mov	r0, r22
    46fe:	02 c0       	rjmp	.+4      	; 0x4704 <Gpio_Read+0x54>
    4700:	88 0f       	add	r24, r24
    4702:	99 1f       	adc	r25, r25
    4704:	0a 94       	dec	r0
    4706:	e2 f7       	brpl	.-8      	; 0x4700 <Gpio_Read+0x50>
    4708:	30 e0       	ldi	r19, 0x00	; 0
    470a:	82 23       	and	r24, r18
    470c:	93 23       	and	r25, r19
    470e:	02 c0       	rjmp	.+4      	; 0x4714 <Gpio_Read+0x64>
    4710:	95 95       	asr	r25
    4712:	87 95       	ror	r24
    4714:	6a 95       	dec	r22
    4716:	e2 f7       	brpl	.-8      	; 0x4710 <Gpio_Read+0x60>
								break;
    4718:	08 95       	ret
				case GPIO_PORT3 :
								result=(PINC & (1<<(gpio_param->pin)))>>(gpio_param->pin);
    471a:	23 b3       	in	r18, 0x13	; 19
    471c:	fc 01       	movw	r30, r24
    471e:	61 81       	ldd	r22, Z+1	; 0x01
    4720:	41 e0       	ldi	r20, 0x01	; 1
    4722:	50 e0       	ldi	r21, 0x00	; 0
    4724:	ca 01       	movw	r24, r20
    4726:	06 2e       	mov	r0, r22
    4728:	02 c0       	rjmp	.+4      	; 0x472e <Gpio_Read+0x7e>
    472a:	88 0f       	add	r24, r24
    472c:	99 1f       	adc	r25, r25
    472e:	0a 94       	dec	r0
    4730:	e2 f7       	brpl	.-8      	; 0x472a <Gpio_Read+0x7a>
    4732:	30 e0       	ldi	r19, 0x00	; 0
    4734:	82 23       	and	r24, r18
    4736:	93 23       	and	r25, r19
    4738:	02 c0       	rjmp	.+4      	; 0x473e <Gpio_Read+0x8e>
    473a:	95 95       	asr	r25
    473c:	87 95       	ror	r24
    473e:	6a 95       	dec	r22
    4740:	e2 f7       	brpl	.-8      	; 0x473a <Gpio_Read+0x8a>
								break;
    4742:	08 95       	ret
				case GPIO_PORT4 :
								result=(PIND & (1<<(gpio_param->pin)))>>(gpio_param->pin);
    4744:	20 b3       	in	r18, 0x10	; 16
    4746:	fc 01       	movw	r30, r24
    4748:	41 81       	ldd	r20, Z+1	; 0x01
    474a:	81 e0       	ldi	r24, 0x01	; 1
    474c:	90 e0       	ldi	r25, 0x00	; 0
    474e:	04 2e       	mov	r0, r20
    4750:	02 c0       	rjmp	.+4      	; 0x4756 <Gpio_Read+0xa6>
    4752:	88 0f       	add	r24, r24
    4754:	99 1f       	adc	r25, r25
    4756:	0a 94       	dec	r0
    4758:	e2 f7       	brpl	.-8      	; 0x4752 <Gpio_Read+0xa2>
    475a:	30 e0       	ldi	r19, 0x00	; 0
    475c:	82 23       	and	r24, r18
    475e:	93 23       	and	r25, r19
    4760:	02 c0       	rjmp	.+4      	; 0x4766 <Gpio_Read+0xb6>
    4762:	95 95       	asr	r25
    4764:	87 95       	ror	r24
    4766:	4a 95       	dec	r20
    4768:	e2 f7       	brpl	.-8      	; 0x4762 <Gpio_Read+0xb2>
								break;
    476a:	08 95       	ret
		}
}
//------------------------------------------------------------------
std_logic_t Gpio_Read(gpio_read_param_t * gpio_param)
{
	std_logic_t result=STD_LOGIC_LOW;
    476c:	80 e0       	ldi	r24, 0x00	; 0
								result=(PIND & (1<<(gpio_param->pin)))>>(gpio_param->pin);
								break;
				default:break;
			}
	return result;
}
    476e:	08 95       	ret

00004770 <i2c_send>:
}
//------------------------------------------------------------------
static void i2c_send(u8 data)
{
	//send address and intterrupt flag
	TWDR=data;
    4770:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT) | (1<<TWEN);  //start transmition
    4772:	84 e8       	ldi	r24, 0x84	; 132
    4774:	86 bf       	out	0x36, r24	; 54
	//wait till operation finish
	while((TWCR & (1<<TWINT)) ==0);
    4776:	06 b6       	in	r0, 0x36	; 54
    4778:	07 fe       	sbrs	r0, 7
    477a:	fd cf       	rjmp	.-6      	; 0x4776 <i2c_send+0x6>
}
    477c:	08 95       	ret

0000477e <u8I2c_Init>:
static void i2c_send(u8 data);
static i2c_error_t i2c_read_ack(i2c_data_t* data);
static i2c_error_t i2c_read_nack(i2c_data_t* data);
//-----------------------------------------------------------------
i2c_init_status_t u8I2c_Init( const i2c_init_param_t* param )
{
    477e:	8f 92       	push	r8
    4780:	9f 92       	push	r9
    4782:	af 92       	push	r10
    4784:	bf 92       	push	r11
    4786:	cf 92       	push	r12
    4788:	df 92       	push	r13
    478a:	ef 92       	push	r14
    478c:	ff 92       	push	r15
    478e:	1f 93       	push	r17
    4790:	cf 93       	push	r28
    4792:	df 93       	push	r29
    4794:	ec 01       	movw	r28, r24
	if(g_i2c_init_flag==0)
    4796:	80 91 e1 01 	lds	r24, 0x01E1
    479a:	81 11       	cpse	r24, r1
    479c:	5b c0       	rjmp	.+182    	; 0x4854 <u8I2c_Init+0xd6>
		//set the frequency
		//test all prescaler till find the right config
		for(index=0;index<4;index++)
		{
			//calculate TWBR for this configuration
			freq_temp =((float)(param->sysclk)/(param->frequency));
    479e:	68 81       	ld	r22, Y
    47a0:	79 81       	ldd	r23, Y+1	; 0x01
    47a2:	8a 81       	ldd	r24, Y+2	; 0x02
    47a4:	9b 81       	ldd	r25, Y+3	; 0x03
    47a6:	0e 94 72 33 	call	0x66e4	; 0x66e4 <__floatunsisf>
    47aa:	6b 01       	movw	r12, r22
    47ac:	7c 01       	movw	r14, r24
    47ae:	6c 81       	ldd	r22, Y+4	; 0x04
    47b0:	7d 81       	ldd	r23, Y+5	; 0x05
    47b2:	8e 81       	ldd	r24, Y+6	; 0x06
    47b4:	9f 81       	ldd	r25, Y+7	; 0x07
    47b6:	0e 94 72 33 	call	0x66e4	; 0x66e4 <__floatunsisf>
    47ba:	9b 01       	movw	r18, r22
    47bc:	ac 01       	movw	r20, r24
    47be:	c7 01       	movw	r24, r14
    47c0:	b6 01       	movw	r22, r12
    47c2:	0e 94 de 32 	call	0x65bc	; 0x65bc <__divsf3>
    47c6:	0e 94 46 33 	call	0x668c	; 0x668c <__fixunssfsi>
			freq_temp =(freq_temp -(16U));
    47ca:	60 51       	subi	r22, 0x10	; 16
    47cc:	71 09       	sbc	r23, r1
			temp=(((2U) * pow(4,index)));
			freq_temp= (freq_temp) / (temp) ;
    47ce:	4b 01       	movw	r8, r22
    47d0:	a1 2c       	mov	r10, r1
    47d2:	b1 2c       	mov	r11, r1
    47d4:	10 e0       	ldi	r17, 0x00	; 0
		for(index=0;index<4;index++)
		{
			//calculate TWBR for this configuration
			freq_temp =((float)(param->sysclk)/(param->frequency));
			freq_temp =(freq_temp -(16U));
			temp=(((2U) * pow(4,index)));
    47d6:	61 2f       	mov	r22, r17
    47d8:	70 e0       	ldi	r23, 0x00	; 0
    47da:	80 e0       	ldi	r24, 0x00	; 0
    47dc:	90 e0       	ldi	r25, 0x00	; 0
    47de:	0e 94 72 33 	call	0x66e4	; 0x66e4 <__floatunsisf>
    47e2:	9b 01       	movw	r18, r22
    47e4:	ac 01       	movw	r20, r24
    47e6:	60 e0       	ldi	r22, 0x00	; 0
    47e8:	70 e0       	ldi	r23, 0x00	; 0
    47ea:	80 e8       	ldi	r24, 0x80	; 128
    47ec:	90 e4       	ldi	r25, 0x40	; 64
    47ee:	0e 94 00 34 	call	0x6800	; 0x6800 <pow>
    47f2:	26 2f       	mov	r18, r22
    47f4:	37 2f       	mov	r19, r23
    47f6:	48 2f       	mov	r20, r24
    47f8:	59 2f       	mov	r21, r25
    47fa:	0e 94 7a 32 	call	0x64f4	; 0x64f4 <__addsf3>
    47fe:	0e 94 46 33 	call	0x668c	; 0x668c <__fixunssfsi>
    4802:	9b 01       	movw	r18, r22
    4804:	ac 01       	movw	r20, r24
			freq_temp= (freq_temp) / (temp) ;
    4806:	c5 01       	movw	r24, r10
    4808:	b4 01       	movw	r22, r8
    480a:	0e 94 c8 35 	call	0x6b90	; 0x6b90 <__udivmodsi4>
    480e:	82 2f       	mov	r24, r18
			if(freq_temp>0xFF || freq_temp==0x00)
    4810:	21 50       	subi	r18, 0x01	; 1
    4812:	31 09       	sbc	r19, r1
    4814:	2f 3f       	cpi	r18, 0xFF	; 255
    4816:	31 05       	cpc	r19, r1
    4818:	28 f0       	brcs	.+10     	; 0x4824 <u8I2c_Init+0xa6>
		u16 freq_temp=0;
		u32 temp=0;
		i2c_init_status_t status=I2C_NO_INIT_ERROR;
		//set the frequency
		//test all prescaler till find the right config
		for(index=0;index<4;index++)
    481a:	1f 5f       	subi	r17, 0xFF	; 255
    481c:	14 30       	cpi	r17, 0x04	; 4
    481e:	d9 f6       	brne	.-74     	; 0x47d6 <u8I2c_Init+0x58>
				break;
			}
		}
		if(status==I2C_FREQ_OUT_OF_RANGE_ERROR)
		{
			return I2C_FREQ_OUT_OF_RANGE_ERROR;
    4820:	81 e0       	ldi	r24, 0x01	; 1
    4822:	19 c0       	rjmp	.+50     	; 0x4856 <u8I2c_Init+0xd8>
				status=I2C_FREQ_OUT_OF_RANGE_ERROR;
				continue;
			}
			else
			{
				TWBR=(u8)freq_temp;
    4824:	80 b9       	out	0x00, r24	; 0
			return I2C_FREQ_OUT_OF_RANGE_ERROR;
		}
		//set interrupt
	
		//set isr callback
		if(param->ptr !=NULL)
    4826:	8b 85       	ldd	r24, Y+11	; 0x0b
    4828:	9c 85       	ldd	r25, Y+12	; 0x0c
    482a:	89 2b       	or	r24, r25
    482c:	49 f0       	breq	.+18     	; 0x4840 <u8I2c_Init+0xc2>
		{
			set_bit(TWCR,TWIE);
    482e:	86 b7       	in	r24, 0x36	; 54
    4830:	81 60       	ori	r24, 0x01	; 1
    4832:	86 bf       	out	0x36, r24	; 54
			g_isr_ptr=param->ptr;
    4834:	8b 85       	ldd	r24, Y+11	; 0x0b
    4836:	9c 85       	ldd	r25, Y+12	; 0x0c
    4838:	90 93 e3 01 	sts	0x01E3, r25
    483c:	80 93 e2 01 	sts	0x01E2, r24
		}
		//set slave address
		if(param->slave_address !=0)
    4840:	8a 85       	ldd	r24, Y+10	; 0x0a
    4842:	81 11       	cpse	r24, r1
		{
			TWAR=param->slave_address;
    4844:	82 b9       	out	0x02, r24	; 2
		}
		//enable i2c
		TWCR =(1<<TWEN);
    4846:	84 e0       	ldi	r24, 0x04	; 4
    4848:	86 bf       	out	0x36, r24	; 54
		g_i2c_init_flag=1;
    484a:	81 e0       	ldi	r24, 0x01	; 1
    484c:	80 93 e1 01 	sts	0x01E1, r24
		return I2C_NO_INIT_ERROR;
    4850:	80 e0       	ldi	r24, 0x00	; 0
    4852:	01 c0       	rjmp	.+2      	; 0x4856 <u8I2c_Init+0xd8>
	}
	else
	{
		
		return I2C_PREV_INIT;
    4854:	87 e0       	ldi	r24, 0x07	; 7
	}	
}
    4856:	df 91       	pop	r29
    4858:	cf 91       	pop	r28
    485a:	1f 91       	pop	r17
    485c:	ff 90       	pop	r15
    485e:	ef 90       	pop	r14
    4860:	df 90       	pop	r13
    4862:	cf 90       	pop	r12
    4864:	bf 90       	pop	r11
    4866:	af 90       	pop	r10
    4868:	9f 90       	pop	r9
    486a:	8f 90       	pop	r8
    486c:	08 95       	ret

0000486e <__vector_19>:
//----------------------------------------------------------------
ISR(TWI_vect)
{
    486e:	1f 92       	push	r1
    4870:	0f 92       	push	r0
    4872:	0f b6       	in	r0, 0x3f	; 63
    4874:	0f 92       	push	r0
    4876:	11 24       	eor	r1, r1
    4878:	2f 93       	push	r18
    487a:	3f 93       	push	r19
    487c:	4f 93       	push	r20
    487e:	5f 93       	push	r21
    4880:	6f 93       	push	r22
    4882:	7f 93       	push	r23
    4884:	8f 93       	push	r24
    4886:	9f 93       	push	r25
    4888:	af 93       	push	r26
    488a:	bf 93       	push	r27
    488c:	ef 93       	push	r30
    488e:	ff 93       	push	r31
	if(g_isr_ptr != NULL)
    4890:	e0 91 e2 01 	lds	r30, 0x01E2
    4894:	f0 91 e3 01 	lds	r31, 0x01E3
    4898:	30 97       	sbiw	r30, 0x00	; 0
    489a:	09 f0       	breq	.+2      	; 0x489e <__vector_19+0x30>
	{
		g_isr_ptr();
    489c:	09 95       	icall
	}
}
    489e:	ff 91       	pop	r31
    48a0:	ef 91       	pop	r30
    48a2:	bf 91       	pop	r27
    48a4:	af 91       	pop	r26
    48a6:	9f 91       	pop	r25
    48a8:	8f 91       	pop	r24
    48aa:	7f 91       	pop	r23
    48ac:	6f 91       	pop	r22
    48ae:	5f 91       	pop	r21
    48b0:	4f 91       	pop	r20
    48b2:	3f 91       	pop	r19
    48b4:	2f 91       	pop	r18
    48b6:	0f 90       	pop	r0
    48b8:	0f be       	out	0x3f, r0	; 63
    48ba:	0f 90       	pop	r0
    48bc:	1f 90       	pop	r1
    48be:	18 95       	reti

000048c0 <u8I2c_Start>:
//-------------------------------------------------------------------
i2c_error_t u8I2c_Start(void)
{
	//send start condition and intterrupt flag
	TWCR= (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    48c0:	84 ea       	ldi	r24, 0xA4	; 164
    48c2:	86 bf       	out	0x36, r24	; 54
	//wait till operation finish
	while((TWCR & (1<<TWINT)) ==0);
    48c4:	06 b6       	in	r0, 0x36	; 54
    48c6:	07 fe       	sbrs	r0, 7
    48c8:	fd cf       	rjmp	.-6      	; 0x48c4 <u8I2c_Start+0x4>
	//check status 
	if((TWSR & (STATUS_REG_MASK)) !=START_CONDITION_STATE)
    48ca:	81 b1       	in	r24, 0x01	; 1
    48cc:	88 7f       	andi	r24, 0xF8	; 248
    48ce:	88 30       	cpi	r24, 0x08	; 8
    48d0:	11 f0       	breq	.+4      	; 0x48d6 <u8I2c_Start+0x16>
	{
		return I2C_START_ERROR;
    48d2:	83 e0       	ldi	r24, 0x03	; 3
    48d4:	08 95       	ret
	}
	else
	{
		return I2C_NO_ERROR;
    48d6:	82 e0       	ldi	r24, 0x02	; 2
	}
}
    48d8:	08 95       	ret

000048da <u8I2c_Send_Address>:
//--------------------------------------------------------------------
i2c_error_t u8I2c_Send_Address(i2c_address_t address,u8 w_r)
{
	switch(w_r)
    48da:	66 23       	and	r22, r22
    48dc:	19 f0       	breq	.+6      	; 0x48e4 <u8I2c_Send_Address+0xa>
    48de:	61 30       	cpi	r22, 0x01	; 1
    48e0:	91 f4       	brne	.+36     	; 0x4906 <u8I2c_Send_Address+0x2c>
    48e2:	08 c0       	rjmp	.+16     	; 0x48f4 <u8I2c_Send_Address+0x1a>
	{
		case I2C_WRITE  :
						i2c_send(address);
    48e4:	0e 94 b8 23 	call	0x4770	; 0x4770 <i2c_send>
						if((TWSR & (STATUS_REG_MASK)) !=SLAVE_ADDRESS_WRITE_ACK_STATE)
    48e8:	81 b1       	in	r24, 0x01	; 1
    48ea:	88 7f       	andi	r24, 0xF8	; 248
    48ec:	88 31       	cpi	r24, 0x18	; 24
    48ee:	69 f0       	breq	.+26     	; 0x490a <u8I2c_Send_Address+0x30>
						{
							return I2C_SEND_ADDRESS_ERROR;
    48f0:	84 e0       	ldi	r24, 0x04	; 4
    48f2:	08 95       	ret
						{
							return I2C_NO_ERROR;
						}
						break;
		case I2C_READ   :
						i2c_send(address+I2C_READ);
    48f4:	8f 5f       	subi	r24, 0xFF	; 255
    48f6:	0e 94 b8 23 	call	0x4770	; 0x4770 <i2c_send>
						if((TWSR & (STATUS_REG_MASK)) !=SLAVE_ADDRESS_READ_ACK_STATE)
    48fa:	81 b1       	in	r24, 0x01	; 1
    48fc:	88 7f       	andi	r24, 0xF8	; 248
    48fe:	80 34       	cpi	r24, 0x40	; 64
    4900:	31 f0       	breq	.+12     	; 0x490e <u8I2c_Send_Address+0x34>
						{
							return I2C_SEND_ADDRESS_ERROR;
    4902:	84 e0       	ldi	r24, 0x04	; 4
    4904:	08 95       	ret
						else
						{
							return I2C_NO_ERROR;
						}
						break;
		default:return I2C_SEND_ADDRESS_ERROR;
    4906:	84 e0       	ldi	r24, 0x04	; 4
    4908:	08 95       	ret
						{
							return I2C_SEND_ADDRESS_ERROR;
						}
						else
						{
							return I2C_NO_ERROR;
    490a:	82 e0       	ldi	r24, 0x02	; 2
    490c:	08 95       	ret
						{
							return I2C_SEND_ADDRESS_ERROR;
						}
						else
						{
							return I2C_NO_ERROR;
    490e:	82 e0       	ldi	r24, 0x02	; 2
						}
						break;
		default:return I2C_SEND_ADDRESS_ERROR;
	}
}
    4910:	08 95       	ret

00004912 <u8I2c_Send_Data>:
	while((TWCR & (1<<TWINT)) ==0);
}
//--------------------------------------------------------------------
i2c_error_t u8I2c_Send_Data(i2c_data_t data)
{
	i2c_send(data);
    4912:	0e 94 b8 23 	call	0x4770	; 0x4770 <i2c_send>
	if((TWSR & (STATUS_REG_MASK)) !=DATA_SEND_ACk_STATE)
    4916:	81 b1       	in	r24, 0x01	; 1
    4918:	88 7f       	andi	r24, 0xF8	; 248
    491a:	88 32       	cpi	r24, 0x28	; 40
    491c:	11 f0       	breq	.+4      	; 0x4922 <u8I2c_Send_Data+0x10>
	{
		return I2C_SEND_DATA_ERROR;
    491e:	85 e0       	ldi	r24, 0x05	; 5
    4920:	08 95       	ret
	}
	else
	{
		return I2C_NO_ERROR;
    4922:	82 e0       	ldi	r24, 0x02	; 2
	}
	
}
    4924:	08 95       	ret

00004926 <vI2c_Stop>:
//---------------------------------------------------------------
void vI2c_Stop(void)
{
		TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    4926:	84 e9       	ldi	r24, 0x94	; 148
    4928:	86 bf       	out	0x36, r24	; 54
    492a:	08 95       	ret

0000492c <u8I2c_Restart>:
}
//----------------------------------------------
i2c_error_t u8I2c_Restart(void)
{
		//send start condition and intterrupt flag
		TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTA);
    492c:	84 ea       	ldi	r24, 0xA4	; 164
    492e:	86 bf       	out	0x36, r24	; 54
		//wait till operation finish
		while((TWCR & (1<<TWINT)) ==0);
    4930:	06 b6       	in	r0, 0x36	; 54
    4932:	07 fe       	sbrs	r0, 7
    4934:	fd cf       	rjmp	.-6      	; 0x4930 <u8I2c_Restart+0x4>
		//check status
		if((TWSR & (STATUS_REG_MASK)) !=RESTART_CONDITION_STATE)
    4936:	81 b1       	in	r24, 0x01	; 1
    4938:	88 7f       	andi	r24, 0xF8	; 248
    493a:	80 31       	cpi	r24, 0x10	; 16
    493c:	11 f0       	breq	.+4      	; 0x4942 <u8I2c_Restart+0x16>
		{
			return I2C_START_ERROR;
    493e:	83 e0       	ldi	r24, 0x03	; 3
    4940:	08 95       	ret
		}
		else
		{
			return I2C_NO_ERROR;
    4942:	82 e0       	ldi	r24, 0x02	; 2
		}
}
    4944:	08 95       	ret

00004946 <u8I2c_Read_Data>:
i2c_error_t u8I2c_Read_Data(i2c_data_t* data,u8 count)
{
	i2c_error_t error= I2C_NO_ERROR;
	u8 index=0;
	//check count >0
	if(count==0)
    4946:	66 23       	and	r22, r22
    4948:	b9 f1       	breq	.+110    	; 0x49b8 <u8I2c_Read_Data+0x72>
	{
		return I2C_READ_DATA_ERROR;
	}

	for(index=count;index>1;index--)
    494a:	62 30       	cpi	r22, 0x02	; 2
    494c:	00 f1       	brcs	.+64     	; 0x498e <u8I2c_Read_Data+0x48>
    494e:	fc 01       	movw	r30, r24
    4950:	36 2f       	mov	r19, r22
    4952:	42 e0       	ldi	r20, 0x02	; 2
}
//------------------------------------------------------------
static i2c_error_t i2c_read_ack(i2c_data_t* data)
{
	//start read
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    4954:	74 ec       	ldi	r23, 0xC4	; 196
	//wait till end of receive
	while((TWCR & (1<<TWINT)) ==0);
	//check sucsses
	if((TWSR & (STATUS_REG_MASK)) !=DATA_READ_ACK_STATE)
	{
		return I2C_READ_DATA_ERROR;
    4956:	a6 e0       	ldi	r26, 0x06	; 6
	}
	else
	{
		*data=TWDR;
		return I2C_NO_ERROR;
    4958:	22 e0       	ldi	r18, 0x02	; 2
}
//------------------------------------------------------------
static i2c_error_t i2c_read_ack(i2c_data_t* data)
{
	//start read
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    495a:	76 bf       	out	0x36, r23	; 54
	//wait till end of receive
	while((TWCR & (1<<TWINT)) ==0);
    495c:	06 b6       	in	r0, 0x36	; 54
    495e:	07 fe       	sbrs	r0, 7
    4960:	fd cf       	rjmp	.-6      	; 0x495c <u8I2c_Read_Data+0x16>
	//check sucsses
	if((TWSR & (STATUS_REG_MASK)) !=DATA_READ_ACK_STATE)
    4962:	51 b1       	in	r21, 0x01	; 1
    4964:	58 7f       	andi	r21, 0xF8	; 248
    4966:	50 35       	cpi	r21, 0x50	; 80
    4968:	21 f4       	brne	.+8      	; 0x4972 <u8I2c_Read_Data+0x2c>
	{
		return I2C_READ_DATA_ERROR;
	}
	else
	{
		*data=TWDR;
    496a:	53 b1       	in	r21, 0x03	; 3
    496c:	50 83       	st	Z, r21
		return I2C_NO_ERROR;
    496e:	52 2f       	mov	r21, r18
    4970:	01 c0       	rjmp	.+2      	; 0x4974 <u8I2c_Read_Data+0x2e>
	//wait till end of receive
	while((TWCR & (1<<TWINT)) ==0);
	//check sucsses
	if((TWSR & (STATUS_REG_MASK)) !=DATA_READ_ACK_STATE)
	{
		return I2C_READ_DATA_ERROR;
    4972:	5a 2f       	mov	r21, r26
		return I2C_READ_DATA_ERROR;
	}

	for(index=count;index>1;index--)
	{
		error |=i2c_read_ack(data++);
    4974:	45 2b       	or	r20, r21
	if(count==0)
	{
		return I2C_READ_DATA_ERROR;
	}

	for(index=count;index>1;index--)
    4976:	31 50       	subi	r19, 0x01	; 1
    4978:	31 96       	adiw	r30, 0x01	; 1
    497a:	31 30       	cpi	r19, 0x01	; 1
    497c:	71 f7       	brne	.-36     	; 0x495a <u8I2c_Read_Data+0x14>
		{
			return I2C_NO_ERROR;
		}
}
//---------------------------------------------------------
i2c_error_t u8I2c_Read_Data(i2c_data_t* data,u8 count)
    497e:	62 50       	subi	r22, 0x02	; 2
    4980:	26 2f       	mov	r18, r22
    4982:	30 e0       	ldi	r19, 0x00	; 0
    4984:	2f 5f       	subi	r18, 0xFF	; 255
    4986:	3f 4f       	sbci	r19, 0xFF	; 255
    4988:	82 0f       	add	r24, r18
    498a:	93 1f       	adc	r25, r19
    498c:	01 c0       	rjmp	.+2      	; 0x4990 <u8I2c_Read_Data+0x4a>
	if(count==0)
	{
		return I2C_READ_DATA_ERROR;
	}

	for(index=count;index>1;index--)
    498e:	42 e0       	ldi	r20, 0x02	; 2
}
//----------------------------------------------------
static i2c_error_t i2c_read_nack(i2c_data_t* data)
{
		//start read
		TWCR = (1<<TWINT) | (1<<TWEN);
    4990:	24 e8       	ldi	r18, 0x84	; 132
    4992:	26 bf       	out	0x36, r18	; 54
		while((TWCR & (1<<TWINT)) ==0);
    4994:	06 b6       	in	r0, 0x36	; 54
    4996:	07 fe       	sbrs	r0, 7
    4998:	fd cf       	rjmp	.-6      	; 0x4994 <u8I2c_Read_Data+0x4e>
		//check sucsses
		if((TWSR & (STATUS_REG_MASK)) !=DATA_READ_NACK_STATE)
    499a:	21 b1       	in	r18, 0x01	; 1
    499c:	28 7f       	andi	r18, 0xF8	; 248
    499e:	28 35       	cpi	r18, 0x58	; 88
    49a0:	29 f4       	brne	.+10     	; 0x49ac <u8I2c_Read_Data+0x66>
		{
			return I2C_READ_DATA_ERROR;
		}
		else
		{
			*data=TWDR;
    49a2:	23 b1       	in	r18, 0x03	; 3
    49a4:	fc 01       	movw	r30, r24
    49a6:	20 83       	st	Z, r18
			return I2C_NO_ERROR;
    49a8:	82 e0       	ldi	r24, 0x02	; 2
    49aa:	01 c0       	rjmp	.+2      	; 0x49ae <u8I2c_Read_Data+0x68>
		TWCR = (1<<TWINT) | (1<<TWEN);
		while((TWCR & (1<<TWINT)) ==0);
		//check sucsses
		if((TWSR & (STATUS_REG_MASK)) !=DATA_READ_NACK_STATE)
		{
			return I2C_READ_DATA_ERROR;
    49ac:	86 e0       	ldi	r24, 0x06	; 6

	for(index=count;index>1;index--)
	{
		error |=i2c_read_ack(data++);
	}
	error |=i2c_read_nack(data);
    49ae:	48 2b       	or	r20, r24
	if(error!=I2C_NO_ERROR)
    49b0:	42 30       	cpi	r20, 0x02	; 2
    49b2:	21 f0       	breq	.+8      	; 0x49bc <u8I2c_Read_Data+0x76>
	{
		return I2C_READ_DATA_ERROR;
    49b4:	86 e0       	ldi	r24, 0x06	; 6
    49b6:	08 95       	ret
	i2c_error_t error= I2C_NO_ERROR;
	u8 index=0;
	//check count >0
	if(count==0)
	{
		return I2C_READ_DATA_ERROR;
    49b8:	86 e0       	ldi	r24, 0x06	; 6
    49ba:	08 95       	ret
	if(error!=I2C_NO_ERROR)
	{
		return I2C_READ_DATA_ERROR;
	}else
	{
		return I2C_NO_ERROR;
    49bc:	82 e0       	ldi	r24, 0x02	; 2
	}
}
    49be:	08 95       	ret

000049c0 <u8I2c_Send_Stream>:
			return I2C_NO_ERROR;
		}
}
//--------------------------------------------------------
i2c_error_t u8I2c_Send_Stream(i2c_data_t* data,u8 count)
{
    49c0:	ff 92       	push	r15
    49c2:	0f 93       	push	r16
    49c4:	1f 93       	push	r17
    49c6:	cf 93       	push	r28
    49c8:	df 93       	push	r29
	u8 index;
	i2c_error_t error=I2C_NO_ERROR;
	if(count==0)
    49ca:	66 23       	and	r22, r22
    49cc:	99 f0       	breq	.+38     	; 0x49f4 <u8I2c_Send_Stream+0x34>
    49ce:	c8 2f       	mov	r28, r24
    49d0:	d9 2f       	mov	r29, r25
			*data=TWDR;
			return I2C_NO_ERROR;
		}
}
//--------------------------------------------------------
i2c_error_t u8I2c_Send_Stream(i2c_data_t* data,u8 count)
    49d2:	8e 01       	movw	r16, r28
    49d4:	0f 5f       	subi	r16, 0xFF	; 255
    49d6:	1f 4f       	sbci	r17, 0xFF	; 255
    49d8:	61 50       	subi	r22, 0x01	; 1
    49da:	06 0f       	add	r16, r22
    49dc:	11 1d       	adc	r17, r1
    49de:	68 94       	set
    49e0:	ff 24       	eor	r15, r15
    49e2:	f1 f8       	bld	r15, 1
	{
		return I2C_SEND_DATA_ERROR;
	}
	for(index=0;index<count;index++)
	{
		error|=u8I2c_Send_Data(data[index]);
    49e4:	89 91       	ld	r24, Y+
    49e6:	0e 94 89 24 	call	0x4912	; 0x4912 <u8I2c_Send_Data>
    49ea:	f8 2a       	or	r15, r24
	i2c_error_t error=I2C_NO_ERROR;
	if(count==0)
	{
		return I2C_SEND_DATA_ERROR;
	}
	for(index=0;index<count;index++)
    49ec:	c0 17       	cp	r28, r16
    49ee:	d1 07       	cpc	r29, r17
    49f0:	c9 f7       	brne	.-14     	; 0x49e4 <u8I2c_Send_Stream+0x24>
    49f2:	04 c0       	rjmp	.+8      	; 0x49fc <u8I2c_Send_Stream+0x3c>
{
	u8 index;
	i2c_error_t error=I2C_NO_ERROR;
	if(count==0)
	{
		return I2C_SEND_DATA_ERROR;
    49f4:	0f 2e       	mov	r0, r31
    49f6:	f5 e0       	ldi	r31, 0x05	; 5
    49f8:	ff 2e       	mov	r15, r31
    49fa:	f0 2d       	mov	r31, r0
	{
		error|=u8I2c_Send_Data(data[index]);
	}
	return error;
	
}
    49fc:	8f 2d       	mov	r24, r15
    49fe:	df 91       	pop	r29
    4a00:	cf 91       	pop	r28
    4a02:	1f 91       	pop	r17
    4a04:	0f 91       	pop	r16
    4a06:	ff 90       	pop	r15
    4a08:	08 95       	ret

00004a0a <set_prescaler2>:
}
//--------------------------------------------------------------

static void set_prescaler2(pwm2_prescaler_t prescaler)
{
	switch(prescaler)
    4a0a:	83 30       	cpi	r24, 0x03	; 3
    4a0c:	51 f1       	breq	.+84     	; 0x4a62 <set_prescaler2+0x58>
    4a0e:	20 f4       	brcc	.+8      	; 0x4a18 <set_prescaler2+0xe>
    4a10:	81 30       	cpi	r24, 0x01	; 1
    4a12:	99 f0       	breq	.+38     	; 0x4a3a <set_prescaler2+0x30>
    4a14:	e0 f4       	brcc	.+56     	; 0x4a4e <set_prescaler2+0x44>
    4a16:	07 c0       	rjmp	.+14     	; 0x4a26 <set_prescaler2+0x1c>
    4a18:	85 30       	cpi	r24, 0x05	; 5
    4a1a:	b9 f1       	breq	.+110    	; 0x4a8a <set_prescaler2+0x80>
    4a1c:	60 f1       	brcs	.+88     	; 0x4a76 <set_prescaler2+0x6c>
    4a1e:	86 30       	cpi	r24, 0x06	; 6
    4a20:	09 f0       	breq	.+2      	; 0x4a24 <set_prescaler2+0x1a>
    4a22:	47 c0       	rjmp	.+142    	; 0x4ab2 <set_prescaler2+0xa8>
    4a24:	3c c0       	rjmp	.+120    	; 0x4a9e <set_prescaler2+0x94>
	{
		case PWM2_BY1_PRESCALER      :clear_bit(TCCR2,CS22);clear_bit(TCCR2,CS21);set_bit(TCCR2,CS20);break;
    4a26:	85 b5       	in	r24, 0x25	; 37
    4a28:	8b 7f       	andi	r24, 0xFB	; 251
    4a2a:	85 bd       	out	0x25, r24	; 37
    4a2c:	85 b5       	in	r24, 0x25	; 37
    4a2e:	8d 7f       	andi	r24, 0xFD	; 253
    4a30:	85 bd       	out	0x25, r24	; 37
    4a32:	85 b5       	in	r24, 0x25	; 37
    4a34:	81 60       	ori	r24, 0x01	; 1
    4a36:	85 bd       	out	0x25, r24	; 37
    4a38:	08 95       	ret
		case PWM2_BY8_PRESCALER      :clear_bit(TCCR2,CS22);set_bit(TCCR2,CS21)  ;clear_bit(TCCR2,CS20);break;
    4a3a:	85 b5       	in	r24, 0x25	; 37
    4a3c:	8b 7f       	andi	r24, 0xFB	; 251
    4a3e:	85 bd       	out	0x25, r24	; 37
    4a40:	85 b5       	in	r24, 0x25	; 37
    4a42:	82 60       	ori	r24, 0x02	; 2
    4a44:	85 bd       	out	0x25, r24	; 37
    4a46:	85 b5       	in	r24, 0x25	; 37
    4a48:	8e 7f       	andi	r24, 0xFE	; 254
    4a4a:	85 bd       	out	0x25, r24	; 37
    4a4c:	08 95       	ret
		case PWM2_BY32_PRESCALER     :clear_bit(TCCR2,CS22);set_bit(TCCR2,CS21);set_bit(TCCR2,CS20);break;
    4a4e:	85 b5       	in	r24, 0x25	; 37
    4a50:	8b 7f       	andi	r24, 0xFB	; 251
    4a52:	85 bd       	out	0x25, r24	; 37
    4a54:	85 b5       	in	r24, 0x25	; 37
    4a56:	82 60       	ori	r24, 0x02	; 2
    4a58:	85 bd       	out	0x25, r24	; 37
    4a5a:	85 b5       	in	r24, 0x25	; 37
    4a5c:	81 60       	ori	r24, 0x01	; 1
    4a5e:	85 bd       	out	0x25, r24	; 37
    4a60:	08 95       	ret
		case PWM2_BY64_PRESCALER     :set_bit(TCCR2,CS22);clear_bit(TCCR2,CS21);clear_bit(TCCR2,CS20);break;
    4a62:	85 b5       	in	r24, 0x25	; 37
    4a64:	84 60       	ori	r24, 0x04	; 4
    4a66:	85 bd       	out	0x25, r24	; 37
    4a68:	85 b5       	in	r24, 0x25	; 37
    4a6a:	8d 7f       	andi	r24, 0xFD	; 253
    4a6c:	85 bd       	out	0x25, r24	; 37
    4a6e:	85 b5       	in	r24, 0x25	; 37
    4a70:	8e 7f       	andi	r24, 0xFE	; 254
    4a72:	85 bd       	out	0x25, r24	; 37
    4a74:	08 95       	ret
		case PWM2_BY128_PRESCALER    :set_bit(TCCR2,CS22);clear_bit(TCCR2,CS21);set_bit(TCCR2,CS20);break;
    4a76:	85 b5       	in	r24, 0x25	; 37
    4a78:	84 60       	ori	r24, 0x04	; 4
    4a7a:	85 bd       	out	0x25, r24	; 37
    4a7c:	85 b5       	in	r24, 0x25	; 37
    4a7e:	8d 7f       	andi	r24, 0xFD	; 253
    4a80:	85 bd       	out	0x25, r24	; 37
    4a82:	85 b5       	in	r24, 0x25	; 37
    4a84:	81 60       	ori	r24, 0x01	; 1
    4a86:	85 bd       	out	0x25, r24	; 37
    4a88:	08 95       	ret
		case PWM2_BY256_PRESCALER    :set_bit(TCCR2,CS22);set_bit(TCCR2,CS21);clear_bit(TCCR2,CS20);break;
    4a8a:	85 b5       	in	r24, 0x25	; 37
    4a8c:	84 60       	ori	r24, 0x04	; 4
    4a8e:	85 bd       	out	0x25, r24	; 37
    4a90:	85 b5       	in	r24, 0x25	; 37
    4a92:	82 60       	ori	r24, 0x02	; 2
    4a94:	85 bd       	out	0x25, r24	; 37
    4a96:	85 b5       	in	r24, 0x25	; 37
    4a98:	8e 7f       	andi	r24, 0xFE	; 254
    4a9a:	85 bd       	out	0x25, r24	; 37
    4a9c:	08 95       	ret
		case PWM2_BY1024_PRESCALER   :set_bit(TCCR2,CS22);set_bit(TCCR2,CS21);set_bit(TCCR2,CS20);break;
    4a9e:	85 b5       	in	r24, 0x25	; 37
    4aa0:	84 60       	ori	r24, 0x04	; 4
    4aa2:	85 bd       	out	0x25, r24	; 37
    4aa4:	85 b5       	in	r24, 0x25	; 37
    4aa6:	82 60       	ori	r24, 0x02	; 2
    4aa8:	85 bd       	out	0x25, r24	; 37
    4aaa:	85 b5       	in	r24, 0x25	; 37
    4aac:	81 60       	ori	r24, 0x01	; 1
    4aae:	85 bd       	out	0x25, r24	; 37
    4ab0:	08 95       	ret
		default						 :clear_bit(TCCR2,CS22);clear_bit(TCCR2,CS21);clear_bit(TCCR2,CS20);break;
    4ab2:	85 b5       	in	r24, 0x25	; 37
    4ab4:	8b 7f       	andi	r24, 0xFB	; 251
    4ab6:	85 bd       	out	0x25, r24	; 37
    4ab8:	85 b5       	in	r24, 0x25	; 37
    4aba:	8d 7f       	andi	r24, 0xFD	; 253
    4abc:	85 bd       	out	0x25, r24	; 37
    4abe:	85 b5       	in	r24, 0x25	; 37
    4ac0:	8e 7f       	andi	r24, 0xFE	; 254
    4ac2:	85 bd       	out	0x25, r24	; 37
    4ac4:	08 95       	ret

00004ac6 <vPwm2_set_duty>:
	}
}
//----------------------------------------------------------
void vPwm2_set_duty(u8 duty)
{
	OCR2=(u8)(((u16)duty  * 255)/100);
    4ac6:	2f ef       	ldi	r18, 0xFF	; 255
    4ac8:	82 9f       	mul	r24, r18
    4aca:	c0 01       	movw	r24, r0
    4acc:	11 24       	eor	r1, r1
    4ace:	9c 01       	movw	r18, r24
    4ad0:	36 95       	lsr	r19
    4ad2:	27 95       	ror	r18
    4ad4:	36 95       	lsr	r19
    4ad6:	27 95       	ror	r18
    4ad8:	ab e7       	ldi	r26, 0x7B	; 123
    4ada:	b4 e1       	ldi	r27, 0x14	; 20
    4adc:	0e 94 ea 35 	call	0x6bd4	; 0x6bd4 <__umulhisi3>
    4ae0:	96 95       	lsr	r25
    4ae2:	87 95       	ror	r24
    4ae4:	83 bd       	out	0x23, r24	; 35
    4ae6:	08 95       	ret

00004ae8 <vPwm2_Init>:
static void set_prescaler2(pwm2_prescaler_t prescaler);
static pwm2_prescaler_t g_prescaler2;

//--------------------------------------------------------------
void vPwm2_Init(pwm2_init_param_t * param)
{ 
    4ae8:	cf 93       	push	r28
    4aea:	df 93       	push	r29
    4aec:	ec 01       	movw	r28, r24
	//stop timer 0
	TCCR2 &=PWM2_PRESCALER_MASK;
    4aee:	85 b5       	in	r24, 0x25	; 37
    4af0:	88 7f       	andi	r24, 0xF8	; 248
    4af2:	85 bd       	out	0x25, r24	; 37
	//set duty
	vPwm2_set_duty(param->duty_cycle);
    4af4:	8a 81       	ldd	r24, Y+2	; 0x02
    4af6:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <vPwm2_set_duty>
	//set prescaler
	g_prescaler2=param->prescaler;
    4afa:	89 81       	ldd	r24, Y+1	; 0x01
    4afc:	80 93 e4 01 	sts	0x01E4, r24
	set_prescaler2(g_prescaler2);
    4b00:	0e 94 05 25 	call	0x4a0a	; 0x4a0a <set_prescaler2>
	switch(param->mode)
    4b04:	88 81       	ld	r24, Y
    4b06:	81 30       	cpi	r24, 0x01	; 1
    4b08:	99 f0       	breq	.+38     	; 0x4b30 <vPwm2_Init+0x48>
    4b0a:	28 f0       	brcs	.+10     	; 0x4b16 <vPwm2_Init+0x2e>
    4b0c:	82 30       	cpi	r24, 0x02	; 2
    4b0e:	e9 f0       	breq	.+58     	; 0x4b4a <vPwm2_Init+0x62>
    4b10:	83 30       	cpi	r24, 0x03	; 3
    4b12:	a1 f5       	brne	.+104    	; 0x4b7c <vPwm2_Init+0x94>
    4b14:	27 c0       	rjmp	.+78     	; 0x4b64 <vPwm2_Init+0x7c>
	{
		case PWM2_FAST_NON_INVERTING_MODE :
										//set mode 
										set_bit(TCCR2,WGM21);set_bit(TCCR2,WGM20);
    4b16:	85 b5       	in	r24, 0x25	; 37
    4b18:	88 60       	ori	r24, 0x08	; 8
    4b1a:	85 bd       	out	0x25, r24	; 37
    4b1c:	85 b5       	in	r24, 0x25	; 37
    4b1e:	80 64       	ori	r24, 0x40	; 64
    4b20:	85 bd       	out	0x25, r24	; 37
										//set oc0 pin 
										set_bit(TCCR2,COM21);clear_bit(TCCR2,COM20);
    4b22:	85 b5       	in	r24, 0x25	; 37
    4b24:	80 62       	ori	r24, 0x20	; 32
    4b26:	85 bd       	out	0x25, r24	; 37
    4b28:	85 b5       	in	r24, 0x25	; 37
    4b2a:	8f 7e       	andi	r24, 0xEF	; 239
    4b2c:	85 bd       	out	0x25, r24	; 37
										break;
    4b2e:	26 c0       	rjmp	.+76     	; 0x4b7c <vPwm2_Init+0x94>
		case PWM2_FAST_INVERTING_MODE :
										//set mode
										set_bit(TCCR2,WGM21);set_bit(TCCR2,WGM20);
    4b30:	85 b5       	in	r24, 0x25	; 37
    4b32:	88 60       	ori	r24, 0x08	; 8
    4b34:	85 bd       	out	0x25, r24	; 37
    4b36:	85 b5       	in	r24, 0x25	; 37
    4b38:	80 64       	ori	r24, 0x40	; 64
    4b3a:	85 bd       	out	0x25, r24	; 37
										//set oc0 pin
										set_bit(TCCR2,COM21);set_bit(TCCR2,COM20);
    4b3c:	85 b5       	in	r24, 0x25	; 37
    4b3e:	80 62       	ori	r24, 0x20	; 32
    4b40:	85 bd       	out	0x25, r24	; 37
    4b42:	85 b5       	in	r24, 0x25	; 37
    4b44:	80 61       	ori	r24, 0x10	; 16
    4b46:	85 bd       	out	0x25, r24	; 37
										break;		
    4b48:	19 c0       	rjmp	.+50     	; 0x4b7c <vPwm2_Init+0x94>
		case PWM2_PHASE_CORRECT_CLEAR_UP_SET_DOWN:
										//set mode
										clear_bit(TCCR2,WGM21);set_bit(TCCR2,WGM20);
    4b4a:	85 b5       	in	r24, 0x25	; 37
    4b4c:	87 7f       	andi	r24, 0xF7	; 247
    4b4e:	85 bd       	out	0x25, r24	; 37
    4b50:	85 b5       	in	r24, 0x25	; 37
    4b52:	80 64       	ori	r24, 0x40	; 64
    4b54:	85 bd       	out	0x25, r24	; 37
										//set oc0 pin
										set_bit(TCCR2,COM21);clear_bit(TCCR2,COM20);
    4b56:	85 b5       	in	r24, 0x25	; 37
    4b58:	80 62       	ori	r24, 0x20	; 32
    4b5a:	85 bd       	out	0x25, r24	; 37
    4b5c:	85 b5       	in	r24, 0x25	; 37
    4b5e:	8f 7e       	andi	r24, 0xEF	; 239
    4b60:	85 bd       	out	0x25, r24	; 37
										break;		
    4b62:	0c c0       	rjmp	.+24     	; 0x4b7c <vPwm2_Init+0x94>
		case PWM2_PHASE_CORRECT_SET_UP_CLEAR_DOWN :
										//set mode
										clear_bit(TCCR2,WGM21);set_bit(TCCR2,WGM20);
    4b64:	85 b5       	in	r24, 0x25	; 37
    4b66:	87 7f       	andi	r24, 0xF7	; 247
    4b68:	85 bd       	out	0x25, r24	; 37
    4b6a:	85 b5       	in	r24, 0x25	; 37
    4b6c:	80 64       	ori	r24, 0x40	; 64
    4b6e:	85 bd       	out	0x25, r24	; 37
										//set oc0 pin
										set_bit(TCCR2,COM21);set_bit(TCCR2,COM20);
    4b70:	85 b5       	in	r24, 0x25	; 37
    4b72:	80 62       	ori	r24, 0x20	; 32
    4b74:	85 bd       	out	0x25, r24	; 37
    4b76:	85 b5       	in	r24, 0x25	; 37
    4b78:	80 61       	ori	r24, 0x10	; 16
    4b7a:	85 bd       	out	0x25, r24	; 37
										break;		
		default:break;
	}
}
    4b7c:	df 91       	pop	r29
    4b7e:	cf 91       	pop	r28
    4b80:	08 95       	ret

00004b82 <vPwm2_stop>:
	OCR2=(u8)(((u16)duty  * 255)/100);
}
//--------------------------------------------------------------
void vPwm2_stop(void)
{
	TCCR2 &=PWM2_PRESCALER_MASK;
    4b82:	85 b5       	in	r24, 0x25	; 37
    4b84:	88 7f       	andi	r24, 0xF8	; 248
    4b86:	85 bd       	out	0x25, r24	; 37
    4b88:	08 95       	ret

00004b8a <vPwm2_restart>:
}
//---------------------------------------------------------------
void vPwm2_restart(void)
{
	set_prescaler2(g_prescaler2);
    4b8a:	80 91 e4 01 	lds	r24, 0x01E4
    4b8e:	0e 94 05 25 	call	0x4a0a	; 0x4a0a <set_prescaler2>
    4b92:	08 95       	ret

00004b94 <vSpi_init>:
#include "spi.h"

static ptr2Spi g_func_ptr=NULL;
//-----------------------------------------------------------------
void vSpi_init(spi_init_param_t * param)
{
    4b94:	fc 01       	movw	r30, r24
	//set mode 
	switch(param->mode)
    4b96:	80 81       	ld	r24, Z
    4b98:	88 23       	and	r24, r24
    4b9a:	19 f0       	breq	.+6      	; 0x4ba2 <vSpi_init+0xe>
    4b9c:	81 30       	cpi	r24, 0x01	; 1
    4b9e:	69 f4       	brne	.+26     	; 0x4bba <vSpi_init+0x26>
    4ba0:	07 c0       	rjmp	.+14     	; 0x4bb0 <vSpi_init+0x1c>
	{
		case SPI_SLAVE :
						clear_bit(SPCR,MSTR);
    4ba2:	6c 98       	cbi	0x0d, 4	; 13
						//make ss MOSI and sck input and MISO output low
						clear_bit(DDRB,4);
    4ba4:	bc 98       	cbi	0x17, 4	; 23
						clear_bit(DDRB,5);
    4ba6:	bd 98       	cbi	0x17, 5	; 23
						clear_bit(DDRB,7);
    4ba8:	bf 98       	cbi	0x17, 7	; 23
						set_bit(DDRB,6);
    4baa:	be 9a       	sbi	0x17, 6	; 23
						clear_bit(PORTB,6);
    4bac:	c6 98       	cbi	0x18, 6	; 24
						break;
    4bae:	05 c0       	rjmp	.+10     	; 0x4bba <vSpi_init+0x26>
		case SPI_MASTER :
						set_bit(SPCR,MSTR);
    4bb0:	6c 9a       	sbi	0x0d, 4	; 13
						//make ss MOSI and sck output and MISO input 
						set_bit(DDRB,4);
    4bb2:	bc 9a       	sbi	0x17, 4	; 23
						set_bit(DDRB,5);
    4bb4:	bd 9a       	sbi	0x17, 5	; 23
						set_bit(DDRB,7);
    4bb6:	bf 9a       	sbi	0x17, 7	; 23
						clear_bit(DDRB,6);
    4bb8:	be 98       	cbi	0x17, 6	; 23
						break;
		default:break;
	}
	//set idle state
	switch(param->idle)
    4bba:	81 81       	ldd	r24, Z+1	; 0x01
    4bbc:	88 23       	and	r24, r24
    4bbe:	19 f0       	breq	.+6      	; 0x4bc6 <vSpi_init+0x32>
    4bc0:	81 30       	cpi	r24, 0x01	; 1
    4bc2:	21 f4       	brne	.+8      	; 0x4bcc <vSpi_init+0x38>
    4bc4:	02 c0       	rjmp	.+4      	; 0x4bca <vSpi_init+0x36>
	{
		case SPI_CLK_IDLE_LOW :clear_bit(SPCR,CPOL);break;
    4bc6:	6b 98       	cbi	0x0d, 3	; 13
    4bc8:	01 c0       	rjmp	.+2      	; 0x4bcc <vSpi_init+0x38>
		case SPI_CLK_IDLE_HIGH :set_bit(SPCR,CPOL);break;
    4bca:	6b 9a       	sbi	0x0d, 3	; 13
		default:break;
	}
	//set read edge
	switch(param->read_edge)
    4bcc:	82 81       	ldd	r24, Z+2	; 0x02
    4bce:	88 23       	and	r24, r24
    4bd0:	19 f0       	breq	.+6      	; 0x4bd8 <vSpi_init+0x44>
    4bd2:	81 30       	cpi	r24, 0x01	; 1
    4bd4:	21 f4       	brne	.+8      	; 0x4bde <vSpi_init+0x4a>
    4bd6:	02 c0       	rjmp	.+4      	; 0x4bdc <vSpi_init+0x48>
	{
		case SPI_READ_ON_LEADING_EDGE :clear_bit(SPCR,CPHA);break;
    4bd8:	6a 98       	cbi	0x0d, 2	; 13
    4bda:	01 c0       	rjmp	.+2      	; 0x4bde <vSpi_init+0x4a>
		case SPI_READ_ON_TRAILING_EDGE :set_bit(SPCR,CPHA);break;
    4bdc:	6a 9a       	sbi	0x0d, 2	; 13
		default:break;
	}	
	//set data order
	switch(param->data_order)
    4bde:	83 81       	ldd	r24, Z+3	; 0x03
    4be0:	88 23       	and	r24, r24
    4be2:	19 f0       	breq	.+6      	; 0x4bea <vSpi_init+0x56>
    4be4:	81 30       	cpi	r24, 0x01	; 1
    4be6:	21 f4       	brne	.+8      	; 0x4bf0 <vSpi_init+0x5c>
    4be8:	02 c0       	rjmp	.+4      	; 0x4bee <vSpi_init+0x5a>
	{
		case SPI_MSB_FIRST :clear_bit(SPCR,DORD);break;
    4bea:	6d 98       	cbi	0x0d, 5	; 13
    4bec:	01 c0       	rjmp	.+2      	; 0x4bf0 <vSpi_init+0x5c>
		case SPI_LSB_FIRST :set_bit(SPCR,DORD);break;
    4bee:	6d 9a       	sbi	0x0d, 5	; 13
		default:break;
	}	
	//set prescaler
	switch(param->prescaler)
    4bf0:	84 81       	ldd	r24, Z+4	; 0x04
    4bf2:	83 30       	cpi	r24, 0x03	; 3
    4bf4:	c9 f0       	breq	.+50     	; 0x4c28 <vSpi_init+0x94>
    4bf6:	20 f4       	brcc	.+8      	; 0x4c00 <vSpi_init+0x6c>
    4bf8:	81 30       	cpi	r24, 0x01	; 1
    4bfa:	71 f0       	breq	.+28     	; 0x4c18 <vSpi_init+0x84>
    4bfc:	88 f4       	brcc	.+34     	; 0x4c20 <vSpi_init+0x8c>
    4bfe:	08 c0       	rjmp	.+16     	; 0x4c10 <vSpi_init+0x7c>
    4c00:	85 30       	cpi	r24, 0x05	; 5
    4c02:	d1 f0       	breq	.+52     	; 0x4c38 <vSpi_init+0xa4>
    4c04:	a8 f0       	brcs	.+42     	; 0x4c30 <vSpi_init+0x9c>
    4c06:	86 30       	cpi	r24, 0x06	; 6
    4c08:	d9 f0       	breq	.+54     	; 0x4c40 <vSpi_init+0xac>
    4c0a:	87 30       	cpi	r24, 0x07	; 7
    4c0c:	01 f5       	brne	.+64     	; 0x4c4e <vSpi_init+0xba>
    4c0e:	1c c0       	rjmp	.+56     	; 0x4c48 <vSpi_init+0xb4>
	{
		case SPI_CLK_BY_4 :clear_bit(SPSR,SPI2X);clear_bit(SPCR,SPR1);clear_bit(SPCR,SPR0);break;
    4c10:	70 98       	cbi	0x0e, 0	; 14
    4c12:	69 98       	cbi	0x0d, 1	; 13
    4c14:	68 98       	cbi	0x0d, 0	; 13
    4c16:	1b c0       	rjmp	.+54     	; 0x4c4e <vSpi_init+0xba>
		case SPI_CLK_BY_16 :clear_bit(SPSR,SPI2X);clear_bit(SPCR,SPR1);set_bit(SPCR,SPR0);break;
    4c18:	70 98       	cbi	0x0e, 0	; 14
    4c1a:	69 98       	cbi	0x0d, 1	; 13
    4c1c:	68 9a       	sbi	0x0d, 0	; 13
    4c1e:	17 c0       	rjmp	.+46     	; 0x4c4e <vSpi_init+0xba>
		case SPI_CLK_BY_64 :clear_bit(SPSR,SPI2X);set_bit(SPCR,SPR1);clear_bit(SPCR,SPR0);break;
    4c20:	70 98       	cbi	0x0e, 0	; 14
    4c22:	69 9a       	sbi	0x0d, 1	; 13
    4c24:	68 98       	cbi	0x0d, 0	; 13
    4c26:	13 c0       	rjmp	.+38     	; 0x4c4e <vSpi_init+0xba>
		case SPI_CLK_BY_128 :clear_bit(SPSR,SPI2X);set_bit(SPCR,SPR1);set_bit(SPCR,SPR0);break;
    4c28:	70 98       	cbi	0x0e, 0	; 14
    4c2a:	69 9a       	sbi	0x0d, 1	; 13
    4c2c:	68 9a       	sbi	0x0d, 0	; 13
    4c2e:	0f c0       	rjmp	.+30     	; 0x4c4e <vSpi_init+0xba>
		case SPI_CLK_BY_2 :set_bit(SPSR,SPI2X);clear_bit(SPCR,SPR1);clear_bit(SPCR,SPR0);break;
    4c30:	70 9a       	sbi	0x0e, 0	; 14
    4c32:	69 98       	cbi	0x0d, 1	; 13
    4c34:	68 98       	cbi	0x0d, 0	; 13
    4c36:	0b c0       	rjmp	.+22     	; 0x4c4e <vSpi_init+0xba>
		case SPI_CLK_BY_8 :set_bit(SPSR,SPI2X);clear_bit(SPCR,SPR1);set_bit(SPCR,SPR0);break;
    4c38:	70 9a       	sbi	0x0e, 0	; 14
    4c3a:	69 98       	cbi	0x0d, 1	; 13
    4c3c:	68 9a       	sbi	0x0d, 0	; 13
    4c3e:	07 c0       	rjmp	.+14     	; 0x4c4e <vSpi_init+0xba>
		case SPI_CLK_BY_32 :set_bit(SPSR,SPI2X);set_bit(SPCR,SPR1);clear_bit(SPCR,SPR0);break;
    4c40:	70 9a       	sbi	0x0e, 0	; 14
    4c42:	69 9a       	sbi	0x0d, 1	; 13
    4c44:	68 98       	cbi	0x0d, 0	; 13
    4c46:	03 c0       	rjmp	.+6      	; 0x4c4e <vSpi_init+0xba>
		case SPI_CLK_BY_64_2 :set_bit(SPSR,SPI2X);set_bit(SPCR,SPR1);set_bit(SPCR,SPR0);break;
    4c48:	70 9a       	sbi	0x0e, 0	; 14
    4c4a:	69 9a       	sbi	0x0d, 1	; 13
    4c4c:	68 9a       	sbi	0x0d, 0	; 13
		default:break;
	}	
	//set interrupt
	switch(param->interrupt)
    4c4e:	85 81       	ldd	r24, Z+5	; 0x05
    4c50:	88 23       	and	r24, r24
    4c52:	19 f0       	breq	.+6      	; 0x4c5a <vSpi_init+0xc6>
    4c54:	81 30       	cpi	r24, 0x01	; 1
    4c56:	61 f4       	brne	.+24     	; 0x4c70 <vSpi_init+0xdc>
    4c58:	02 c0       	rjmp	.+4      	; 0x4c5e <vSpi_init+0xca>
	{
		case SPI_NO_INTERRUPT :clear_bit(SPCR,SPIE);break;
    4c5a:	6f 98       	cbi	0x0d, 7	; 13
    4c5c:	09 c0       	rjmp	.+18     	; 0x4c70 <vSpi_init+0xdc>
		case SPI_INTERRUPT :
							set_bit(SPCR,SPIE);
    4c5e:	6f 9a       	sbi	0x0d, 7	; 13
							if(param->ptr2func != NULL)
    4c60:	86 81       	ldd	r24, Z+6	; 0x06
    4c62:	97 81       	ldd	r25, Z+7	; 0x07
    4c64:	00 97       	sbiw	r24, 0x00	; 0
    4c66:	21 f0       	breq	.+8      	; 0x4c70 <vSpi_init+0xdc>
							{
								g_func_ptr=param->ptr2func;
    4c68:	90 93 e6 01 	sts	0x01E6, r25
    4c6c:	80 93 e5 01 	sts	0x01E5, r24
							}
							break;
		default:break;
	}
	//enable spi
	set_bit(SPCR,SPE);
    4c70:	6e 9a       	sbi	0x0d, 6	; 13
    4c72:	08 95       	ret

00004c74 <__vector_12>:
	while(check_bit(SPSR,SPIF) ==0);
	return SPDR;
}
//---------------------------------------------------------------
ISR(SPI_STC_vect)
{
    4c74:	1f 92       	push	r1
    4c76:	0f 92       	push	r0
    4c78:	0f b6       	in	r0, 0x3f	; 63
    4c7a:	0f 92       	push	r0
    4c7c:	11 24       	eor	r1, r1
    4c7e:	2f 93       	push	r18
    4c80:	3f 93       	push	r19
    4c82:	4f 93       	push	r20
    4c84:	5f 93       	push	r21
    4c86:	6f 93       	push	r22
    4c88:	7f 93       	push	r23
    4c8a:	8f 93       	push	r24
    4c8c:	9f 93       	push	r25
    4c8e:	af 93       	push	r26
    4c90:	bf 93       	push	r27
    4c92:	ef 93       	push	r30
    4c94:	ff 93       	push	r31
	if(g_func_ptr !=NULL)
    4c96:	e0 91 e5 01 	lds	r30, 0x01E5
    4c9a:	f0 91 e6 01 	lds	r31, 0x01E6
    4c9e:	30 97       	sbiw	r30, 0x00	; 0
    4ca0:	09 f0       	breq	.+2      	; 0x4ca4 <__vector_12+0x30>
	{
		g_func_ptr();
    4ca2:	09 95       	icall
	}
}
    4ca4:	ff 91       	pop	r31
    4ca6:	ef 91       	pop	r30
    4ca8:	bf 91       	pop	r27
    4caa:	af 91       	pop	r26
    4cac:	9f 91       	pop	r25
    4cae:	8f 91       	pop	r24
    4cb0:	7f 91       	pop	r23
    4cb2:	6f 91       	pop	r22
    4cb4:	5f 91       	pop	r21
    4cb6:	4f 91       	pop	r20
    4cb8:	3f 91       	pop	r19
    4cba:	2f 91       	pop	r18
    4cbc:	0f 90       	pop	r0
    4cbe:	0f be       	out	0x3f, r0	; 63
    4cc0:	0f 90       	pop	r0
    4cc2:	1f 90       	pop	r1
    4cc4:	18 95       	reti

00004cc6 <vUartInit>:
#include "uart.h"

static PTR2ISR g_ISR[MAX_UART_INTERRUPTS];

void vUartInit(uart_param_t * uart_param)
{
    4cc6:	fc 01       	movw	r30, r24

	//set URSEL
	//set_bit(UCSRC,URSEL);
	//UCSRC =0x80;
	//select mode
	switch(uart_param->mode)
    4cc8:	80 85       	ldd	r24, Z+8	; 0x08
    4cca:	81 30       	cpi	r24, 0x01	; 1
    4ccc:	39 f0       	breq	.+14     	; 0x4cdc <vUartInit+0x16>
    4cce:	18 f0       	brcs	.+6      	; 0x4cd6 <vUartInit+0x10>
    4cd0:	82 30       	cpi	r24, 0x02	; 2
    4cd2:	49 f4       	brne	.+18     	; 0x4ce6 <vUartInit+0x20>
    4cd4:	06 c0       	rjmp	.+12     	; 0x4ce2 <vUartInit+0x1c>
	{
		case UART_RECIEVER :set_bit(UCSRB,RXEN);clear_bit(UCSRB,TXEN);break;
    4cd6:	54 9a       	sbi	0x0a, 4	; 10
    4cd8:	53 98       	cbi	0x0a, 3	; 10
    4cda:	05 c0       	rjmp	.+10     	; 0x4ce6 <vUartInit+0x20>
		case UART_TRANSMITER :clear_bit(UCSRB,RXEN);set_bit(UCSRB,TXEN);break;
    4cdc:	54 98       	cbi	0x0a, 4	; 10
    4cde:	53 9a       	sbi	0x0a, 3	; 10
    4ce0:	02 c0       	rjmp	.+4      	; 0x4ce6 <vUartInit+0x20>
		case UART_RECIEVER_TRANSMITER :set_bit(UCSRB,RXEN);set_bit(UCSRB,TXEN);break;
    4ce2:	54 9a       	sbi	0x0a, 4	; 10
    4ce4:	53 9a       	sbi	0x0a, 3	; 10
		default:break;
	}
	
	//set data bits
	switch(uart_param->data_bits)
    4ce6:	82 85       	ldd	r24, Z+10	; 0x0a
    4ce8:	82 30       	cpi	r24, 0x02	; 2
    4cea:	89 f0       	breq	.+34     	; 0x4d0e <vUartInit+0x48>
    4cec:	28 f4       	brcc	.+10     	; 0x4cf8 <vUartInit+0x32>
    4cee:	88 23       	and	r24, r24
    4cf0:	41 f0       	breq	.+16     	; 0x4d02 <vUartInit+0x3c>
    4cf2:	81 30       	cpi	r24, 0x01	; 1
    4cf4:	a9 f4       	brne	.+42     	; 0x4d20 <vUartInit+0x5a>
    4cf6:	08 c0       	rjmp	.+16     	; 0x4d08 <vUartInit+0x42>
    4cf8:	83 30       	cpi	r24, 0x03	; 3
    4cfa:	61 f0       	breq	.+24     	; 0x4d14 <vUartInit+0x4e>
    4cfc:	84 30       	cpi	r24, 0x04	; 4
    4cfe:	81 f4       	brne	.+32     	; 0x4d20 <vUartInit+0x5a>
    4d00:	0c c0       	rjmp	.+24     	; 0x4d1a <vUartInit+0x54>
	{
		case UART_5_BITS :clear_bit(UCSRB,UCSZ2);clear_bit(ucsrc_buffer,UCSZ1);clear_bit(ucsrc_buffer,UCSZ0);break;
    4d02:	52 98       	cbi	0x0a, 2	; 10
    4d04:	80 e0       	ldi	r24, 0x00	; 0
    4d06:	0d c0       	rjmp	.+26     	; 0x4d22 <vUartInit+0x5c>
		case UART_6_BITS :clear_bit(UCSRB,UCSZ2);clear_bit(ucsrc_buffer,UCSZ1);set_bit(ucsrc_buffer,UCSZ0);break;
    4d08:	52 98       	cbi	0x0a, 2	; 10
    4d0a:	82 e0       	ldi	r24, 0x02	; 2
    4d0c:	0a c0       	rjmp	.+20     	; 0x4d22 <vUartInit+0x5c>
		case UART_7_BITS :clear_bit(UCSRB,UCSZ2);set_bit(ucsrc_buffer,UCSZ1);clear_bit(ucsrc_buffer,UCSZ0);break;
    4d0e:	52 98       	cbi	0x0a, 2	; 10
    4d10:	84 e0       	ldi	r24, 0x04	; 4
    4d12:	07 c0       	rjmp	.+14     	; 0x4d22 <vUartInit+0x5c>
		case UART_8_BITS :clear_bit(UCSRB,UCSZ2);set_bit(ucsrc_buffer,UCSZ1);set_bit(ucsrc_buffer,UCSZ0);break;
    4d14:	52 98       	cbi	0x0a, 2	; 10
    4d16:	86 e0       	ldi	r24, 0x06	; 6
    4d18:	04 c0       	rjmp	.+8      	; 0x4d22 <vUartInit+0x5c>
		case UART_9_BITS :set_bit(UCSRB,UCSZ2);set_bit(ucsrc_buffer,UCSZ1);set_bit(ucsrc_buffer,UCSZ0);break;
    4d1a:	52 9a       	sbi	0x0a, 2	; 10
    4d1c:	86 e0       	ldi	r24, 0x06	; 6
    4d1e:	01 c0       	rjmp	.+2      	; 0x4d22 <vUartInit+0x5c>
static PTR2ISR g_ISR[MAX_UART_INTERRUPTS];

void vUartInit(uart_param_t * uart_param)
{
	u16 ubr=0;
	u8 ucsrc_buffer=0;
    4d20:	80 e0       	ldi	r24, 0x00	; 0
		case UART_8_BITS :clear_bit(UCSRB,UCSZ2);set_bit(ucsrc_buffer,UCSZ1);set_bit(ucsrc_buffer,UCSZ0);break;
		case UART_9_BITS :set_bit(UCSRB,UCSZ2);set_bit(ucsrc_buffer,UCSZ1);set_bit(ucsrc_buffer,UCSZ0);break;
		default:break;
	}
	//set stop bits
	switch(uart_param->stop_bits)
    4d22:	93 85       	ldd	r25, Z+11	; 0x0b
    4d24:	99 23       	and	r25, r25
    4d26:	19 f0       	breq	.+6      	; 0x4d2e <vUartInit+0x68>
    4d28:	91 30       	cpi	r25, 0x01	; 1
    4d2a:	21 f4       	brne	.+8      	; 0x4d34 <vUartInit+0x6e>
    4d2c:	02 c0       	rjmp	.+4      	; 0x4d32 <vUartInit+0x6c>
	{
		case UART_1_STOP_BIT :clear_bit(ucsrc_buffer,USBS);break;
    4d2e:	87 7f       	andi	r24, 0xF7	; 247
    4d30:	01 c0       	rjmp	.+2      	; 0x4d34 <vUartInit+0x6e>
		case UART_2_STOP_BIT :set_bit(ucsrc_buffer,USBS);break;
    4d32:	88 60       	ori	r24, 0x08	; 8
		default:break;
	}
	//set parity mode
	switch(uart_param->parity_mode)
    4d34:	94 85       	ldd	r25, Z+12	; 0x0c
    4d36:	92 30       	cpi	r25, 0x02	; 2
    4d38:	31 f0       	breq	.+12     	; 0x4d46 <vUartInit+0x80>
    4d3a:	93 30       	cpi	r25, 0x03	; 3
    4d3c:	39 f0       	breq	.+14     	; 0x4d4c <vUartInit+0x86>
    4d3e:	91 11       	cpse	r25, r1
    4d40:	06 c0       	rjmp	.+12     	; 0x4d4e <vUartInit+0x88>
	{
		case UART_NON_PARITY :clear_bit(ucsrc_buffer,UPM1);clear_bit(ucsrc_buffer,UPM0);break;
    4d42:	8f 7c       	andi	r24, 0xCF	; 207
    4d44:	04 c0       	rjmp	.+8      	; 0x4d4e <vUartInit+0x88>
		case UART_EVEN_PARITY :set_bit(ucsrc_buffer,UPM1);clear_bit(ucsrc_buffer,UPM0);break;
    4d46:	8f 7e       	andi	r24, 0xEF	; 239
    4d48:	80 62       	ori	r24, 0x20	; 32
    4d4a:	01 c0       	rjmp	.+2      	; 0x4d4e <vUartInit+0x88>
		case UART_ODD_PARITY :set_bit(ucsrc_buffer,UPM1);set_bit(ucsrc_buffer,UPM0);break;
    4d4c:	80 63       	ori	r24, 0x30	; 48
		default:break;
	}
	// write UCSRC data
	set_bit(ucsrc_buffer,URSEL);
	set_bit(UCSRC,URSEL);
    4d4e:	90 b5       	in	r25, 0x20	; 32
    4d50:	90 68       	ori	r25, 0x80	; 128
    4d52:	90 bd       	out	0x20, r25	; 32
	UCSRC =ucsrc_buffer |(1<<URSEL);
    4d54:	80 68       	ori	r24, 0x80	; 128
    4d56:	80 bd       	out	0x20, r24	; 32
	//set interrupts
	UCSRB |=uart_param->interrupt_mode;
    4d58:	9a b1       	in	r25, 0x0a	; 10
    4d5a:	85 85       	ldd	r24, Z+13	; 0x0d
    4d5c:	89 2b       	or	r24, r25
    4d5e:	8a b9       	out	0x0a, r24	; 10
	if(uart_param->rx_ISR !=NULL)
    4d60:	86 85       	ldd	r24, Z+14	; 0x0e
    4d62:	97 85       	ldd	r25, Z+15	; 0x0f
    4d64:	00 97       	sbiw	r24, 0x00	; 0
    4d66:	21 f0       	breq	.+8      	; 0x4d70 <vUartInit+0xaa>
	{
		g_ISR[RX_COMPLETE_INTERRUPT]=uart_param->rx_ISR;
    4d68:	90 93 e8 01 	sts	0x01E8, r25
    4d6c:	80 93 e7 01 	sts	0x01E7, r24
	}
	if(uart_param->tx_ISR !=NULL)
    4d70:	80 89       	ldd	r24, Z+16	; 0x10
    4d72:	91 89       	ldd	r25, Z+17	; 0x11
    4d74:	00 97       	sbiw	r24, 0x00	; 0
    4d76:	21 f0       	breq	.+8      	; 0x4d80 <vUartInit+0xba>
	{
		g_ISR[TX_COMPLETE_INTERRUPT]=uart_param->tx_ISR;
    4d78:	90 93 ea 01 	sts	0x01EA, r25
    4d7c:	80 93 e9 01 	sts	0x01E9, r24
	}
	if(uart_param->data_reg_empty_ISR !=NULL)
    4d80:	82 89       	ldd	r24, Z+18	; 0x12
    4d82:	93 89       	ldd	r25, Z+19	; 0x13
    4d84:	00 97       	sbiw	r24, 0x00	; 0
    4d86:	21 f0       	breq	.+8      	; 0x4d90 <vUartInit+0xca>
	{
		g_ISR[UDR_EMPTY_INTERRUPT]=uart_param->data_reg_empty_ISR;
    4d88:	90 93 ec 01 	sts	0x01EC, r25
    4d8c:	80 93 eb 01 	sts	0x01EB, r24
	//-------------------------------------------------
		//select UBRR reg
		//clear_bit(UCSRC,URSEL);
		//set async mode
		//clear_bit(UCSRC,UMSEL);
		switch(uart_param->async_mode)
    4d90:	81 85       	ldd	r24, Z+9	; 0x09
    4d92:	88 23       	and	r24, r24
    4d94:	21 f0       	breq	.+8      	; 0x4d9e <vUartInit+0xd8>
    4d96:	81 30       	cpi	r24, 0x01	; 1
    4d98:	09 f0       	breq	.+2      	; 0x4d9c <vUartInit+0xd6>
    4d9a:	48 c0       	rjmp	.+144    	; 0x4e2c <vUartInit+0x166>
    4d9c:	26 c0       	rjmp	.+76     	; 0x4dea <vUartInit+0x124>
		{
			case NORMAL_ASYNC_MODE :clear_bit(UCSRA,U2X);
    4d9e:	59 98       	cbi	0x0b, 1	; 11
			ubr=(u16)((uart_param->sys_clock)/((u32)16 *(uart_param->baud_rate)))-1;
    4da0:	80 81       	ld	r24, Z
    4da2:	91 81       	ldd	r25, Z+1	; 0x01
    4da4:	a2 81       	ldd	r26, Z+2	; 0x02
    4da6:	b3 81       	ldd	r27, Z+3	; 0x03
    4da8:	88 0f       	add	r24, r24
    4daa:	99 1f       	adc	r25, r25
    4dac:	aa 1f       	adc	r26, r26
    4dae:	bb 1f       	adc	r27, r27
    4db0:	88 0f       	add	r24, r24
    4db2:	99 1f       	adc	r25, r25
    4db4:	aa 1f       	adc	r26, r26
    4db6:	bb 1f       	adc	r27, r27
    4db8:	9c 01       	movw	r18, r24
    4dba:	ad 01       	movw	r20, r26
    4dbc:	22 0f       	add	r18, r18
    4dbe:	33 1f       	adc	r19, r19
    4dc0:	44 1f       	adc	r20, r20
    4dc2:	55 1f       	adc	r21, r21
    4dc4:	22 0f       	add	r18, r18
    4dc6:	33 1f       	adc	r19, r19
    4dc8:	44 1f       	adc	r20, r20
    4dca:	55 1f       	adc	r21, r21
    4dcc:	64 81       	ldd	r22, Z+4	; 0x04
    4dce:	75 81       	ldd	r23, Z+5	; 0x05
    4dd0:	86 81       	ldd	r24, Z+6	; 0x06
    4dd2:	97 81       	ldd	r25, Z+7	; 0x07
    4dd4:	0e 94 c8 35 	call	0x6b90	; 0x6b90 <__udivmodsi4>
    4dd8:	21 50       	subi	r18, 0x01	; 1
    4dda:	31 09       	sbc	r19, r1
			UBRRH=(u8)((u16)ubr>>8) & (0x7F);
    4ddc:	83 2f       	mov	r24, r19
    4dde:	99 27       	eor	r25, r25
    4de0:	8f 77       	andi	r24, 0x7F	; 127
    4de2:	99 27       	eor	r25, r25
    4de4:	80 bd       	out	0x20, r24	; 32
			UBRRL=(u8)ubr;
    4de6:	29 b9       	out	0x09, r18	; 9
			break;
    4de8:	08 95       	ret
			case DOUBLE_SPEED_ASYNC_MODE :set_bit(UCSRA,U2X);
    4dea:	59 9a       	sbi	0x0b, 1	; 11
			ubr=(u16)((uart_param->sys_clock)/((u32)8 *(uart_param->baud_rate)))-1;
    4dec:	80 81       	ld	r24, Z
    4dee:	91 81       	ldd	r25, Z+1	; 0x01
    4df0:	a2 81       	ldd	r26, Z+2	; 0x02
    4df2:	b3 81       	ldd	r27, Z+3	; 0x03
    4df4:	88 0f       	add	r24, r24
    4df6:	99 1f       	adc	r25, r25
    4df8:	aa 1f       	adc	r26, r26
    4dfa:	bb 1f       	adc	r27, r27
    4dfc:	88 0f       	add	r24, r24
    4dfe:	99 1f       	adc	r25, r25
    4e00:	aa 1f       	adc	r26, r26
    4e02:	bb 1f       	adc	r27, r27
    4e04:	9c 01       	movw	r18, r24
    4e06:	ad 01       	movw	r20, r26
    4e08:	22 0f       	add	r18, r18
    4e0a:	33 1f       	adc	r19, r19
    4e0c:	44 1f       	adc	r20, r20
    4e0e:	55 1f       	adc	r21, r21
    4e10:	64 81       	ldd	r22, Z+4	; 0x04
    4e12:	75 81       	ldd	r23, Z+5	; 0x05
    4e14:	86 81       	ldd	r24, Z+6	; 0x06
    4e16:	97 81       	ldd	r25, Z+7	; 0x07
    4e18:	0e 94 c8 35 	call	0x6b90	; 0x6b90 <__udivmodsi4>
    4e1c:	21 50       	subi	r18, 0x01	; 1
    4e1e:	31 09       	sbc	r19, r1
			UBRRH=(u8)((u16)ubr>>8)  & (0x7F);
    4e20:	83 2f       	mov	r24, r19
    4e22:	99 27       	eor	r25, r25
    4e24:	8f 77       	andi	r24, 0x7F	; 127
    4e26:	99 27       	eor	r25, r25
    4e28:	80 bd       	out	0x20, r24	; 32
			UBRRL=(u8)ubr;
    4e2a:	29 b9       	out	0x09, r18	; 9
    4e2c:	08 95       	ret

00004e2e <__vector_13>:
		}
	
}
//-------------------------------------------------------------------------
ISR(USART_RXC_vect)
{
    4e2e:	1f 92       	push	r1
    4e30:	0f 92       	push	r0
    4e32:	0f b6       	in	r0, 0x3f	; 63
    4e34:	0f 92       	push	r0
    4e36:	11 24       	eor	r1, r1
    4e38:	2f 93       	push	r18
    4e3a:	3f 93       	push	r19
    4e3c:	4f 93       	push	r20
    4e3e:	5f 93       	push	r21
    4e40:	6f 93       	push	r22
    4e42:	7f 93       	push	r23
    4e44:	8f 93       	push	r24
    4e46:	9f 93       	push	r25
    4e48:	af 93       	push	r26
    4e4a:	bf 93       	push	r27
    4e4c:	ef 93       	push	r30
    4e4e:	ff 93       	push	r31
	if(g_ISR[RX_COMPLETE_INTERRUPT] !=NULL)
    4e50:	e0 91 e7 01 	lds	r30, 0x01E7
    4e54:	f0 91 e8 01 	lds	r31, 0x01E8
    4e58:	30 97       	sbiw	r30, 0x00	; 0
    4e5a:	09 f0       	breq	.+2      	; 0x4e5e <__vector_13+0x30>
	{
		g_ISR[RX_COMPLETE_INTERRUPT]();
    4e5c:	09 95       	icall
	}
}
    4e5e:	ff 91       	pop	r31
    4e60:	ef 91       	pop	r30
    4e62:	bf 91       	pop	r27
    4e64:	af 91       	pop	r26
    4e66:	9f 91       	pop	r25
    4e68:	8f 91       	pop	r24
    4e6a:	7f 91       	pop	r23
    4e6c:	6f 91       	pop	r22
    4e6e:	5f 91       	pop	r21
    4e70:	4f 91       	pop	r20
    4e72:	3f 91       	pop	r19
    4e74:	2f 91       	pop	r18
    4e76:	0f 90       	pop	r0
    4e78:	0f be       	out	0x3f, r0	; 63
    4e7a:	0f 90       	pop	r0
    4e7c:	1f 90       	pop	r1
    4e7e:	18 95       	reti

00004e80 <__vector_15>:
//------------------------------------------------------------
ISR(USART_TXC_vect)
{
    4e80:	1f 92       	push	r1
    4e82:	0f 92       	push	r0
    4e84:	0f b6       	in	r0, 0x3f	; 63
    4e86:	0f 92       	push	r0
    4e88:	11 24       	eor	r1, r1
    4e8a:	2f 93       	push	r18
    4e8c:	3f 93       	push	r19
    4e8e:	4f 93       	push	r20
    4e90:	5f 93       	push	r21
    4e92:	6f 93       	push	r22
    4e94:	7f 93       	push	r23
    4e96:	8f 93       	push	r24
    4e98:	9f 93       	push	r25
    4e9a:	af 93       	push	r26
    4e9c:	bf 93       	push	r27
    4e9e:	ef 93       	push	r30
    4ea0:	ff 93       	push	r31
	if(g_ISR[TX_COMPLETE_INTERRUPT] !=NULL)
    4ea2:	e0 91 e9 01 	lds	r30, 0x01E9
    4ea6:	f0 91 ea 01 	lds	r31, 0x01EA
    4eaa:	30 97       	sbiw	r30, 0x00	; 0
    4eac:	09 f0       	breq	.+2      	; 0x4eb0 <__vector_15+0x30>
	{
		g_ISR[TX_COMPLETE_INTERRUPT]();
    4eae:	09 95       	icall
	}
}
    4eb0:	ff 91       	pop	r31
    4eb2:	ef 91       	pop	r30
    4eb4:	bf 91       	pop	r27
    4eb6:	af 91       	pop	r26
    4eb8:	9f 91       	pop	r25
    4eba:	8f 91       	pop	r24
    4ebc:	7f 91       	pop	r23
    4ebe:	6f 91       	pop	r22
    4ec0:	5f 91       	pop	r21
    4ec2:	4f 91       	pop	r20
    4ec4:	3f 91       	pop	r19
    4ec6:	2f 91       	pop	r18
    4ec8:	0f 90       	pop	r0
    4eca:	0f be       	out	0x3f, r0	; 63
    4ecc:	0f 90       	pop	r0
    4ece:	1f 90       	pop	r1
    4ed0:	18 95       	reti

00004ed2 <__vector_14>:
//-------------------------------------------------------
ISR(USART_UDRE_vect)
{
    4ed2:	1f 92       	push	r1
    4ed4:	0f 92       	push	r0
    4ed6:	0f b6       	in	r0, 0x3f	; 63
    4ed8:	0f 92       	push	r0
    4eda:	11 24       	eor	r1, r1
    4edc:	2f 93       	push	r18
    4ede:	3f 93       	push	r19
    4ee0:	4f 93       	push	r20
    4ee2:	5f 93       	push	r21
    4ee4:	6f 93       	push	r22
    4ee6:	7f 93       	push	r23
    4ee8:	8f 93       	push	r24
    4eea:	9f 93       	push	r25
    4eec:	af 93       	push	r26
    4eee:	bf 93       	push	r27
    4ef0:	ef 93       	push	r30
    4ef2:	ff 93       	push	r31
	if(g_ISR[UDR_EMPTY_INTERRUPT] !=NULL)
    4ef4:	e0 91 eb 01 	lds	r30, 0x01EB
    4ef8:	f0 91 ec 01 	lds	r31, 0x01EC
    4efc:	30 97       	sbiw	r30, 0x00	; 0
    4efe:	09 f0       	breq	.+2      	; 0x4f02 <__vector_14+0x30>
	{
		g_ISR[UDR_EMPTY_INTERRUPT]();
    4f00:	09 95       	icall
	}
}
    4f02:	ff 91       	pop	r31
    4f04:	ef 91       	pop	r30
    4f06:	bf 91       	pop	r27
    4f08:	af 91       	pop	r26
    4f0a:	9f 91       	pop	r25
    4f0c:	8f 91       	pop	r24
    4f0e:	7f 91       	pop	r23
    4f10:	6f 91       	pop	r22
    4f12:	5f 91       	pop	r21
    4f14:	4f 91       	pop	r20
    4f16:	3f 91       	pop	r19
    4f18:	2f 91       	pop	r18
    4f1a:	0f 90       	pop	r0
    4f1c:	0f be       	out	0x3f, r0	; 63
    4f1e:	0f 90       	pop	r0
    4f20:	1f 90       	pop	r1
    4f22:	18 95       	reti

00004f24 <vUartTransmit>:
//--------------------------------------------------
void vUartTransmit(u8 data)
{
	while(check_bit(UCSRA,UDRE) == 0);
    4f24:	5d 9b       	sbis	0x0b, 5	; 11
    4f26:	fe cf       	rjmp	.-4      	; 0x4f24 <vUartTransmit>
	UDR=data;	
    4f28:	8c b9       	out	0x0c, r24	; 12
    4f2a:	08 95       	ret

00004f2c <vUartTransmitString_program>:
		{
			vUartTransmit(pgm_read_byte(data++));
		}
}
void vUartTransmitString_program(const char* data)
{
    4f2c:	cf 93       	push	r28
    4f2e:	df 93       	push	r29
    4f30:	ec 01       	movw	r28, r24
		while(pgm_read_byte(data) != '\0')
    4f32:	fe 01       	movw	r30, r28
    4f34:	24 91       	lpm	r18, Z
    4f36:	22 23       	and	r18, r18
    4f38:	51 f0       	breq	.+20     	; 0x4f4e <vUartTransmitString_program+0x22>
		{
			vUartTransmit(pgm_read_byte(data++));
    4f3a:	21 96       	adiw	r28, 0x01	; 1
    4f3c:	fc 01       	movw	r30, r24
    4f3e:	84 91       	lpm	r24, Z
    4f40:	0e 94 92 27 	call	0x4f24	; 0x4f24 <vUartTransmit>
			vUartTransmit(pgm_read_byte(data++));
		}
}
void vUartTransmitString_program(const char* data)
{
		while(pgm_read_byte(data) != '\0')
    4f44:	ce 01       	movw	r24, r28
    4f46:	fe 01       	movw	r30, r28
    4f48:	24 91       	lpm	r18, Z
    4f4a:	21 11       	cpse	r18, r1
    4f4c:	f6 cf       	rjmp	.-20     	; 0x4f3a <vUartTransmitString_program+0xe>
		{
			vUartTransmit(pgm_read_byte(data++));
		}	
    4f4e:	df 91       	pop	r29
    4f50:	cf 91       	pop	r28
    4f52:	08 95       	ret

00004f54 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    4f54:	cf 93       	push	r28
    4f56:	df 93       	push	r29
    4f58:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    4f5a:	0e 94 27 2f 	call	0x5e4e	; 0x5e4e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    4f5e:	80 91 ed 01 	lds	r24, 0x01ED
    4f62:	90 91 ee 01 	lds	r25, 0x01EE
    4f66:	89 2b       	or	r24, r25
    4f68:	31 f4       	brne	.+12     	; 0x4f76 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    4f6a:	80 ef       	ldi	r24, 0xF0	; 240
    4f6c:	91 e0       	ldi	r25, 0x01	; 1
    4f6e:	90 93 ee 01 	sts	0x01EE, r25
    4f72:	80 93 ed 01 	sts	0x01ED, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    4f76:	40 91 cb 07 	lds	r20, 0x07CB
    4f7a:	50 91 cc 07 	lds	r21, 0x07CC
    4f7e:	9e 01       	movw	r18, r28
    4f80:	24 0f       	add	r18, r20
    4f82:	35 1f       	adc	r19, r21
    4f84:	2b 3d       	cpi	r18, 0xDB	; 219
    4f86:	85 e0       	ldi	r24, 0x05	; 5
    4f88:	38 07       	cpc	r19, r24
    4f8a:	70 f4       	brcc	.+28     	; 0x4fa8 <pvPortMalloc+0x54>
    4f8c:	42 17       	cp	r20, r18
    4f8e:	53 07       	cpc	r21, r19
    4f90:	70 f4       	brcc	.+28     	; 0x4fae <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    4f92:	c0 91 ed 01 	lds	r28, 0x01ED
    4f96:	d0 91 ee 01 	lds	r29, 0x01EE
    4f9a:	c4 0f       	add	r28, r20
    4f9c:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    4f9e:	30 93 cc 07 	sts	0x07CC, r19
    4fa2:	20 93 cb 07 	sts	0x07CB, r18
    4fa6:	05 c0       	rjmp	.+10     	; 0x4fb2 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    4fa8:	c0 e0       	ldi	r28, 0x00	; 0
    4faa:	d0 e0       	ldi	r29, 0x00	; 0
    4fac:	02 c0       	rjmp	.+4      	; 0x4fb2 <pvPortMalloc+0x5e>
    4fae:	c0 e0       	ldi	r28, 0x00	; 0
    4fb0:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    4fb2:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    4fb6:	8c 2f       	mov	r24, r28
    4fb8:	9d 2f       	mov	r25, r29
    4fba:	df 91       	pop	r29
    4fbc:	cf 91       	pop	r28
    4fbe:	08 95       	ret

00004fc0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4fc0:	08 95       	ret

00004fc2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    4fc2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4fc4:	03 96       	adiw	r24, 0x03	; 3
    4fc6:	92 83       	std	Z+2, r25	; 0x02
    4fc8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4fca:	2f ef       	ldi	r18, 0xFF	; 255
    4fcc:	3f ef       	ldi	r19, 0xFF	; 255
    4fce:	34 83       	std	Z+4, r19	; 0x04
    4fd0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4fd2:	96 83       	std	Z+6, r25	; 0x06
    4fd4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4fd6:	90 87       	std	Z+8, r25	; 0x08
    4fd8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    4fda:	10 82       	st	Z, r1
    4fdc:	08 95       	ret

00004fde <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    4fde:	fc 01       	movw	r30, r24
    4fe0:	11 86       	std	Z+9, r1	; 0x09
    4fe2:	10 86       	std	Z+8, r1	; 0x08
    4fe4:	08 95       	ret

00004fe6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    4fe6:	cf 93       	push	r28
    4fe8:	df 93       	push	r29
    4fea:	9c 01       	movw	r18, r24
    4fec:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    4fee:	dc 01       	movw	r26, r24
    4ff0:	11 96       	adiw	r26, 0x01	; 1
    4ff2:	cd 91       	ld	r28, X+
    4ff4:	dc 91       	ld	r29, X
    4ff6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    4ff8:	d3 83       	std	Z+3, r29	; 0x03
    4ffa:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    4ffc:	8c 81       	ldd	r24, Y+4	; 0x04
    4ffe:	9d 81       	ldd	r25, Y+5	; 0x05
    5000:	95 83       	std	Z+5, r25	; 0x05
    5002:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    5004:	8c 81       	ldd	r24, Y+4	; 0x04
    5006:	9d 81       	ldd	r25, Y+5	; 0x05
    5008:	dc 01       	movw	r26, r24
    500a:	13 96       	adiw	r26, 0x03	; 3
    500c:	7c 93       	st	X, r23
    500e:	6e 93       	st	-X, r22
    5010:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    5012:	7d 83       	std	Y+5, r23	; 0x05
    5014:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    5016:	31 87       	std	Z+9, r19	; 0x09
    5018:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    501a:	f9 01       	movw	r30, r18
    501c:	80 81       	ld	r24, Z
    501e:	8f 5f       	subi	r24, 0xFF	; 255
    5020:	80 83       	st	Z, r24
}
    5022:	df 91       	pop	r29
    5024:	cf 91       	pop	r28
    5026:	08 95       	ret

00005028 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    5028:	cf 93       	push	r28
    502a:	df 93       	push	r29
    502c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    502e:	48 81       	ld	r20, Y
    5030:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    5032:	4f 3f       	cpi	r20, 0xFF	; 255
    5034:	2f ef       	ldi	r18, 0xFF	; 255
    5036:	52 07       	cpc	r21, r18
    5038:	21 f4       	brne	.+8      	; 0x5042 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    503a:	fc 01       	movw	r30, r24
    503c:	a7 81       	ldd	r26, Z+7	; 0x07
    503e:	b0 85       	ldd	r27, Z+8	; 0x08
    5040:	0d c0       	rjmp	.+26     	; 0x505c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    5042:	dc 01       	movw	r26, r24
    5044:	13 96       	adiw	r26, 0x03	; 3
    5046:	01 c0       	rjmp	.+2      	; 0x504a <vListInsert+0x22>
    5048:	df 01       	movw	r26, r30
    504a:	12 96       	adiw	r26, 0x02	; 2
    504c:	ed 91       	ld	r30, X+
    504e:	fc 91       	ld	r31, X
    5050:	13 97       	sbiw	r26, 0x03	; 3
    5052:	20 81       	ld	r18, Z
    5054:	31 81       	ldd	r19, Z+1	; 0x01
    5056:	42 17       	cp	r20, r18
    5058:	53 07       	cpc	r21, r19
    505a:	b0 f7       	brcc	.-20     	; 0x5048 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    505c:	12 96       	adiw	r26, 0x02	; 2
    505e:	ed 91       	ld	r30, X+
    5060:	fc 91       	ld	r31, X
    5062:	13 97       	sbiw	r26, 0x03	; 3
    5064:	fb 83       	std	Y+3, r31	; 0x03
    5066:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    5068:	d5 83       	std	Z+5, r29	; 0x05
    506a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    506c:	bd 83       	std	Y+5, r27	; 0x05
    506e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    5070:	13 96       	adiw	r26, 0x03	; 3
    5072:	dc 93       	st	X, r29
    5074:	ce 93       	st	-X, r28
    5076:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    5078:	99 87       	std	Y+9, r25	; 0x09
    507a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    507c:	fc 01       	movw	r30, r24
    507e:	20 81       	ld	r18, Z
    5080:	2f 5f       	subi	r18, 0xFF	; 255
    5082:	20 83       	st	Z, r18
}
    5084:	df 91       	pop	r29
    5086:	cf 91       	pop	r28
    5088:	08 95       	ret

0000508a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    508a:	cf 93       	push	r28
    508c:	df 93       	push	r29
    508e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    5090:	a0 85       	ldd	r26, Z+8	; 0x08
    5092:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    5094:	c2 81       	ldd	r28, Z+2	; 0x02
    5096:	d3 81       	ldd	r29, Z+3	; 0x03
    5098:	84 81       	ldd	r24, Z+4	; 0x04
    509a:	95 81       	ldd	r25, Z+5	; 0x05
    509c:	9d 83       	std	Y+5, r25	; 0x05
    509e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    50a0:	c4 81       	ldd	r28, Z+4	; 0x04
    50a2:	d5 81       	ldd	r29, Z+5	; 0x05
    50a4:	82 81       	ldd	r24, Z+2	; 0x02
    50a6:	93 81       	ldd	r25, Z+3	; 0x03
    50a8:	9b 83       	std	Y+3, r25	; 0x03
    50aa:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    50ac:	11 96       	adiw	r26, 0x01	; 1
    50ae:	cd 91       	ld	r28, X+
    50b0:	dc 91       	ld	r29, X
    50b2:	12 97       	sbiw	r26, 0x02	; 2
    50b4:	ce 17       	cp	r28, r30
    50b6:	df 07       	cpc	r29, r31
    50b8:	31 f4       	brne	.+12     	; 0x50c6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    50ba:	8c 81       	ldd	r24, Y+4	; 0x04
    50bc:	9d 81       	ldd	r25, Y+5	; 0x05
    50be:	12 96       	adiw	r26, 0x02	; 2
    50c0:	9c 93       	st	X, r25
    50c2:	8e 93       	st	-X, r24
    50c4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    50c6:	11 86       	std	Z+9, r1	; 0x09
    50c8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    50ca:	8c 91       	ld	r24, X
    50cc:	81 50       	subi	r24, 0x01	; 1
    50ce:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    50d0:	8c 91       	ld	r24, X
}
    50d2:	df 91       	pop	r29
    50d4:	cf 91       	pop	r28
    50d6:	08 95       	ret

000050d8 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    50d8:	31 e1       	ldi	r19, 0x11	; 17
    50da:	fc 01       	movw	r30, r24
    50dc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    50de:	31 97       	sbiw	r30, 0x01	; 1
    50e0:	22 e2       	ldi	r18, 0x22	; 34
    50e2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    50e4:	fc 01       	movw	r30, r24
    50e6:	32 97       	sbiw	r30, 0x02	; 2
    50e8:	a3 e3       	ldi	r26, 0x33	; 51
    50ea:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    50ec:	fc 01       	movw	r30, r24
    50ee:	33 97       	sbiw	r30, 0x03	; 3
    50f0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    50f2:	fc 01       	movw	r30, r24
    50f4:	34 97       	sbiw	r30, 0x04	; 4
    50f6:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    50f8:	fc 01       	movw	r30, r24
    50fa:	35 97       	sbiw	r30, 0x05	; 5
    50fc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    50fe:	fc 01       	movw	r30, r24
    5100:	36 97       	sbiw	r30, 0x06	; 6
    5102:	60 e8       	ldi	r22, 0x80	; 128
    5104:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    5106:	fc 01       	movw	r30, r24
    5108:	37 97       	sbiw	r30, 0x07	; 7
    510a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    510c:	fc 01       	movw	r30, r24
    510e:	38 97       	sbiw	r30, 0x08	; 8
    5110:	62 e0       	ldi	r22, 0x02	; 2
    5112:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    5114:	fc 01       	movw	r30, r24
    5116:	39 97       	sbiw	r30, 0x09	; 9
    5118:	63 e0       	ldi	r22, 0x03	; 3
    511a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    511c:	fc 01       	movw	r30, r24
    511e:	3a 97       	sbiw	r30, 0x0a	; 10
    5120:	64 e0       	ldi	r22, 0x04	; 4
    5122:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    5124:	fc 01       	movw	r30, r24
    5126:	3b 97       	sbiw	r30, 0x0b	; 11
    5128:	65 e0       	ldi	r22, 0x05	; 5
    512a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    512c:	fc 01       	movw	r30, r24
    512e:	3c 97       	sbiw	r30, 0x0c	; 12
    5130:	66 e0       	ldi	r22, 0x06	; 6
    5132:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    5134:	fc 01       	movw	r30, r24
    5136:	3d 97       	sbiw	r30, 0x0d	; 13
    5138:	67 e0       	ldi	r22, 0x07	; 7
    513a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    513c:	fc 01       	movw	r30, r24
    513e:	3e 97       	sbiw	r30, 0x0e	; 14
    5140:	68 e0       	ldi	r22, 0x08	; 8
    5142:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    5144:	fc 01       	movw	r30, r24
    5146:	3f 97       	sbiw	r30, 0x0f	; 15
    5148:	69 e0       	ldi	r22, 0x09	; 9
    514a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    514c:	fc 01       	movw	r30, r24
    514e:	70 97       	sbiw	r30, 0x10	; 16
    5150:	60 e1       	ldi	r22, 0x10	; 16
    5152:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    5154:	fc 01       	movw	r30, r24
    5156:	71 97       	sbiw	r30, 0x11	; 17
    5158:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    515a:	fc 01       	movw	r30, r24
    515c:	72 97       	sbiw	r30, 0x12	; 18
    515e:	32 e1       	ldi	r19, 0x12	; 18
    5160:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    5162:	fc 01       	movw	r30, r24
    5164:	73 97       	sbiw	r30, 0x13	; 19
    5166:	33 e1       	ldi	r19, 0x13	; 19
    5168:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    516a:	fc 01       	movw	r30, r24
    516c:	74 97       	sbiw	r30, 0x14	; 20
    516e:	34 e1       	ldi	r19, 0x14	; 20
    5170:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    5172:	fc 01       	movw	r30, r24
    5174:	75 97       	sbiw	r30, 0x15	; 21
    5176:	35 e1       	ldi	r19, 0x15	; 21
    5178:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    517a:	fc 01       	movw	r30, r24
    517c:	76 97       	sbiw	r30, 0x16	; 22
    517e:	36 e1       	ldi	r19, 0x16	; 22
    5180:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    5182:	fc 01       	movw	r30, r24
    5184:	77 97       	sbiw	r30, 0x17	; 23
    5186:	37 e1       	ldi	r19, 0x17	; 23
    5188:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    518a:	fc 01       	movw	r30, r24
    518c:	78 97       	sbiw	r30, 0x18	; 24
    518e:	38 e1       	ldi	r19, 0x18	; 24
    5190:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    5192:	fc 01       	movw	r30, r24
    5194:	79 97       	sbiw	r30, 0x19	; 25
    5196:	39 e1       	ldi	r19, 0x19	; 25
    5198:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    519a:	fc 01       	movw	r30, r24
    519c:	7a 97       	sbiw	r30, 0x1a	; 26
    519e:	30 e2       	ldi	r19, 0x20	; 32
    51a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    51a2:	fc 01       	movw	r30, r24
    51a4:	7b 97       	sbiw	r30, 0x1b	; 27
    51a6:	31 e2       	ldi	r19, 0x21	; 33
    51a8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    51aa:	fc 01       	movw	r30, r24
    51ac:	7c 97       	sbiw	r30, 0x1c	; 28
    51ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    51b0:	fc 01       	movw	r30, r24
    51b2:	7d 97       	sbiw	r30, 0x1d	; 29
    51b4:	23 e2       	ldi	r18, 0x23	; 35
    51b6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    51b8:	fc 01       	movw	r30, r24
    51ba:	7e 97       	sbiw	r30, 0x1e	; 30
    51bc:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    51be:	fc 01       	movw	r30, r24
    51c0:	7f 97       	sbiw	r30, 0x1f	; 31
    51c2:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    51c4:	fc 01       	movw	r30, r24
    51c6:	b0 97       	sbiw	r30, 0x20	; 32
    51c8:	26 e2       	ldi	r18, 0x26	; 38
    51ca:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    51cc:	fc 01       	movw	r30, r24
    51ce:	b1 97       	sbiw	r30, 0x21	; 33
    51d0:	27 e2       	ldi	r18, 0x27	; 39
    51d2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    51d4:	fc 01       	movw	r30, r24
    51d6:	b2 97       	sbiw	r30, 0x22	; 34
    51d8:	28 e2       	ldi	r18, 0x28	; 40
    51da:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    51dc:	fc 01       	movw	r30, r24
    51de:	b3 97       	sbiw	r30, 0x23	; 35
    51e0:	29 e2       	ldi	r18, 0x29	; 41
    51e2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    51e4:	fc 01       	movw	r30, r24
    51e6:	b4 97       	sbiw	r30, 0x24	; 36
    51e8:	20 e3       	ldi	r18, 0x30	; 48
    51ea:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    51ec:	fc 01       	movw	r30, r24
    51ee:	b5 97       	sbiw	r30, 0x25	; 37
    51f0:	21 e3       	ldi	r18, 0x31	; 49
    51f2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    51f4:	9c 01       	movw	r18, r24
    51f6:	26 52       	subi	r18, 0x26	; 38
    51f8:	31 09       	sbc	r19, r1
}
    51fa:	82 2f       	mov	r24, r18
    51fc:	93 2f       	mov	r25, r19
    51fe:	08 95       	ret

00005200 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    5200:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    5202:	89 ef       	ldi	r24, 0xF9	; 249
    5204:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    5206:	8b e0       	ldi	r24, 0x0B	; 11
    5208:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    520a:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    520c:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    520e:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    5210:	a0 91 cd 07 	lds	r26, 0x07CD
    5214:	b0 91 ce 07 	lds	r27, 0x07CE
    5218:	cd 91       	ld	r28, X+
    521a:	cd bf       	out	0x3d, r28	; 61
    521c:	dd 91       	ld	r29, X+
    521e:	de bf       	out	0x3e, r29	; 62
    5220:	ff 91       	pop	r31
    5222:	ef 91       	pop	r30
    5224:	df 91       	pop	r29
    5226:	cf 91       	pop	r28
    5228:	bf 91       	pop	r27
    522a:	af 91       	pop	r26
    522c:	9f 91       	pop	r25
    522e:	8f 91       	pop	r24
    5230:	7f 91       	pop	r23
    5232:	6f 91       	pop	r22
    5234:	5f 91       	pop	r21
    5236:	4f 91       	pop	r20
    5238:	3f 91       	pop	r19
    523a:	2f 91       	pop	r18
    523c:	1f 91       	pop	r17
    523e:	0f 91       	pop	r16
    5240:	ff 90       	pop	r15
    5242:	ef 90       	pop	r14
    5244:	df 90       	pop	r13
    5246:	cf 90       	pop	r12
    5248:	bf 90       	pop	r11
    524a:	af 90       	pop	r10
    524c:	9f 90       	pop	r9
    524e:	8f 90       	pop	r8
    5250:	7f 90       	pop	r7
    5252:	6f 90       	pop	r6
    5254:	5f 90       	pop	r5
    5256:	4f 90       	pop	r4
    5258:	3f 90       	pop	r3
    525a:	2f 90       	pop	r2
    525c:	1f 90       	pop	r1
    525e:	0f 90       	pop	r0
    5260:	0f be       	out	0x3f, r0	; 63
    5262:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5264:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    5266:	81 e0       	ldi	r24, 0x01	; 1
    5268:	08 95       	ret

0000526a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    526a:	0f 92       	push	r0
    526c:	0f b6       	in	r0, 0x3f	; 63
    526e:	f8 94       	cli
    5270:	0f 92       	push	r0
    5272:	1f 92       	push	r1
    5274:	11 24       	eor	r1, r1
    5276:	2f 92       	push	r2
    5278:	3f 92       	push	r3
    527a:	4f 92       	push	r4
    527c:	5f 92       	push	r5
    527e:	6f 92       	push	r6
    5280:	7f 92       	push	r7
    5282:	8f 92       	push	r8
    5284:	9f 92       	push	r9
    5286:	af 92       	push	r10
    5288:	bf 92       	push	r11
    528a:	cf 92       	push	r12
    528c:	df 92       	push	r13
    528e:	ef 92       	push	r14
    5290:	ff 92       	push	r15
    5292:	0f 93       	push	r16
    5294:	1f 93       	push	r17
    5296:	2f 93       	push	r18
    5298:	3f 93       	push	r19
    529a:	4f 93       	push	r20
    529c:	5f 93       	push	r21
    529e:	6f 93       	push	r22
    52a0:	7f 93       	push	r23
    52a2:	8f 93       	push	r24
    52a4:	9f 93       	push	r25
    52a6:	af 93       	push	r26
    52a8:	bf 93       	push	r27
    52aa:	cf 93       	push	r28
    52ac:	df 93       	push	r29
    52ae:	ef 93       	push	r30
    52b0:	ff 93       	push	r31
    52b2:	a0 91 cd 07 	lds	r26, 0x07CD
    52b6:	b0 91 ce 07 	lds	r27, 0x07CE
    52ba:	0d b6       	in	r0, 0x3d	; 61
    52bc:	0d 92       	st	X+, r0
    52be:	0e b6       	in	r0, 0x3e	; 62
    52c0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    52c2:	0e 94 7c 30 	call	0x60f8	; 0x60f8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    52c6:	a0 91 cd 07 	lds	r26, 0x07CD
    52ca:	b0 91 ce 07 	lds	r27, 0x07CE
    52ce:	cd 91       	ld	r28, X+
    52d0:	cd bf       	out	0x3d, r28	; 61
    52d2:	dd 91       	ld	r29, X+
    52d4:	de bf       	out	0x3e, r29	; 62
    52d6:	ff 91       	pop	r31
    52d8:	ef 91       	pop	r30
    52da:	df 91       	pop	r29
    52dc:	cf 91       	pop	r28
    52de:	bf 91       	pop	r27
    52e0:	af 91       	pop	r26
    52e2:	9f 91       	pop	r25
    52e4:	8f 91       	pop	r24
    52e6:	7f 91       	pop	r23
    52e8:	6f 91       	pop	r22
    52ea:	5f 91       	pop	r21
    52ec:	4f 91       	pop	r20
    52ee:	3f 91       	pop	r19
    52f0:	2f 91       	pop	r18
    52f2:	1f 91       	pop	r17
    52f4:	0f 91       	pop	r16
    52f6:	ff 90       	pop	r15
    52f8:	ef 90       	pop	r14
    52fa:	df 90       	pop	r13
    52fc:	cf 90       	pop	r12
    52fe:	bf 90       	pop	r11
    5300:	af 90       	pop	r10
    5302:	9f 90       	pop	r9
    5304:	8f 90       	pop	r8
    5306:	7f 90       	pop	r7
    5308:	6f 90       	pop	r6
    530a:	5f 90       	pop	r5
    530c:	4f 90       	pop	r4
    530e:	3f 90       	pop	r3
    5310:	2f 90       	pop	r2
    5312:	1f 90       	pop	r1
    5314:	0f 90       	pop	r0
    5316:	0f be       	out	0x3f, r0	; 63
    5318:	0f 90       	pop	r0

	asm volatile ( "ret" );
    531a:	08 95       	ret

0000531c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    531c:	0f 92       	push	r0
    531e:	0f b6       	in	r0, 0x3f	; 63
    5320:	f8 94       	cli
    5322:	0f 92       	push	r0
    5324:	1f 92       	push	r1
    5326:	11 24       	eor	r1, r1
    5328:	2f 92       	push	r2
    532a:	3f 92       	push	r3
    532c:	4f 92       	push	r4
    532e:	5f 92       	push	r5
    5330:	6f 92       	push	r6
    5332:	7f 92       	push	r7
    5334:	8f 92       	push	r8
    5336:	9f 92       	push	r9
    5338:	af 92       	push	r10
    533a:	bf 92       	push	r11
    533c:	cf 92       	push	r12
    533e:	df 92       	push	r13
    5340:	ef 92       	push	r14
    5342:	ff 92       	push	r15
    5344:	0f 93       	push	r16
    5346:	1f 93       	push	r17
    5348:	2f 93       	push	r18
    534a:	3f 93       	push	r19
    534c:	4f 93       	push	r20
    534e:	5f 93       	push	r21
    5350:	6f 93       	push	r22
    5352:	7f 93       	push	r23
    5354:	8f 93       	push	r24
    5356:	9f 93       	push	r25
    5358:	af 93       	push	r26
    535a:	bf 93       	push	r27
    535c:	cf 93       	push	r28
    535e:	df 93       	push	r29
    5360:	ef 93       	push	r30
    5362:	ff 93       	push	r31
    5364:	a0 91 cd 07 	lds	r26, 0x07CD
    5368:	b0 91 ce 07 	lds	r27, 0x07CE
    536c:	0d b6       	in	r0, 0x3d	; 61
    536e:	0d 92       	st	X+, r0
    5370:	0e b6       	in	r0, 0x3e	; 62
    5372:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    5374:	0e 94 2d 2f 	call	0x5e5a	; 0x5e5a <xTaskIncrementTick>
    5378:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    537a:	0e 94 7c 30 	call	0x60f8	; 0x60f8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    537e:	a0 91 cd 07 	lds	r26, 0x07CD
    5382:	b0 91 ce 07 	lds	r27, 0x07CE
    5386:	cd 91       	ld	r28, X+
    5388:	cd bf       	out	0x3d, r28	; 61
    538a:	dd 91       	ld	r29, X+
    538c:	de bf       	out	0x3e, r29	; 62
    538e:	ff 91       	pop	r31
    5390:	ef 91       	pop	r30
    5392:	df 91       	pop	r29
    5394:	cf 91       	pop	r28
    5396:	bf 91       	pop	r27
    5398:	af 91       	pop	r26
    539a:	9f 91       	pop	r25
    539c:	8f 91       	pop	r24
    539e:	7f 91       	pop	r23
    53a0:	6f 91       	pop	r22
    53a2:	5f 91       	pop	r21
    53a4:	4f 91       	pop	r20
    53a6:	3f 91       	pop	r19
    53a8:	2f 91       	pop	r18
    53aa:	1f 91       	pop	r17
    53ac:	0f 91       	pop	r16
    53ae:	ff 90       	pop	r15
    53b0:	ef 90       	pop	r14
    53b2:	df 90       	pop	r13
    53b4:	cf 90       	pop	r12
    53b6:	bf 90       	pop	r11
    53b8:	af 90       	pop	r10
    53ba:	9f 90       	pop	r9
    53bc:	8f 90       	pop	r8
    53be:	7f 90       	pop	r7
    53c0:	6f 90       	pop	r6
    53c2:	5f 90       	pop	r5
    53c4:	4f 90       	pop	r4
    53c6:	3f 90       	pop	r3
    53c8:	2f 90       	pop	r2
    53ca:	1f 90       	pop	r1
    53cc:	0f 90       	pop	r0
    53ce:	0f be       	out	0x3f, r0	; 63
    53d0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    53d2:	08 95       	ret

000053d4 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    53d4:	0e 94 8e 29 	call	0x531c	; 0x531c <vPortYieldFromTick>
		asm volatile ( "reti" );
    53d8:	18 95       	reti

000053da <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    53da:	0f b6       	in	r0, 0x3f	; 63
    53dc:	f8 94       	cli
    53de:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    53e0:	fc 01       	movw	r30, r24
    53e2:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    53e4:	0f 90       	pop	r0
    53e6:	0f be       	out	0x3f, r0	; 63
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    53e8:	81 e0       	ldi	r24, 0x01	; 1
    53ea:	91 11       	cpse	r25, r1
    53ec:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    53ee:	08 95       	ret

000053f0 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    53f0:	fc 01       	movw	r30, r24
    53f2:	86 2f       	mov	r24, r22
    53f4:	97 2f       	mov	r25, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    53f6:	44 8d       	ldd	r20, Z+28	; 0x1c
    53f8:	44 23       	and	r20, r20
    53fa:	a1 f0       	breq	.+40     	; 0x5424 <prvCopyDataFromQueue+0x34>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    53fc:	26 81       	ldd	r18, Z+6	; 0x06
    53fe:	37 81       	ldd	r19, Z+7	; 0x07
    5400:	24 0f       	add	r18, r20
    5402:	31 1d       	adc	r19, r1
    5404:	37 83       	std	Z+7, r19	; 0x07
    5406:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    5408:	a2 81       	ldd	r26, Z+2	; 0x02
    540a:	b3 81       	ldd	r27, Z+3	; 0x03
    540c:	2a 17       	cp	r18, r26
    540e:	3b 07       	cpc	r19, r27
    5410:	20 f0       	brcs	.+8      	; 0x541a <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    5412:	20 81       	ld	r18, Z
    5414:	31 81       	ldd	r19, Z+1	; 0x01
    5416:	37 83       	std	Z+7, r19	; 0x07
    5418:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    541a:	66 81       	ldd	r22, Z+6	; 0x06
    541c:	77 81       	ldd	r23, Z+7	; 0x07
    541e:	50 e0       	ldi	r21, 0x00	; 0
    5420:	0e 94 f6 35 	call	0x6bec	; 0x6bec <memcpy>
    5424:	08 95       	ret

00005426 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    5426:	ff 92       	push	r15
    5428:	0f 93       	push	r16
    542a:	1f 93       	push	r17
    542c:	cf 93       	push	r28
    542e:	df 93       	push	r29
    5430:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    5432:	0f b6       	in	r0, 0x3f	; 63
    5434:	f8 94       	cli
    5436:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    5438:	fe 8c       	ldd	r15, Y+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    543a:	1f 14       	cp	r1, r15
    543c:	9c f4       	brge	.+38     	; 0x5464 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    543e:	89 89       	ldd	r24, Y+17	; 0x11
    5440:	81 11       	cpse	r24, r1
    5442:	05 c0       	rjmp	.+10     	; 0x544e <prvUnlockQueue+0x28>
    5444:	0f c0       	rjmp	.+30     	; 0x5464 <prvUnlockQueue+0x3e>
    5446:	89 89       	ldd	r24, Y+17	; 0x11
    5448:	81 11       	cpse	r24, r1
    544a:	04 c0       	rjmp	.+8      	; 0x5454 <prvUnlockQueue+0x2e>
    544c:	0b c0       	rjmp	.+22     	; 0x5464 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    544e:	8e 01       	movw	r16, r28
    5450:	0f 5e       	subi	r16, 0xEF	; 239
    5452:	1f 4f       	sbci	r17, 0xFF	; 255
    5454:	c8 01       	movw	r24, r16
    5456:	0e 94 e6 30 	call	0x61cc	; 0x61cc <xTaskRemoveFromEventList>
    545a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    545c:	0e 94 66 31 	call	0x62cc	; 0x62cc <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    5460:	fa 94       	dec	r15
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    5462:	89 f7       	brne	.-30     	; 0x5446 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    5464:	8f ef       	ldi	r24, 0xFF	; 255
    5466:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    5468:	0f 90       	pop	r0
    546a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    546c:	0f b6       	in	r0, 0x3f	; 63
    546e:	f8 94       	cli
    5470:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    5472:	fd 8c       	ldd	r15, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
    5474:	1f 14       	cp	r1, r15
    5476:	9c f4       	brge	.+38     	; 0x549e <prvUnlockQueue+0x78>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5478:	88 85       	ldd	r24, Y+8	; 0x08
    547a:	81 11       	cpse	r24, r1
    547c:	05 c0       	rjmp	.+10     	; 0x5488 <prvUnlockQueue+0x62>
    547e:	0f c0       	rjmp	.+30     	; 0x549e <prvUnlockQueue+0x78>
    5480:	88 85       	ldd	r24, Y+8	; 0x08
    5482:	81 11       	cpse	r24, r1
    5484:	04 c0       	rjmp	.+8      	; 0x548e <prvUnlockQueue+0x68>
    5486:	0b c0       	rjmp	.+22     	; 0x549e <prvUnlockQueue+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5488:	8e 01       	movw	r16, r28
    548a:	08 5f       	subi	r16, 0xF8	; 248
    548c:	1f 4f       	sbci	r17, 0xFF	; 255
    548e:	c8 01       	movw	r24, r16
    5490:	0e 94 e6 30 	call	0x61cc	; 0x61cc <xTaskRemoveFromEventList>
    5494:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    5496:	0e 94 66 31 	call	0x62cc	; 0x62cc <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    549a:	fa 94       	dec	r15
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    549c:	89 f7       	brne	.-30     	; 0x5480 <prvUnlockQueue+0x5a>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    549e:	8f ef       	ldi	r24, 0xFF	; 255
    54a0:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    54a2:	0f 90       	pop	r0
    54a4:	0f be       	out	0x3f, r0	; 63
}
    54a6:	df 91       	pop	r29
    54a8:	cf 91       	pop	r28
    54aa:	1f 91       	pop	r17
    54ac:	0f 91       	pop	r16
    54ae:	ff 90       	pop	r15
    54b0:	08 95       	ret

000054b2 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    54b2:	0f 93       	push	r16
    54b4:	1f 93       	push	r17
    54b6:	cf 93       	push	r28
    54b8:	df 93       	push	r29
    54ba:	ec 01       	movw	r28, r24
    54bc:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    54be:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    54c0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    54c2:	41 11       	cpse	r20, r1
    54c4:	0c c0       	rjmp	.+24     	; 0x54de <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    54c6:	88 81       	ld	r24, Y
    54c8:	99 81       	ldd	r25, Y+1	; 0x01
    54ca:	89 2b       	or	r24, r25
    54cc:	09 f0       	breq	.+2      	; 0x54d0 <prvCopyDataToQueue+0x1e>
    54ce:	42 c0       	rjmp	.+132    	; 0x5554 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    54d0:	8a 81       	ldd	r24, Y+2	; 0x02
    54d2:	9b 81       	ldd	r25, Y+3	; 0x03
    54d4:	0e 94 d7 31 	call	0x63ae	; 0x63ae <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    54d8:	1b 82       	std	Y+3, r1	; 0x03
    54da:	1a 82       	std	Y+2, r1	; 0x02
    54dc:	42 c0       	rjmp	.+132    	; 0x5562 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    54de:	01 11       	cpse	r16, r1
    54e0:	17 c0       	rjmp	.+46     	; 0x5510 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    54e2:	50 e0       	ldi	r21, 0x00	; 0
    54e4:	8c 81       	ldd	r24, Y+4	; 0x04
    54e6:	9d 81       	ldd	r25, Y+5	; 0x05
    54e8:	0e 94 f6 35 	call	0x6bec	; 0x6bec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    54ec:	2c 8d       	ldd	r18, Y+28	; 0x1c
    54ee:	8c 81       	ldd	r24, Y+4	; 0x04
    54f0:	9d 81       	ldd	r25, Y+5	; 0x05
    54f2:	82 0f       	add	r24, r18
    54f4:	91 1d       	adc	r25, r1
    54f6:	9d 83       	std	Y+5, r25	; 0x05
    54f8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    54fa:	2a 81       	ldd	r18, Y+2	; 0x02
    54fc:	3b 81       	ldd	r19, Y+3	; 0x03
    54fe:	82 17       	cp	r24, r18
    5500:	93 07       	cpc	r25, r19
    5502:	50 f1       	brcs	.+84     	; 0x5558 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    5504:	88 81       	ld	r24, Y
    5506:	99 81       	ldd	r25, Y+1	; 0x01
    5508:	9d 83       	std	Y+5, r25	; 0x05
    550a:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    550c:	80 e0       	ldi	r24, 0x00	; 0
    550e:	29 c0       	rjmp	.+82     	; 0x5562 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5510:	50 e0       	ldi	r21, 0x00	; 0
    5512:	8e 81       	ldd	r24, Y+6	; 0x06
    5514:	9f 81       	ldd	r25, Y+7	; 0x07
    5516:	0e 94 f6 35 	call	0x6bec	; 0x6bec <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    551a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    551c:	30 e0       	ldi	r19, 0x00	; 0
    551e:	31 95       	neg	r19
    5520:	21 95       	neg	r18
    5522:	31 09       	sbc	r19, r1
    5524:	8e 81       	ldd	r24, Y+6	; 0x06
    5526:	9f 81       	ldd	r25, Y+7	; 0x07
    5528:	82 0f       	add	r24, r18
    552a:	93 1f       	adc	r25, r19
    552c:	9f 83       	std	Y+7, r25	; 0x07
    552e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    5530:	68 81       	ld	r22, Y
    5532:	79 81       	ldd	r23, Y+1	; 0x01
    5534:	86 17       	cp	r24, r22
    5536:	97 07       	cpc	r25, r23
    5538:	30 f4       	brcc	.+12     	; 0x5546 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    553a:	8a 81       	ldd	r24, Y+2	; 0x02
    553c:	9b 81       	ldd	r25, Y+3	; 0x03
    553e:	28 0f       	add	r18, r24
    5540:	39 1f       	adc	r19, r25
    5542:	3f 83       	std	Y+7, r19	; 0x07
    5544:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    5546:	02 30       	cpi	r16, 0x02	; 2
    5548:	49 f4       	brne	.+18     	; 0x555c <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    554a:	11 23       	and	r17, r17
    554c:	49 f0       	breq	.+18     	; 0x5560 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    554e:	11 50       	subi	r17, 0x01	; 1
#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    5550:	80 e0       	ldi	r24, 0x00	; 0
    5552:	07 c0       	rjmp	.+14     	; 0x5562 <prvCopyDataToQueue+0xb0>
    5554:	80 e0       	ldi	r24, 0x00	; 0
    5556:	05 c0       	rjmp	.+10     	; 0x5562 <prvCopyDataToQueue+0xb0>
    5558:	80 e0       	ldi	r24, 0x00	; 0
    555a:	03 c0       	rjmp	.+6      	; 0x5562 <prvCopyDataToQueue+0xb0>
    555c:	80 e0       	ldi	r24, 0x00	; 0
    555e:	01 c0       	rjmp	.+2      	; 0x5562 <prvCopyDataToQueue+0xb0>
    5560:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    5562:	1f 5f       	subi	r17, 0xFF	; 255
    5564:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    5566:	df 91       	pop	r29
    5568:	cf 91       	pop	r28
    556a:	1f 91       	pop	r17
    556c:	0f 91       	pop	r16
    556e:	08 95       	ret

00005570 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    5570:	cf 93       	push	r28
    5572:	df 93       	push	r29
    5574:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    5576:	0f b6       	in	r0, 0x3f	; 63
    5578:	f8 94       	cli
    557a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    557c:	88 81       	ld	r24, Y
    557e:	99 81       	ldd	r25, Y+1	; 0x01
    5580:	4b 8d       	ldd	r20, Y+27	; 0x1b
    5582:	50 e0       	ldi	r21, 0x00	; 0
    5584:	2c 8d       	ldd	r18, Y+28	; 0x1c
    5586:	30 e0       	ldi	r19, 0x00	; 0
    5588:	42 9f       	mul	r20, r18
    558a:	f0 01       	movw	r30, r0
    558c:	43 9f       	mul	r20, r19
    558e:	f0 0d       	add	r31, r0
    5590:	52 9f       	mul	r21, r18
    5592:	f0 0d       	add	r31, r0
    5594:	11 24       	eor	r1, r1
    5596:	e8 0f       	add	r30, r24
    5598:	f9 1f       	adc	r31, r25
    559a:	fb 83       	std	Y+3, r31	; 0x03
    559c:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    559e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    55a0:	9d 83       	std	Y+5, r25	; 0x05
    55a2:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    55a4:	41 50       	subi	r20, 0x01	; 1
    55a6:	51 09       	sbc	r21, r1
    55a8:	24 9f       	mul	r18, r20
    55aa:	f0 01       	movw	r30, r0
    55ac:	25 9f       	mul	r18, r21
    55ae:	f0 0d       	add	r31, r0
    55b0:	34 9f       	mul	r19, r20
    55b2:	f0 0d       	add	r31, r0
    55b4:	11 24       	eor	r1, r1
    55b6:	8e 0f       	add	r24, r30
    55b8:	9f 1f       	adc	r25, r31
    55ba:	9f 83       	std	Y+7, r25	; 0x07
    55bc:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    55be:	8f ef       	ldi	r24, 0xFF	; 255
    55c0:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    55c2:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    55c4:	61 11       	cpse	r22, r1
    55c6:	0c c0       	rjmp	.+24     	; 0x55e0 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    55c8:	88 85       	ldd	r24, Y+8	; 0x08
    55ca:	88 23       	and	r24, r24
    55cc:	89 f0       	breq	.+34     	; 0x55f0 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    55ce:	ce 01       	movw	r24, r28
    55d0:	08 96       	adiw	r24, 0x08	; 8
    55d2:	0e 94 e6 30 	call	0x61cc	; 0x61cc <xTaskRemoveFromEventList>
    55d6:	88 23       	and	r24, r24
    55d8:	59 f0       	breq	.+22     	; 0x55f0 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    55da:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
    55de:	08 c0       	rjmp	.+16     	; 0x55f0 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    55e0:	ce 01       	movw	r24, r28
    55e2:	08 96       	adiw	r24, 0x08	; 8
    55e4:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    55e8:	ce 01       	movw	r24, r28
    55ea:	41 96       	adiw	r24, 0x11	; 17
    55ec:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    55f0:	0f 90       	pop	r0
    55f2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    55f4:	81 e0       	ldi	r24, 0x01	; 1
    55f6:	df 91       	pop	r29
    55f8:	cf 91       	pop	r28
    55fa:	08 95       	ret

000055fc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    55fc:	0f 93       	push	r16
    55fe:	1f 93       	push	r17
    5600:	cf 93       	push	r28
    5602:	df 93       	push	r29
    5604:	08 2f       	mov	r16, r24
    5606:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    5608:	66 23       	and	r22, r22
    560a:	d9 f0       	breq	.+54     	; 0x5642 <xQueueGenericCreate+0x46>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    560c:	86 9f       	mul	r24, r22
    560e:	c0 01       	movw	r24, r0
    5610:	11 24       	eor	r1, r1
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    5612:	4f 96       	adiw	r24, 0x1f	; 31
    5614:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <pvPortMalloc>
    5618:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    561a:	00 97       	sbiw	r24, 0x00	; 0
    561c:	21 f4       	brne	.+8      	; 0x5626 <xQueueGenericCreate+0x2a>
    561e:	0e c0       	rjmp	.+28     	; 0x563c <xQueueGenericCreate+0x40>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    5620:	d9 83       	std	Y+1, r29	; 0x01
    5622:	c8 83       	st	Y, r28
    5624:	05 c0       	rjmp	.+10     	; 0x5630 <xQueueGenericCreate+0x34>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    5626:	9c 01       	movw	r18, r24
    5628:	21 5e       	subi	r18, 0xE1	; 225
    562a:	3f 4f       	sbci	r19, 0xFF	; 255
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    562c:	39 83       	std	Y+1, r19	; 0x01
    562e:	28 83       	st	Y, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    5630:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    5632:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    5634:	61 e0       	ldi	r22, 0x01	; 1
    5636:	ce 01       	movw	r24, r28
    5638:	0e 94 b8 2a 	call	0x5570	; 0x5570 <xQueueGenericReset>
		else
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
    563c:	8c 2f       	mov	r24, r28
    563e:	9d 2f       	mov	r25, r29
    5640:	08 c0       	rjmp	.+16     	; 0x5652 <xQueueGenericCreate+0x56>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    5642:	8f e1       	ldi	r24, 0x1F	; 31
    5644:	90 e0       	ldi	r25, 0x00	; 0
    5646:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <pvPortMalloc>
    564a:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    564c:	00 97       	sbiw	r24, 0x00	; 0
    564e:	41 f7       	brne	.-48     	; 0x5620 <xQueueGenericCreate+0x24>
    5650:	f5 cf       	rjmp	.-22     	; 0x563c <xQueueGenericCreate+0x40>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
		}

		return pxNewQueue;
	}
    5652:	df 91       	pop	r29
    5654:	cf 91       	pop	r28
    5656:	1f 91       	pop	r17
    5658:	0f 91       	pop	r16
    565a:	08 95       	ret

0000565c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    565c:	9f 92       	push	r9
    565e:	af 92       	push	r10
    5660:	bf 92       	push	r11
    5662:	cf 92       	push	r12
    5664:	df 92       	push	r13
    5666:	ef 92       	push	r14
    5668:	ff 92       	push	r15
    566a:	0f 93       	push	r16
    566c:	1f 93       	push	r17
    566e:	cf 93       	push	r28
    5670:	df 93       	push	r29
    5672:	00 d0       	rcall	.+0      	; 0x5674 <xQueueGenericSend+0x18>
    5674:	00 d0       	rcall	.+0      	; 0x5676 <xQueueGenericSend+0x1a>
    5676:	1f 92       	push	r1
    5678:	cd b7       	in	r28, 0x3d	; 61
    567a:	de b7       	in	r29, 0x3e	; 62
    567c:	8c 01       	movw	r16, r24
    567e:	6b 01       	movw	r12, r22
    5680:	5d 83       	std	Y+5, r21	; 0x05
    5682:	4c 83       	std	Y+4, r20	; 0x04
    5684:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    5686:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    5688:	99 24       	eor	r9, r9
    568a:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    568c:	7c 01       	movw	r14, r24
    568e:	88 e0       	ldi	r24, 0x08	; 8
    5690:	e8 0e       	add	r14, r24
    5692:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5694:	0f b6       	in	r0, 0x3f	; 63
    5696:	f8 94       	cli
    5698:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    569a:	f8 01       	movw	r30, r16
    569c:	92 8d       	ldd	r25, Z+26	; 0x1a
    569e:	83 8d       	ldd	r24, Z+27	; 0x1b
    56a0:	98 17       	cp	r25, r24
    56a2:	18 f0       	brcs	.+6      	; 0x56aa <xQueueGenericSend+0x4e>
    56a4:	f2 e0       	ldi	r31, 0x02	; 2
    56a6:	af 12       	cpse	r10, r31
    56a8:	19 c0       	rjmp	.+50     	; 0x56dc <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    56aa:	4a 2d       	mov	r20, r10
    56ac:	b6 01       	movw	r22, r12
    56ae:	c8 01       	movw	r24, r16
    56b0:	0e 94 59 2a 	call	0x54b2	; 0x54b2 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    56b4:	f8 01       	movw	r30, r16
    56b6:	91 89       	ldd	r25, Z+17	; 0x11
    56b8:	99 23       	and	r25, r25
    56ba:	49 f0       	breq	.+18     	; 0x56ce <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    56bc:	c8 01       	movw	r24, r16
    56be:	41 96       	adiw	r24, 0x11	; 17
    56c0:	0e 94 e6 30 	call	0x61cc	; 0x61cc <xTaskRemoveFromEventList>
    56c4:	88 23       	and	r24, r24
    56c6:	31 f0       	breq	.+12     	; 0x56d4 <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    56c8:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
    56cc:	03 c0       	rjmp	.+6      	; 0x56d4 <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    56ce:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    56d0:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    56d4:	0f 90       	pop	r0
    56d6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    56d8:	81 e0       	ldi	r24, 0x01	; 1
    56da:	51 c0       	rjmp	.+162    	; 0x577e <xQueueGenericSend+0x122>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    56dc:	ec 81       	ldd	r30, Y+4	; 0x04
    56de:	fd 81       	ldd	r31, Y+5	; 0x05
    56e0:	ef 2b       	or	r30, r31
    56e2:	21 f4       	brne	.+8      	; 0x56ec <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    56e4:	0f 90       	pop	r0
    56e6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    56e8:	80 e0       	ldi	r24, 0x00	; 0
    56ea:	49 c0       	rjmp	.+146    	; 0x577e <xQueueGenericSend+0x122>
				}
				else if( xEntryTimeSet == pdFALSE )
    56ec:	b1 10       	cpse	r11, r1
    56ee:	05 c0       	rjmp	.+10     	; 0x56fa <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    56f0:	ce 01       	movw	r24, r28
    56f2:	01 96       	adiw	r24, 0x01	; 1
    56f4:	0e 94 2f 31 	call	0x625e	; 0x625e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    56f8:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    56fa:	0f 90       	pop	r0
    56fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    56fe:	0e 94 27 2f 	call	0x5e4e	; 0x5e4e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5702:	0f b6       	in	r0, 0x3f	; 63
    5704:	f8 94       	cli
    5706:	0f 92       	push	r0
    5708:	f8 01       	movw	r30, r16
    570a:	85 8d       	ldd	r24, Z+29	; 0x1d
    570c:	8f 3f       	cpi	r24, 0xFF	; 255
    570e:	09 f4       	brne	.+2      	; 0x5712 <xQueueGenericSend+0xb6>
    5710:	15 8e       	std	Z+29, r1	; 0x1d
    5712:	f8 01       	movw	r30, r16
    5714:	86 8d       	ldd	r24, Z+30	; 0x1e
    5716:	8f 3f       	cpi	r24, 0xFF	; 255
    5718:	09 f4       	brne	.+2      	; 0x571c <xQueueGenericSend+0xc0>
    571a:	16 8e       	std	Z+30, r1	; 0x1e
    571c:	0f 90       	pop	r0
    571e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5720:	be 01       	movw	r22, r28
    5722:	6c 5f       	subi	r22, 0xFC	; 252
    5724:	7f 4f       	sbci	r23, 0xFF	; 255
    5726:	ce 01       	movw	r24, r28
    5728:	01 96       	adiw	r24, 0x01	; 1
    572a:	0e 94 3a 31 	call	0x6274	; 0x6274 <xTaskCheckForTimeOut>
    572e:	81 11       	cpse	r24, r1
    5730:	20 c0       	rjmp	.+64     	; 0x5772 <xQueueGenericSend+0x116>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    5732:	0f b6       	in	r0, 0x3f	; 63
    5734:	f8 94       	cli
    5736:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    5738:	f8 01       	movw	r30, r16
    573a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    573c:	0f 90       	pop	r0
    573e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    5740:	f8 01       	movw	r30, r16
    5742:	83 8d       	ldd	r24, Z+27	; 0x1b
    5744:	98 13       	cpse	r25, r24
    5746:	0f c0       	rjmp	.+30     	; 0x5766 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5748:	6c 81       	ldd	r22, Y+4	; 0x04
    574a:	7d 81       	ldd	r23, Y+5	; 0x05
    574c:	c7 01       	movw	r24, r14
    574e:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5752:	c8 01       	movw	r24, r16
    5754:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    5758:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
    575c:	81 11       	cpse	r24, r1
    575e:	9a cf       	rjmp	.-204    	; 0x5694 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    5760:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
    5764:	97 cf       	rjmp	.-210    	; 0x5694 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    5766:	c8 01       	movw	r24, r16
    5768:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    576c:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
    5770:	91 cf       	rjmp	.-222    	; 0x5694 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    5772:	c8 01       	movw	r24, r16
    5774:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5778:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    577c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    577e:	0f 90       	pop	r0
    5780:	0f 90       	pop	r0
    5782:	0f 90       	pop	r0
    5784:	0f 90       	pop	r0
    5786:	0f 90       	pop	r0
    5788:	df 91       	pop	r29
    578a:	cf 91       	pop	r28
    578c:	1f 91       	pop	r17
    578e:	0f 91       	pop	r16
    5790:	ff 90       	pop	r15
    5792:	ef 90       	pop	r14
    5794:	df 90       	pop	r13
    5796:	cf 90       	pop	r12
    5798:	bf 90       	pop	r11
    579a:	af 90       	pop	r10
    579c:	9f 90       	pop	r9
    579e:	08 95       	ret

000057a0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    57a0:	cf 93       	push	r28
    57a2:	df 93       	push	r29
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    57a4:	48 2f       	mov	r20, r24
    57a6:	60 e0       	ldi	r22, 0x00	; 0
    57a8:	81 e0       	ldi	r24, 0x01	; 1
    57aa:	0e 94 fe 2a 	call	0x55fc	; 0x55fc <xQueueGenericCreate>
    57ae:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    57b0:	00 97       	sbiw	r24, 0x00	; 0
    57b2:	61 f0       	breq	.+24     	; 0x57cc <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    57b4:	1b 82       	std	Y+3, r1	; 0x03
    57b6:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    57b8:	19 82       	std	Y+1, r1	; 0x01
    57ba:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    57bc:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    57be:	20 e0       	ldi	r18, 0x00	; 0
    57c0:	40 e0       	ldi	r20, 0x00	; 0
    57c2:	50 e0       	ldi	r21, 0x00	; 0
    57c4:	60 e0       	ldi	r22, 0x00	; 0
    57c6:	70 e0       	ldi	r23, 0x00	; 0
    57c8:	0e 94 2e 2b 	call	0x565c	; 0x565c <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
    57cc:	8c 2f       	mov	r24, r28
    57ce:	9d 2f       	mov	r25, r29
    57d0:	df 91       	pop	r29
    57d2:	cf 91       	pop	r28
    57d4:	08 95       	ret

000057d6 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    57d6:	ff 92       	push	r15
    57d8:	0f 93       	push	r16
    57da:	1f 93       	push	r17
    57dc:	cf 93       	push	r28
    57de:	df 93       	push	r29
    57e0:	ec 01       	movw	r28, r24
    57e2:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    57e4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    57e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    57e8:	98 17       	cp	r25, r24
    57ea:	10 f0       	brcs	.+4      	; 0x57f0 <xQueueGenericSendFromISR+0x1a>
    57ec:	22 30       	cpi	r18, 0x02	; 2
    57ee:	e1 f4       	brne	.+56     	; 0x5828 <xQueueGenericSendFromISR+0x52>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    57f0:	fe 8c       	ldd	r15, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    57f2:	42 2f       	mov	r20, r18
    57f4:	ce 01       	movw	r24, r28
    57f6:	0e 94 59 2a 	call	0x54b2	; 0x54b2 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    57fa:	8f ef       	ldi	r24, 0xFF	; 255
    57fc:	f8 12       	cpse	r15, r24
    57fe:	10 c0       	rjmp	.+32     	; 0x5820 <xQueueGenericSendFromISR+0x4a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5800:	89 89       	ldd	r24, Y+17	; 0x11
    5802:	88 23       	and	r24, r24
    5804:	99 f0       	breq	.+38     	; 0x582c <xQueueGenericSendFromISR+0x56>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5806:	ce 01       	movw	r24, r28
    5808:	41 96       	adiw	r24, 0x11	; 17
    580a:	0e 94 e6 30 	call	0x61cc	; 0x61cc <xTaskRemoveFromEventList>
    580e:	88 23       	and	r24, r24
    5810:	79 f0       	breq	.+30     	; 0x5830 <xQueueGenericSendFromISR+0x5a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    5812:	01 15       	cp	r16, r1
    5814:	11 05       	cpc	r17, r1
    5816:	71 f0       	breq	.+28     	; 0x5834 <xQueueGenericSendFromISR+0x5e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    5818:	81 e0       	ldi	r24, 0x01	; 1
    581a:	f8 01       	movw	r30, r16
    581c:	80 83       	st	Z, r24
    581e:	0b c0       	rjmp	.+22     	; 0x5836 <xQueueGenericSendFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    5820:	f3 94       	inc	r15
    5822:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
    5824:	81 e0       	ldi	r24, 0x01	; 1
    5826:	07 c0       	rjmp	.+14     	; 0x5836 <xQueueGenericSendFromISR+0x60>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5828:	80 e0       	ldi	r24, 0x00	; 0
    582a:	05 c0       	rjmp	.+10     	; 0x5836 <xQueueGenericSendFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    582c:	81 e0       	ldi	r24, 0x01	; 1
    582e:	03 c0       	rjmp	.+6      	; 0x5836 <xQueueGenericSendFromISR+0x60>
    5830:	81 e0       	ldi	r24, 0x01	; 1
    5832:	01 c0       	rjmp	.+2      	; 0x5836 <xQueueGenericSendFromISR+0x60>
    5834:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    5836:	df 91       	pop	r29
    5838:	cf 91       	pop	r28
    583a:	1f 91       	pop	r17
    583c:	0f 91       	pop	r16
    583e:	ff 90       	pop	r15
    5840:	08 95       	ret

00005842 <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    5842:	9f 92       	push	r9
    5844:	af 92       	push	r10
    5846:	bf 92       	push	r11
    5848:	cf 92       	push	r12
    584a:	df 92       	push	r13
    584c:	ef 92       	push	r14
    584e:	ff 92       	push	r15
    5850:	0f 93       	push	r16
    5852:	1f 93       	push	r17
    5854:	cf 93       	push	r28
    5856:	df 93       	push	r29
    5858:	00 d0       	rcall	.+0      	; 0x585a <xQueueReceive+0x18>
    585a:	00 d0       	rcall	.+0      	; 0x585c <xQueueReceive+0x1a>
    585c:	1f 92       	push	r1
    585e:	cd b7       	in	r28, 0x3d	; 61
    5860:	de b7       	in	r29, 0x3e	; 62
    5862:	8c 01       	movw	r16, r24
    5864:	6b 01       	movw	r12, r22
    5866:	5d 83       	std	Y+5, r21	; 0x05
    5868:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    586a:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    586c:	99 24       	eor	r9, r9
    586e:	93 94       	inc	r9
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5870:	7c 01       	movw	r14, r24
    5872:	81 e1       	ldi	r24, 0x11	; 17
    5874:	e8 0e       	add	r14, r24
    5876:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    5878:	0f b6       	in	r0, 0x3f	; 63
    587a:	f8 94       	cli
    587c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    587e:	f8 01       	movw	r30, r16
    5880:	b2 8c       	ldd	r11, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    5882:	bb 20       	and	r11, r11
    5884:	a9 f0       	breq	.+42     	; 0x58b0 <xQueueReceive+0x6e>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5886:	b6 01       	movw	r22, r12
    5888:	c8 01       	movw	r24, r16
    588a:	0e 94 f8 29 	call	0x53f0	; 0x53f0 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    588e:	ba 94       	dec	r11
    5890:	f8 01       	movw	r30, r16
    5892:	b2 8e       	std	Z+26, r11	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5894:	80 85       	ldd	r24, Z+8	; 0x08
    5896:	88 23       	and	r24, r24
    5898:	39 f0       	breq	.+14     	; 0x58a8 <xQueueReceive+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    589a:	c8 01       	movw	r24, r16
    589c:	08 96       	adiw	r24, 0x08	; 8
    589e:	0e 94 e6 30 	call	0x61cc	; 0x61cc <xTaskRemoveFromEventList>
    58a2:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    58a4:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    58a8:	0f 90       	pop	r0
    58aa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    58ac:	81 e0       	ldi	r24, 0x01	; 1
    58ae:	51 c0       	rjmp	.+162    	; 0x5952 <xQueueReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    58b0:	2c 81       	ldd	r18, Y+4	; 0x04
    58b2:	3d 81       	ldd	r19, Y+5	; 0x05
    58b4:	23 2b       	or	r18, r19
    58b6:	21 f4       	brne	.+8      	; 0x58c0 <xQueueReceive+0x7e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    58b8:	0f 90       	pop	r0
    58ba:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    58bc:	80 e0       	ldi	r24, 0x00	; 0
    58be:	49 c0       	rjmp	.+146    	; 0x5952 <xQueueReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
    58c0:	a1 10       	cpse	r10, r1
    58c2:	05 c0       	rjmp	.+10     	; 0x58ce <xQueueReceive+0x8c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    58c4:	ce 01       	movw	r24, r28
    58c6:	01 96       	adiw	r24, 0x01	; 1
    58c8:	0e 94 2f 31 	call	0x625e	; 0x625e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    58cc:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    58ce:	0f 90       	pop	r0
    58d0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    58d2:	0e 94 27 2f 	call	0x5e4e	; 0x5e4e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    58d6:	0f b6       	in	r0, 0x3f	; 63
    58d8:	f8 94       	cli
    58da:	0f 92       	push	r0
    58dc:	f8 01       	movw	r30, r16
    58de:	85 8d       	ldd	r24, Z+29	; 0x1d
    58e0:	8f 3f       	cpi	r24, 0xFF	; 255
    58e2:	09 f4       	brne	.+2      	; 0x58e6 <xQueueReceive+0xa4>
    58e4:	15 8e       	std	Z+29, r1	; 0x1d
    58e6:	f8 01       	movw	r30, r16
    58e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    58ea:	8f 3f       	cpi	r24, 0xFF	; 255
    58ec:	09 f4       	brne	.+2      	; 0x58f0 <xQueueReceive+0xae>
    58ee:	16 8e       	std	Z+30, r1	; 0x1e
    58f0:	0f 90       	pop	r0
    58f2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    58f4:	be 01       	movw	r22, r28
    58f6:	6c 5f       	subi	r22, 0xFC	; 252
    58f8:	7f 4f       	sbci	r23, 0xFF	; 255
    58fa:	ce 01       	movw	r24, r28
    58fc:	01 96       	adiw	r24, 0x01	; 1
    58fe:	0e 94 3a 31 	call	0x6274	; 0x6274 <xTaskCheckForTimeOut>
    5902:	81 11       	cpse	r24, r1
    5904:	1a c0       	rjmp	.+52     	; 0x593a <xQueueReceive+0xf8>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5906:	c8 01       	movw	r24, r16
    5908:	0e 94 ed 29 	call	0x53da	; 0x53da <prvIsQueueEmpty>
    590c:	88 23       	and	r24, r24
    590e:	79 f0       	breq	.+30     	; 0x592e <xQueueReceive+0xec>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5910:	6c 81       	ldd	r22, Y+4	; 0x04
    5912:	7d 81       	ldd	r23, Y+5	; 0x05
    5914:	c7 01       	movw	r24, r14
    5916:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    591a:	c8 01       	movw	r24, r16
    591c:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5920:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
    5924:	81 11       	cpse	r24, r1
    5926:	a8 cf       	rjmp	.-176    	; 0x5878 <xQueueReceive+0x36>
				{
					portYIELD_WITHIN_API();
    5928:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
    592c:	a5 cf       	rjmp	.-182    	; 0x5878 <xQueueReceive+0x36>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    592e:	c8 01       	movw	r24, r16
    5930:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5934:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
    5938:	9f cf       	rjmp	.-194    	; 0x5878 <xQueueReceive+0x36>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    593a:	c8 01       	movw	r24, r16
    593c:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5940:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5944:	c8 01       	movw	r24, r16
    5946:	0e 94 ed 29 	call	0x53da	; 0x53da <prvIsQueueEmpty>
    594a:	88 23       	and	r24, r24
    594c:	09 f4       	brne	.+2      	; 0x5950 <xQueueReceive+0x10e>
    594e:	94 cf       	rjmp	.-216    	; 0x5878 <xQueueReceive+0x36>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    5950:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    5952:	0f 90       	pop	r0
    5954:	0f 90       	pop	r0
    5956:	0f 90       	pop	r0
    5958:	0f 90       	pop	r0
    595a:	0f 90       	pop	r0
    595c:	df 91       	pop	r29
    595e:	cf 91       	pop	r28
    5960:	1f 91       	pop	r17
    5962:	0f 91       	pop	r16
    5964:	ff 90       	pop	r15
    5966:	ef 90       	pop	r14
    5968:	df 90       	pop	r13
    596a:	cf 90       	pop	r12
    596c:	bf 90       	pop	r11
    596e:	af 90       	pop	r10
    5970:	9f 90       	pop	r9
    5972:	08 95       	ret

00005974 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    5974:	bf 92       	push	r11
    5976:	cf 92       	push	r12
    5978:	df 92       	push	r13
    597a:	ef 92       	push	r14
    597c:	ff 92       	push	r15
    597e:	0f 93       	push	r16
    5980:	1f 93       	push	r17
    5982:	cf 93       	push	r28
    5984:	df 93       	push	r29
    5986:	00 d0       	rcall	.+0      	; 0x5988 <xQueueSemaphoreTake+0x14>
    5988:	00 d0       	rcall	.+0      	; 0x598a <xQueueSemaphoreTake+0x16>
    598a:	1f 92       	push	r1
    598c:	cd b7       	in	r28, 0x3d	; 61
    598e:	de b7       	in	r29, 0x3e	; 62
    5990:	8c 01       	movw	r16, r24
    5992:	7d 83       	std	Y+5, r23	; 0x05
    5994:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    5996:	b1 2c       	mov	r11, r1
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
BaseType_t xEntryTimeSet = pdFALSE;
    5998:	d1 2c       	mov	r13, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    599a:	cc 24       	eor	r12, r12
    599c:	c3 94       	inc	r12
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    599e:	7c 01       	movw	r14, r24
    59a0:	81 e1       	ldi	r24, 0x11	; 17
    59a2:	e8 0e       	add	r14, r24
    59a4:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    59a6:	0f b6       	in	r0, 0x3f	; 63
    59a8:	f8 94       	cli
    59aa:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    59ac:	d8 01       	movw	r26, r16
    59ae:	5a 96       	adiw	r26, 0x1a	; 26
    59b0:	9c 91       	ld	r25, X
    59b2:	5a 97       	sbiw	r26, 0x1a	; 26

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    59b4:	99 23       	and	r25, r25
    59b6:	e9 f0       	breq	.+58     	; 0x59f2 <xQueueSemaphoreTake+0x7e>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    59b8:	91 50       	subi	r25, 0x01	; 1
    59ba:	5a 96       	adiw	r26, 0x1a	; 26
    59bc:	9c 93       	st	X, r25
    59be:	5a 97       	sbiw	r26, 0x1a	; 26

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    59c0:	8d 91       	ld	r24, X+
    59c2:	9c 91       	ld	r25, X
    59c4:	89 2b       	or	r24, r25
    59c6:	29 f4       	brne	.+10     	; 0x59d2 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    59c8:	0e 94 65 32 	call	0x64ca	; 0x64ca <pvTaskIncrementMutexHeldCount>
    59cc:	f8 01       	movw	r30, r16
    59ce:	93 83       	std	Z+3, r25	; 0x03
    59d0:	82 83       	std	Z+2, r24	; 0x02
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    59d2:	d8 01       	movw	r26, r16
    59d4:	18 96       	adiw	r26, 0x08	; 8
    59d6:	8c 91       	ld	r24, X
    59d8:	88 23       	and	r24, r24
    59da:	39 f0       	breq	.+14     	; 0x59ea <xQueueSemaphoreTake+0x76>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    59dc:	c8 01       	movw	r24, r16
    59de:	08 96       	adiw	r24, 0x08	; 8
    59e0:	0e 94 e6 30 	call	0x61cc	; 0x61cc <xTaskRemoveFromEventList>
    59e4:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    59e6:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    59ea:	0f 90       	pop	r0
    59ec:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    59ee:	81 e0       	ldi	r24, 0x01	; 1
    59f0:	7f c0       	rjmp	.+254    	; 0x5af0 <xQueueSemaphoreTake+0x17c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    59f2:	2c 81       	ldd	r18, Y+4	; 0x04
    59f4:	3d 81       	ldd	r19, Y+5	; 0x05
    59f6:	23 2b       	or	r18, r19
    59f8:	21 f4       	brne	.+8      	; 0x5a02 <xQueueSemaphoreTake+0x8e>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    59fa:	0f 90       	pop	r0
    59fc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    59fe:	80 e0       	ldi	r24, 0x00	; 0
    5a00:	77 c0       	rjmp	.+238    	; 0x5af0 <xQueueSemaphoreTake+0x17c>
				}
				else if( xEntryTimeSet == pdFALSE )
    5a02:	d1 10       	cpse	r13, r1
    5a04:	05 c0       	rjmp	.+10     	; 0x5a10 <xQueueSemaphoreTake+0x9c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    5a06:	ce 01       	movw	r24, r28
    5a08:	01 96       	adiw	r24, 0x01	; 1
    5a0a:	0e 94 2f 31 	call	0x625e	; 0x625e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5a0e:	dc 2c       	mov	r13, r12
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    5a10:	0f 90       	pop	r0
    5a12:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    5a14:	0e 94 27 2f 	call	0x5e4e	; 0x5e4e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5a18:	0f b6       	in	r0, 0x3f	; 63
    5a1a:	f8 94       	cli
    5a1c:	0f 92       	push	r0
    5a1e:	f8 01       	movw	r30, r16
    5a20:	95 8d       	ldd	r25, Z+29	; 0x1d
    5a22:	9f 3f       	cpi	r25, 0xFF	; 255
    5a24:	09 f4       	brne	.+2      	; 0x5a28 <xQueueSemaphoreTake+0xb4>
    5a26:	15 8e       	std	Z+29, r1	; 0x1d
    5a28:	d8 01       	movw	r26, r16
    5a2a:	5e 96       	adiw	r26, 0x1e	; 30
    5a2c:	9c 91       	ld	r25, X
    5a2e:	5e 97       	sbiw	r26, 0x1e	; 30
    5a30:	9f 3f       	cpi	r25, 0xFF	; 255
    5a32:	11 f4       	brne	.+4      	; 0x5a38 <xQueueSemaphoreTake+0xc4>
    5a34:	5e 96       	adiw	r26, 0x1e	; 30
    5a36:	1c 92       	st	X, r1
    5a38:	0f 90       	pop	r0
    5a3a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5a3c:	be 01       	movw	r22, r28
    5a3e:	6c 5f       	subi	r22, 0xFC	; 252
    5a40:	7f 4f       	sbci	r23, 0xFF	; 255
    5a42:	ce 01       	movw	r24, r28
    5a44:	01 96       	adiw	r24, 0x01	; 1
    5a46:	0e 94 3a 31 	call	0x6274	; 0x6274 <xTaskCheckForTimeOut>
    5a4a:	81 11       	cpse	r24, r1
    5a4c:	29 c0       	rjmp	.+82     	; 0x5aa0 <xQueueSemaphoreTake+0x12c>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5a4e:	c8 01       	movw	r24, r16
    5a50:	0e 94 ed 29 	call	0x53da	; 0x53da <prvIsQueueEmpty>
    5a54:	88 23       	and	r24, r24
    5a56:	f1 f0       	breq	.+60     	; 0x5a94 <xQueueSemaphoreTake+0x120>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    5a58:	f8 01       	movw	r30, r16
    5a5a:	20 81       	ld	r18, Z
    5a5c:	31 81       	ldd	r19, Z+1	; 0x01
    5a5e:	23 2b       	or	r18, r19
    5a60:	51 f4       	brne	.+20     	; 0x5a76 <xQueueSemaphoreTake+0x102>
					{
						taskENTER_CRITICAL();
    5a62:	0f b6       	in	r0, 0x3f	; 63
    5a64:	f8 94       	cli
    5a66:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    5a68:	82 81       	ldd	r24, Z+2	; 0x02
    5a6a:	93 81       	ldd	r25, Z+3	; 0x03
    5a6c:	0e 94 6a 31 	call	0x62d4	; 0x62d4 <xTaskPriorityInherit>
    5a70:	b8 2e       	mov	r11, r24
						}
						taskEXIT_CRITICAL();
    5a72:	0f 90       	pop	r0
    5a74:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5a76:	6c 81       	ldd	r22, Y+4	; 0x04
    5a78:	7d 81       	ldd	r23, Y+5	; 0x05
    5a7a:	c7 01       	movw	r24, r14
    5a7c:	0e 94 d4 30 	call	0x61a8	; 0x61a8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5a80:	c8 01       	movw	r24, r16
    5a82:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5a86:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
    5a8a:	81 11       	cpse	r24, r1
    5a8c:	8c cf       	rjmp	.-232    	; 0x59a6 <xQueueSemaphoreTake+0x32>
				{
					portYIELD_WITHIN_API();
    5a8e:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
    5a92:	89 cf       	rjmp	.-238    	; 0x59a6 <xQueueSemaphoreTake+0x32>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    5a94:	c8 01       	movw	r24, r16
    5a96:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5a9a:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
    5a9e:	83 cf       	rjmp	.-250    	; 0x59a6 <xQueueSemaphoreTake+0x32>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    5aa0:	c8 01       	movw	r24, r16
    5aa2:	0e 94 13 2a 	call	0x5426	; 0x5426 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5aa6:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5aaa:	c8 01       	movw	r24, r16
    5aac:	0e 94 ed 29 	call	0x53da	; 0x53da <prvIsQueueEmpty>
    5ab0:	88 23       	and	r24, r24
    5ab2:	09 f4       	brne	.+2      	; 0x5ab6 <xQueueSemaphoreTake+0x142>
    5ab4:	78 cf       	rjmp	.-272    	; 0x59a6 <xQueueSemaphoreTake+0x32>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    5ab6:	bb 20       	and	r11, r11
    5ab8:	d1 f0       	breq	.+52     	; 0x5aee <xQueueSemaphoreTake+0x17a>
					{
						taskENTER_CRITICAL();
    5aba:	0f b6       	in	r0, 0x3f	; 63
    5abc:	f8 94       	cli
    5abe:	0f 92       	push	r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
    5ac0:	f8 01       	movw	r30, r16
    5ac2:	81 89       	ldd	r24, Z+17	; 0x11
    5ac4:	88 23       	and	r24, r24
    5ac6:	39 f0       	breq	.+14     	; 0x5ad6 <xQueueSemaphoreTake+0x162>
		{
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    5ac8:	06 88       	ldd	r0, Z+22	; 0x16
    5aca:	f7 89       	ldd	r31, Z+23	; 0x17
    5acc:	e0 2d       	mov	r30, r0
    5ace:	80 81       	ld	r24, Z
    5ad0:	65 e0       	ldi	r22, 0x05	; 5
    5ad2:	68 1b       	sub	r22, r24
    5ad4:	01 c0       	rjmp	.+2      	; 0x5ad8 <xQueueSemaphoreTake+0x164>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    5ad6:	60 e0       	ldi	r22, 0x00	; 0
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
    5ad8:	d8 01       	movw	r26, r16
    5ada:	12 96       	adiw	r26, 0x02	; 2
    5adc:	8d 91       	ld	r24, X+
    5ade:	9c 91       	ld	r25, X
    5ae0:	13 97       	sbiw	r26, 0x03	; 3
    5ae2:	0e 94 16 32 	call	0x642c	; 0x642c <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    5ae6:	0f 90       	pop	r0
    5ae8:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    5aea:	80 e0       	ldi	r24, 0x00	; 0
    5aec:	01 c0       	rjmp	.+2      	; 0x5af0 <xQueueSemaphoreTake+0x17c>
    5aee:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    5af0:	0f 90       	pop	r0
    5af2:	0f 90       	pop	r0
    5af4:	0f 90       	pop	r0
    5af6:	0f 90       	pop	r0
    5af8:	0f 90       	pop	r0
    5afa:	df 91       	pop	r29
    5afc:	cf 91       	pop	r28
    5afe:	1f 91       	pop	r17
    5b00:	0f 91       	pop	r16
    5b02:	ff 90       	pop	r15
    5b04:	ef 90       	pop	r14
    5b06:	df 90       	pop	r13
    5b08:	cf 90       	pop	r12
    5b0a:	bf 90       	pop	r11
    5b0c:	08 95       	ret

00005b0e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5b0e:	e0 91 dc 07 	lds	r30, 0x07DC
    5b12:	f0 91 dd 07 	lds	r31, 0x07DD
    5b16:	80 81       	ld	r24, Z
    5b18:	81 11       	cpse	r24, r1
    5b1a:	07 c0       	rjmp	.+14     	; 0x5b2a <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5b1c:	8f ef       	ldi	r24, 0xFF	; 255
    5b1e:	9f ef       	ldi	r25, 0xFF	; 255
    5b20:	90 93 d1 07 	sts	0x07D1, r25
    5b24:	80 93 d0 07 	sts	0x07D0, r24
    5b28:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5b2a:	e0 91 dc 07 	lds	r30, 0x07DC
    5b2e:	f0 91 dd 07 	lds	r31, 0x07DD
    5b32:	05 80       	ldd	r0, Z+5	; 0x05
    5b34:	f6 81       	ldd	r31, Z+6	; 0x06
    5b36:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5b38:	06 80       	ldd	r0, Z+6	; 0x06
    5b3a:	f7 81       	ldd	r31, Z+7	; 0x07
    5b3c:	e0 2d       	mov	r30, r0
    5b3e:	82 81       	ldd	r24, Z+2	; 0x02
    5b40:	93 81       	ldd	r25, Z+3	; 0x03
    5b42:	90 93 d1 07 	sts	0x07D1, r25
    5b46:	80 93 d0 07 	sts	0x07D0, r24
    5b4a:	08 95       	ret

00005b4c <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5b4c:	cf ed       	ldi	r28, 0xDF	; 223
    5b4e:	d7 e0       	ldi	r29, 0x07	; 7
    5b50:	88 81       	ld	r24, Y
    5b52:	82 30       	cpi	r24, 0x02	; 2
    5b54:	e8 f3       	brcs	.-6      	; 0x5b50 <prvIdleTask+0x4>
			{
				taskYIELD();
    5b56:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
    5b5a:	fa cf       	rjmp	.-12     	; 0x5b50 <prvIdleTask+0x4>

00005b5c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5b5c:	0f 93       	push	r16
    5b5e:	1f 93       	push	r17
    5b60:	cf 93       	push	r28
    5b62:	df 93       	push	r29
    5b64:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5b66:	00 91 d7 07 	lds	r16, 0x07D7
    5b6a:	10 91 d8 07 	lds	r17, 0x07D8
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5b6e:	80 91 cd 07 	lds	r24, 0x07CD
    5b72:	90 91 ce 07 	lds	r25, 0x07CE
    5b76:	02 96       	adiw	r24, 0x02	; 2
    5b78:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    5b7c:	c0 0f       	add	r28, r16
    5b7e:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5b80:	e0 91 cd 07 	lds	r30, 0x07CD
    5b84:	f0 91 ce 07 	lds	r31, 0x07CE
    5b88:	d3 83       	std	Z+3, r29	; 0x03
    5b8a:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    5b8c:	c0 17       	cp	r28, r16
    5b8e:	d1 07       	cpc	r29, r17
    5b90:	68 f4       	brcc	.+26     	; 0x5bac <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5b92:	60 91 cd 07 	lds	r22, 0x07CD
    5b96:	70 91 ce 07 	lds	r23, 0x07CE
    5b9a:	80 91 da 07 	lds	r24, 0x07DA
    5b9e:	90 91 db 07 	lds	r25, 0x07DB
    5ba2:	6e 5f       	subi	r22, 0xFE	; 254
    5ba4:	7f 4f       	sbci	r23, 0xFF	; 255
    5ba6:	0e 94 14 28 	call	0x5028	; 0x5028 <vListInsert>
    5baa:	17 c0       	rjmp	.+46     	; 0x5bda <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5bac:	60 91 cd 07 	lds	r22, 0x07CD
    5bb0:	70 91 ce 07 	lds	r23, 0x07CE
    5bb4:	80 91 dc 07 	lds	r24, 0x07DC
    5bb8:	90 91 dd 07 	lds	r25, 0x07DD
    5bbc:	6e 5f       	subi	r22, 0xFE	; 254
    5bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    5bc0:	0e 94 14 28 	call	0x5028	; 0x5028 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    5bc4:	80 91 d0 07 	lds	r24, 0x07D0
    5bc8:	90 91 d1 07 	lds	r25, 0x07D1
    5bcc:	c8 17       	cp	r28, r24
    5bce:	d9 07       	cpc	r29, r25
    5bd0:	20 f4       	brcc	.+8      	; 0x5bda <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    5bd2:	d0 93 d1 07 	sts	0x07D1, r29
    5bd6:	c0 93 d0 07 	sts	0x07D0, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5bda:	df 91       	pop	r29
    5bdc:	cf 91       	pop	r28
    5bde:	1f 91       	pop	r17
    5be0:	0f 91       	pop	r16
    5be2:	08 95       	ret

00005be4 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    5be4:	4f 92       	push	r4
    5be6:	5f 92       	push	r5
    5be8:	6f 92       	push	r6
    5bea:	7f 92       	push	r7
    5bec:	8f 92       	push	r8
    5bee:	9f 92       	push	r9
    5bf0:	af 92       	push	r10
    5bf2:	bf 92       	push	r11
    5bf4:	cf 92       	push	r12
    5bf6:	df 92       	push	r13
    5bf8:	ef 92       	push	r14
    5bfa:	ff 92       	push	r15
    5bfc:	0f 93       	push	r16
    5bfe:	cf 93       	push	r28
    5c00:	df 93       	push	r29
    5c02:	4c 01       	movw	r8, r24
    5c04:	6b 01       	movw	r12, r22
    5c06:	5a 01       	movw	r10, r20
    5c08:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5c0a:	ca 01       	movw	r24, r20
    5c0c:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <pvPortMalloc>
    5c10:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
    5c12:	00 97       	sbiw	r24, 0x00	; 0
    5c14:	09 f4       	brne	.+2      	; 0x5c18 <xTaskCreate+0x34>
    5c16:	e0 c0       	rjmp	.+448    	; 0x5dd8 <xTaskCreate+0x1f4>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    5c18:	8a e2       	ldi	r24, 0x2A	; 42
    5c1a:	90 e0       	ldi	r25, 0x00	; 0
    5c1c:	0e 94 aa 27 	call	0x4f54	; 0x4f54 <pvPortMalloc>
    5c20:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    5c22:	00 97       	sbiw	r24, 0x00	; 0
    5c24:	71 f0       	breq	.+28     	; 0x5c42 <xTaskCreate+0x5e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    5c26:	78 8e       	std	Y+24, r7	; 0x18
    5c28:	6f 8a       	std	Y+23, r6	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    5c2a:	81 e0       	ldi	r24, 0x01	; 1
    5c2c:	a8 1a       	sub	r10, r24
    5c2e:	b1 08       	sbc	r11, r1
    5c30:	6a 0c       	add	r6, r10
    5c32:	7b 1c       	adc	r7, r11
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    5c34:	d6 01       	movw	r26, r12
    5c36:	8c 91       	ld	r24, X
    5c38:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5c3a:	8c 91       	ld	r24, X
    5c3c:	81 11       	cpse	r24, r1
    5c3e:	05 c0       	rjmp	.+10     	; 0x5c4a <xTaskCreate+0x66>
    5c40:	16 c0       	rjmp	.+44     	; 0x5c6e <xTaskCreate+0x8a>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    5c42:	c3 01       	movw	r24, r6
    5c44:	0e 94 e0 27 	call	0x4fc0	; 0x4fc0 <vPortFree>
    5c48:	c7 c0       	rjmp	.+398    	; 0x5dd8 <xTaskCreate+0x1f4>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    5c4a:	ae 01       	movw	r20, r28
    5c4c:	46 5e       	subi	r20, 0xE6	; 230
    5c4e:	5f 4f       	sbci	r21, 0xFF	; 255
    5c50:	f6 01       	movw	r30, r12
    5c52:	31 96       	adiw	r30, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5c54:	21 e0       	ldi	r18, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    5c56:	cf 01       	movw	r24, r30
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    5c58:	31 91       	ld	r19, Z+
    5c5a:	da 01       	movw	r26, r20
    5c5c:	3d 93       	st	X+, r19
    5c5e:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    5c60:	dc 01       	movw	r26, r24
    5c62:	8c 91       	ld	r24, X
    5c64:	88 23       	and	r24, r24
    5c66:	19 f0       	breq	.+6      	; 0x5c6e <xTaskCreate+0x8a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5c68:	2f 5f       	subi	r18, 0xFF	; 255
    5c6a:	2a 30       	cpi	r18, 0x0A	; 10
    5c6c:	a1 f7       	brne	.-24     	; 0x5c56 <xTaskCreate+0x72>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5c6e:	1a a2       	std	Y+34, r1	; 0x22
    5c70:	05 30       	cpi	r16, 0x05	; 5
    5c72:	08 f0       	brcs	.+2      	; 0x5c76 <xTaskCreate+0x92>
    5c74:	04 e0       	ldi	r16, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    5c76:	0e 8b       	std	Y+22, r16	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    5c78:	0b a3       	std	Y+35, r16	; 0x23
		pxNewTCB->uxMutexesHeld = 0;
    5c7a:	1c a2       	std	Y+36, r1	; 0x24
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    5c7c:	6e 01       	movw	r12, r28
    5c7e:	b2 e0       	ldi	r27, 0x02	; 2
    5c80:	cb 0e       	add	r12, r27
    5c82:	d1 1c       	adc	r13, r1
    5c84:	c6 01       	movw	r24, r12
    5c86:	0e 94 ef 27 	call	0x4fde	; 0x4fde <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    5c8a:	ce 01       	movw	r24, r28
    5c8c:	0c 96       	adiw	r24, 0x0c	; 12
    5c8e:	0e 94 ef 27 	call	0x4fde	; 0x4fde <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    5c92:	d9 87       	std	Y+9, r29	; 0x09
    5c94:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5c96:	85 e0       	ldi	r24, 0x05	; 5
    5c98:	90 e0       	ldi	r25, 0x00	; 0
    5c9a:	80 1b       	sub	r24, r16
    5c9c:	91 09       	sbc	r25, r1
    5c9e:	9d 87       	std	Y+13, r25	; 0x0d
    5ca0:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    5ca2:	db 8b       	std	Y+19, r29	; 0x13
    5ca4:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    5ca6:	1d a2       	std	Y+37, r1	; 0x25
    5ca8:	1e a2       	std	Y+38, r1	; 0x26
    5caa:	1f a2       	std	Y+39, r1	; 0x27
    5cac:	18 a6       	std	Y+40, r1	; 0x28
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5cae:	19 a6       	std	Y+41, r1	; 0x29
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5cb0:	a2 01       	movw	r20, r4
    5cb2:	b4 01       	movw	r22, r8
    5cb4:	c3 01       	movw	r24, r6
    5cb6:	0e 94 6c 28 	call	0x50d8	; 0x50d8 <pxPortInitialiseStack>
    5cba:	99 83       	std	Y+1, r25	; 0x01
    5cbc:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    5cbe:	e1 14       	cp	r14, r1
    5cc0:	f1 04       	cpc	r15, r1
    5cc2:	19 f0       	breq	.+6      	; 0x5cca <xTaskCreate+0xe6>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    5cc4:	f7 01       	movw	r30, r14
    5cc6:	d1 83       	std	Z+1, r29	; 0x01
    5cc8:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    5cca:	0f b6       	in	r0, 0x3f	; 63
    5ccc:	f8 94       	cli
    5cce:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    5cd0:	80 91 d9 07 	lds	r24, 0x07D9
    5cd4:	8f 5f       	subi	r24, 0xFF	; 255
    5cd6:	80 93 d9 07 	sts	0x07D9, r24
		if( pxCurrentTCB == NULL )
    5cda:	80 91 cd 07 	lds	r24, 0x07CD
    5cde:	90 91 ce 07 	lds	r25, 0x07CE
    5ce2:	89 2b       	or	r24, r25
    5ce4:	c1 f5       	brne	.+112    	; 0x5d56 <xTaskCreate+0x172>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    5ce6:	d0 93 ce 07 	sts	0x07CE, r29
    5cea:	c0 93 cd 07 	sts	0x07CD, r28

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    5cee:	80 91 d9 07 	lds	r24, 0x07D9
    5cf2:	81 30       	cpi	r24, 0x01	; 1
    5cf4:	09 f0       	breq	.+2      	; 0x5cf8 <xTaskCreate+0x114>
    5cf6:	3f c0       	rjmp	.+126    	; 0x5d76 <xTaskCreate+0x192>
    5cf8:	e1 2c       	mov	r14, r1
    5cfa:	f1 2c       	mov	r15, r1
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5cfc:	c7 01       	movw	r24, r14
    5cfe:	88 0f       	add	r24, r24
    5d00:	99 1f       	adc	r25, r25
    5d02:	88 0f       	add	r24, r24
    5d04:	99 1f       	adc	r25, r25
    5d06:	88 0f       	add	r24, r24
    5d08:	99 1f       	adc	r25, r25
    5d0a:	8e 0d       	add	r24, r14
    5d0c:	9f 1d       	adc	r25, r15
    5d0e:	81 52       	subi	r24, 0x21	; 33
    5d10:	98 4f       	sbci	r25, 0xF8	; 248
    5d12:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vListInitialise>
    5d16:	ff ef       	ldi	r31, 0xFF	; 255
    5d18:	ef 1a       	sub	r14, r31
    5d1a:	ff 0a       	sbc	r15, r31

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5d1c:	85 e0       	ldi	r24, 0x05	; 5
    5d1e:	e8 16       	cp	r14, r24
    5d20:	f1 04       	cpc	r15, r1
    5d22:	61 f7       	brne	.-40     	; 0x5cfc <xTaskCreate+0x118>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5d24:	8c e0       	ldi	r24, 0x0C	; 12
    5d26:	98 e0       	ldi	r25, 0x08	; 8
    5d28:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5d2c:	85 e1       	ldi	r24, 0x15	; 21
    5d2e:	98 e0       	ldi	r25, 0x08	; 8
    5d30:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5d34:	8e e1       	ldi	r24, 0x1E	; 30
    5d36:	98 e0       	ldi	r25, 0x08	; 8
    5d38:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5d3c:	8c e0       	ldi	r24, 0x0C	; 12
    5d3e:	98 e0       	ldi	r25, 0x08	; 8
    5d40:	90 93 dd 07 	sts	0x07DD, r25
    5d44:	80 93 dc 07 	sts	0x07DC, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5d48:	85 e1       	ldi	r24, 0x15	; 21
    5d4a:	98 e0       	ldi	r25, 0x08	; 8
    5d4c:	90 93 db 07 	sts	0x07DB, r25
    5d50:	80 93 da 07 	sts	0x07DA, r24
    5d54:	10 c0       	rjmp	.+32     	; 0x5d76 <xTaskCreate+0x192>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    5d56:	80 91 d5 07 	lds	r24, 0x07D5
    5d5a:	81 11       	cpse	r24, r1
    5d5c:	0c c0       	rjmp	.+24     	; 0x5d76 <xTaskCreate+0x192>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    5d5e:	e0 91 cd 07 	lds	r30, 0x07CD
    5d62:	f0 91 ce 07 	lds	r31, 0x07CE
    5d66:	96 89       	ldd	r25, Z+22	; 0x16
    5d68:	8e 89       	ldd	r24, Y+22	; 0x16
    5d6a:	89 17       	cp	r24, r25
    5d6c:	20 f0       	brcs	.+8      	; 0x5d76 <xTaskCreate+0x192>
				{
					pxCurrentTCB = pxNewTCB;
    5d6e:	d0 93 ce 07 	sts	0x07CE, r29
    5d72:	c0 93 cd 07 	sts	0x07CD, r28
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    5d76:	80 91 de 07 	lds	r24, 0x07DE
    5d7a:	8f 5f       	subi	r24, 0xFF	; 255
    5d7c:	80 93 de 07 	sts	0x07DE, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    5d80:	8e 89       	ldd	r24, Y+22	; 0x16
    5d82:	90 91 d6 07 	lds	r25, 0x07D6
    5d86:	98 17       	cp	r25, r24
    5d88:	10 f4       	brcc	.+4      	; 0x5d8e <xTaskCreate+0x1aa>
    5d8a:	80 93 d6 07 	sts	0x07D6, r24
    5d8e:	90 e0       	ldi	r25, 0x00	; 0
    5d90:	9c 01       	movw	r18, r24
    5d92:	22 0f       	add	r18, r18
    5d94:	33 1f       	adc	r19, r19
    5d96:	22 0f       	add	r18, r18
    5d98:	33 1f       	adc	r19, r19
    5d9a:	22 0f       	add	r18, r18
    5d9c:	33 1f       	adc	r19, r19
    5d9e:	82 0f       	add	r24, r18
    5da0:	93 1f       	adc	r25, r19
    5da2:	b6 01       	movw	r22, r12
    5da4:	81 52       	subi	r24, 0x21	; 33
    5da6:	98 4f       	sbci	r25, 0xF8	; 248
    5da8:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    5dac:	0f 90       	pop	r0
    5dae:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    5db0:	80 91 d5 07 	lds	r24, 0x07D5
    5db4:	88 23       	and	r24, r24
    5db6:	61 f0       	breq	.+24     	; 0x5dd0 <xTaskCreate+0x1ec>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    5db8:	e0 91 cd 07 	lds	r30, 0x07CD
    5dbc:	f0 91 ce 07 	lds	r31, 0x07CE
    5dc0:	96 89       	ldd	r25, Z+22	; 0x16
    5dc2:	8e 89       	ldd	r24, Y+22	; 0x16
    5dc4:	98 17       	cp	r25, r24
    5dc6:	30 f4       	brcc	.+12     	; 0x5dd4 <xTaskCreate+0x1f0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    5dc8:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    5dcc:	81 e0       	ldi	r24, 0x01	; 1
    5dce:	05 c0       	rjmp	.+10     	; 0x5dda <xTaskCreate+0x1f6>
    5dd0:	81 e0       	ldi	r24, 0x01	; 1
    5dd2:	03 c0       	rjmp	.+6      	; 0x5dda <xTaskCreate+0x1f6>
    5dd4:	81 e0       	ldi	r24, 0x01	; 1
    5dd6:	01 c0       	rjmp	.+2      	; 0x5dda <xTaskCreate+0x1f6>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5dd8:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
    5dda:	df 91       	pop	r29
    5ddc:	cf 91       	pop	r28
    5dde:	0f 91       	pop	r16
    5de0:	ff 90       	pop	r15
    5de2:	ef 90       	pop	r14
    5de4:	df 90       	pop	r13
    5de6:	cf 90       	pop	r12
    5de8:	bf 90       	pop	r11
    5dea:	af 90       	pop	r10
    5dec:	9f 90       	pop	r9
    5dee:	8f 90       	pop	r8
    5df0:	7f 90       	pop	r7
    5df2:	6f 90       	pop	r6
    5df4:	5f 90       	pop	r5
    5df6:	4f 90       	pop	r4
    5df8:	08 95       	ret

00005dfa <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    5dfa:	ef 92       	push	r14
    5dfc:	ff 92       	push	r15
    5dfe:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    5e00:	0f 2e       	mov	r0, r31
    5e02:	f7 e2       	ldi	r31, 0x27	; 39
    5e04:	ef 2e       	mov	r14, r31
    5e06:	f8 e0       	ldi	r31, 0x08	; 8
    5e08:	ff 2e       	mov	r15, r31
    5e0a:	f0 2d       	mov	r31, r0
    5e0c:	00 e0       	ldi	r16, 0x00	; 0
    5e0e:	20 e0       	ldi	r18, 0x00	; 0
    5e10:	30 e0       	ldi	r19, 0x00	; 0
    5e12:	44 e6       	ldi	r20, 0x64	; 100
    5e14:	50 e0       	ldi	r21, 0x00	; 0
    5e16:	61 eb       	ldi	r22, 0xB1	; 177
    5e18:	71 e0       	ldi	r23, 0x01	; 1
    5e1a:	86 ea       	ldi	r24, 0xA6	; 166
    5e1c:	9d e2       	ldi	r25, 0x2D	; 45
    5e1e:	0e 94 f2 2d 	call	0x5be4	; 0x5be4 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    5e22:	81 30       	cpi	r24, 0x01	; 1
    5e24:	81 f4       	brne	.+32     	; 0x5e46 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    5e26:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    5e28:	8f ef       	ldi	r24, 0xFF	; 255
    5e2a:	9f ef       	ldi	r25, 0xFF	; 255
    5e2c:	90 93 d1 07 	sts	0x07D1, r25
    5e30:	80 93 d0 07 	sts	0x07D0, r24
		xSchedulerRunning = pdTRUE;
    5e34:	81 e0       	ldi	r24, 0x01	; 1
    5e36:	80 93 d5 07 	sts	0x07D5, r24
		xTickCount = ( TickType_t ) 0U;
    5e3a:	10 92 d8 07 	sts	0x07D8, r1
    5e3e:	10 92 d7 07 	sts	0x07D7, r1
		FreeRTOSConfig.h file. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5e42:	0e 94 00 29 	call	0x5200	; 0x5200 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    5e46:	0f 91       	pop	r16
    5e48:	ff 90       	pop	r15
    5e4a:	ef 90       	pop	r14
    5e4c:	08 95       	ret

00005e4e <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    5e4e:	80 91 cf 07 	lds	r24, 0x07CF
    5e52:	8f 5f       	subi	r24, 0xFF	; 255
    5e54:	80 93 cf 07 	sts	0x07CF, r24
    5e58:	08 95       	ret

00005e5a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5e5a:	cf 92       	push	r12
    5e5c:	df 92       	push	r13
    5e5e:	ef 92       	push	r14
    5e60:	ff 92       	push	r15
    5e62:	0f 93       	push	r16
    5e64:	1f 93       	push	r17
    5e66:	cf 93       	push	r28
    5e68:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5e6a:	80 91 cf 07 	lds	r24, 0x07CF
    5e6e:	81 11       	cpse	r24, r1
    5e70:	98 c0       	rjmp	.+304    	; 0x5fa2 <xTaskIncrementTick+0x148>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5e72:	e0 90 d7 07 	lds	r14, 0x07D7
    5e76:	f0 90 d8 07 	lds	r15, 0x07D8
    5e7a:	8f ef       	ldi	r24, 0xFF	; 255
    5e7c:	e8 1a       	sub	r14, r24
    5e7e:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    5e80:	f0 92 d8 07 	sts	0x07D8, r15
    5e84:	e0 92 d7 07 	sts	0x07D7, r14

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    5e88:	e1 14       	cp	r14, r1
    5e8a:	f1 04       	cpc	r15, r1
    5e8c:	b9 f4       	brne	.+46     	; 0x5ebc <xTaskIncrementTick+0x62>
		{
			taskSWITCH_DELAYED_LISTS();
    5e8e:	80 91 dc 07 	lds	r24, 0x07DC
    5e92:	90 91 dd 07 	lds	r25, 0x07DD
    5e96:	20 91 da 07 	lds	r18, 0x07DA
    5e9a:	30 91 db 07 	lds	r19, 0x07DB
    5e9e:	30 93 dd 07 	sts	0x07DD, r19
    5ea2:	20 93 dc 07 	sts	0x07DC, r18
    5ea6:	90 93 db 07 	sts	0x07DB, r25
    5eaa:	80 93 da 07 	sts	0x07DA, r24
    5eae:	80 91 d2 07 	lds	r24, 0x07D2
    5eb2:	8f 5f       	subi	r24, 0xFF	; 255
    5eb4:	80 93 d2 07 	sts	0x07D2, r24
    5eb8:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    5ebc:	80 91 d0 07 	lds	r24, 0x07D0
    5ec0:	90 91 d1 07 	lds	r25, 0x07D1
    5ec4:	e8 16       	cp	r14, r24
    5ec6:	f9 06       	cpc	r15, r25
    5ec8:	20 f4       	brcc	.+8      	; 0x5ed2 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5eca:	d1 2c       	mov	r13, r1
    5ecc:	54 c0       	rjmp	.+168    	; 0x5f76 <xTaskIncrementTick+0x11c>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    5ece:	dc 2c       	mov	r13, r12
    5ed0:	03 c0       	rjmp	.+6      	; 0x5ed8 <xTaskIncrementTick+0x7e>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    5ed2:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    5ed4:	cc 24       	eor	r12, r12
    5ed6:	c3 94       	inc	r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5ed8:	e0 91 dc 07 	lds	r30, 0x07DC
    5edc:	f0 91 dd 07 	lds	r31, 0x07DD
    5ee0:	80 81       	ld	r24, Z
    5ee2:	81 11       	cpse	r24, r1
    5ee4:	07 c0       	rjmp	.+14     	; 0x5ef4 <xTaskIncrementTick+0x9a>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5ee6:	8f ef       	ldi	r24, 0xFF	; 255
    5ee8:	9f ef       	ldi	r25, 0xFF	; 255
    5eea:	90 93 d1 07 	sts	0x07D1, r25
    5eee:	80 93 d0 07 	sts	0x07D0, r24
					break;
    5ef2:	41 c0       	rjmp	.+130    	; 0x5f76 <xTaskIncrementTick+0x11c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    5ef4:	e0 91 dc 07 	lds	r30, 0x07DC
    5ef8:	f0 91 dd 07 	lds	r31, 0x07DD
    5efc:	05 80       	ldd	r0, Z+5	; 0x05
    5efe:	f6 81       	ldd	r31, Z+6	; 0x06
    5f00:	e0 2d       	mov	r30, r0
    5f02:	c6 81       	ldd	r28, Z+6	; 0x06
    5f04:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5f06:	2a 81       	ldd	r18, Y+2	; 0x02
    5f08:	3b 81       	ldd	r19, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    5f0a:	e2 16       	cp	r14, r18
    5f0c:	f3 06       	cpc	r15, r19
    5f0e:	28 f4       	brcc	.+10     	; 0x5f1a <xTaskIncrementTick+0xc0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    5f10:	30 93 d1 07 	sts	0x07D1, r19
    5f14:	20 93 d0 07 	sts	0x07D0, r18
						break;
    5f18:	2e c0       	rjmp	.+92     	; 0x5f76 <xTaskIncrementTick+0x11c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5f1a:	8e 01       	movw	r16, r28
    5f1c:	0e 5f       	subi	r16, 0xFE	; 254
    5f1e:	1f 4f       	sbci	r17, 0xFF	; 255
    5f20:	c8 01       	movw	r24, r16
    5f22:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5f26:	8c 89       	ldd	r24, Y+20	; 0x14
    5f28:	9d 89       	ldd	r25, Y+21	; 0x15
    5f2a:	89 2b       	or	r24, r25
    5f2c:	21 f0       	breq	.+8      	; 0x5f36 <xTaskIncrementTick+0xdc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5f2e:	ce 01       	movw	r24, r28
    5f30:	0c 96       	adiw	r24, 0x0c	; 12
    5f32:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    5f36:	2e 89       	ldd	r18, Y+22	; 0x16
    5f38:	80 91 d6 07 	lds	r24, 0x07D6
    5f3c:	82 17       	cp	r24, r18
    5f3e:	10 f4       	brcc	.+4      	; 0x5f44 <xTaskIncrementTick+0xea>
    5f40:	20 93 d6 07 	sts	0x07D6, r18
    5f44:	30 e0       	ldi	r19, 0x00	; 0
    5f46:	c9 01       	movw	r24, r18
    5f48:	88 0f       	add	r24, r24
    5f4a:	99 1f       	adc	r25, r25
    5f4c:	88 0f       	add	r24, r24
    5f4e:	99 1f       	adc	r25, r25
    5f50:	88 0f       	add	r24, r24
    5f52:	99 1f       	adc	r25, r25
    5f54:	82 0f       	add	r24, r18
    5f56:	93 1f       	adc	r25, r19
    5f58:	b8 01       	movw	r22, r16
    5f5a:	81 52       	subi	r24, 0x21	; 33
    5f5c:	98 4f       	sbci	r25, 0xF8	; 248
    5f5e:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5f62:	e0 91 cd 07 	lds	r30, 0x07CD
    5f66:	f0 91 ce 07 	lds	r31, 0x07CE
    5f6a:	9e 89       	ldd	r25, Y+22	; 0x16
    5f6c:	86 89       	ldd	r24, Z+22	; 0x16
    5f6e:	98 17       	cp	r25, r24
    5f70:	08 f0       	brcs	.+2      	; 0x5f74 <xTaskIncrementTick+0x11a>
    5f72:	ad cf       	rjmp	.-166    	; 0x5ece <xTaskIncrementTick+0x74>
    5f74:	b1 cf       	rjmp	.-158    	; 0x5ed8 <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    5f76:	e0 91 cd 07 	lds	r30, 0x07CD
    5f7a:	f0 91 ce 07 	lds	r31, 0x07CE
    5f7e:	86 89       	ldd	r24, Z+22	; 0x16
    5f80:	90 e0       	ldi	r25, 0x00	; 0
    5f82:	fc 01       	movw	r30, r24
    5f84:	ee 0f       	add	r30, r30
    5f86:	ff 1f       	adc	r31, r31
    5f88:	ee 0f       	add	r30, r30
    5f8a:	ff 1f       	adc	r31, r31
    5f8c:	ee 0f       	add	r30, r30
    5f8e:	ff 1f       	adc	r31, r31
    5f90:	8e 0f       	add	r24, r30
    5f92:	9f 1f       	adc	r25, r31
    5f94:	fc 01       	movw	r30, r24
    5f96:	e1 52       	subi	r30, 0x21	; 33
    5f98:	f8 4f       	sbci	r31, 0xF8	; 248
    5f9a:	80 81       	ld	r24, Z
    5f9c:	82 30       	cpi	r24, 0x02	; 2
    5f9e:	40 f4       	brcc	.+16     	; 0x5fb0 <xTaskIncrementTick+0x156>
    5fa0:	09 c0       	rjmp	.+18     	; 0x5fb4 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    5fa2:	80 91 d4 07 	lds	r24, 0x07D4
    5fa6:	8f 5f       	subi	r24, 0xFF	; 255
    5fa8:	80 93 d4 07 	sts	0x07D4, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5fac:	d1 2c       	mov	r13, r1
    5fae:	02 c0       	rjmp	.+4      	; 0x5fb4 <xTaskIncrementTick+0x15a>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    5fb0:	dd 24       	eor	r13, r13
    5fb2:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    5fb4:	80 91 d3 07 	lds	r24, 0x07D3
    5fb8:	88 23       	and	r24, r24
    5fba:	11 f0       	breq	.+4      	; 0x5fc0 <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
    5fbc:	dd 24       	eor	r13, r13
    5fbe:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    5fc0:	8d 2d       	mov	r24, r13
    5fc2:	df 91       	pop	r29
    5fc4:	cf 91       	pop	r28
    5fc6:	1f 91       	pop	r17
    5fc8:	0f 91       	pop	r16
    5fca:	ff 90       	pop	r15
    5fcc:	ef 90       	pop	r14
    5fce:	df 90       	pop	r13
    5fd0:	cf 90       	pop	r12
    5fd2:	08 95       	ret

00005fd4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    5fd4:	df 92       	push	r13
    5fd6:	ef 92       	push	r14
    5fd8:	ff 92       	push	r15
    5fda:	0f 93       	push	r16
    5fdc:	1f 93       	push	r17
    5fde:	cf 93       	push	r28
    5fe0:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5fe2:	0f b6       	in	r0, 0x3f	; 63
    5fe4:	f8 94       	cli
    5fe6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5fe8:	80 91 cf 07 	lds	r24, 0x07CF
    5fec:	81 50       	subi	r24, 0x01	; 1
    5fee:	80 93 cf 07 	sts	0x07CF, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5ff2:	80 91 cf 07 	lds	r24, 0x07CF
    5ff6:	81 11       	cpse	r24, r1
    5ff8:	5e c0       	rjmp	.+188    	; 0x60b6 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    5ffa:	80 91 d9 07 	lds	r24, 0x07D9
    5ffe:	81 11       	cpse	r24, r1
    6000:	32 c0       	rjmp	.+100    	; 0x6066 <xTaskResumeAll+0x92>
    6002:	5c c0       	rjmp	.+184    	; 0x60bc <xTaskResumeAll+0xe8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    6004:	e0 91 23 08 	lds	r30, 0x0823
    6008:	f0 91 24 08 	lds	r31, 0x0824
    600c:	c6 81       	ldd	r28, Z+6	; 0x06
    600e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    6010:	ce 01       	movw	r24, r28
    6012:	0c 96       	adiw	r24, 0x0c	; 12
    6014:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6018:	8e 01       	movw	r16, r28
    601a:	0e 5f       	subi	r16, 0xFE	; 254
    601c:	1f 4f       	sbci	r17, 0xFF	; 255
    601e:	c8 01       	movw	r24, r16
    6020:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6024:	8e 89       	ldd	r24, Y+22	; 0x16
    6026:	90 91 d6 07 	lds	r25, 0x07D6
    602a:	98 17       	cp	r25, r24
    602c:	10 f4       	brcc	.+4      	; 0x6032 <xTaskResumeAll+0x5e>
    602e:	80 93 d6 07 	sts	0x07D6, r24
    6032:	90 e0       	ldi	r25, 0x00	; 0
    6034:	9c 01       	movw	r18, r24
    6036:	22 0f       	add	r18, r18
    6038:	33 1f       	adc	r19, r19
    603a:	22 0f       	add	r18, r18
    603c:	33 1f       	adc	r19, r19
    603e:	22 0f       	add	r18, r18
    6040:	33 1f       	adc	r19, r19
    6042:	82 0f       	add	r24, r18
    6044:	93 1f       	adc	r25, r19
    6046:	b8 01       	movw	r22, r16
    6048:	81 52       	subi	r24, 0x21	; 33
    604a:	98 4f       	sbci	r25, 0xF8	; 248
    604c:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6050:	e0 91 cd 07 	lds	r30, 0x07CD
    6054:	f0 91 ce 07 	lds	r31, 0x07CE
    6058:	9e 89       	ldd	r25, Y+22	; 0x16
    605a:	86 89       	ldd	r24, Z+22	; 0x16
    605c:	98 17       	cp	r25, r24
    605e:	68 f0       	brcs	.+26     	; 0x607a <xTaskResumeAll+0xa6>
					{
						xYieldPending = pdTRUE;
    6060:	d0 92 d3 07 	sts	0x07D3, r13
    6064:	0a c0       	rjmp	.+20     	; 0x607a <xTaskResumeAll+0xa6>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    6066:	c0 e0       	ldi	r28, 0x00	; 0
    6068:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    606a:	0f 2e       	mov	r0, r31
    606c:	fe e1       	ldi	r31, 0x1E	; 30
    606e:	ef 2e       	mov	r14, r31
    6070:	f8 e0       	ldi	r31, 0x08	; 8
    6072:	ff 2e       	mov	r15, r31
    6074:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    6076:	dd 24       	eor	r13, r13
    6078:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    607a:	f7 01       	movw	r30, r14
    607c:	80 81       	ld	r24, Z
    607e:	81 11       	cpse	r24, r1
    6080:	c1 cf       	rjmp	.-126    	; 0x6004 <xTaskResumeAll+0x30>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    6082:	cd 2b       	or	r28, r29
    6084:	11 f0       	breq	.+4      	; 0x608a <xTaskResumeAll+0xb6>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    6086:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    608a:	c0 91 d4 07 	lds	r28, 0x07D4

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    608e:	cc 23       	and	r28, r28
    6090:	51 f0       	breq	.+20     	; 0x60a6 <xTaskResumeAll+0xd2>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    6092:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    6094:	0e 94 2d 2f 	call	0x5e5a	; 0x5e5a <xTaskIncrementTick>
    6098:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
    609a:	d0 93 d3 07 	sts	0x07D3, r29
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    609e:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    60a0:	c9 f7       	brne	.-14     	; 0x6094 <xTaskResumeAll+0xc0>

						uxPendedTicks = 0;
    60a2:	10 92 d4 07 	sts	0x07D4, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    60a6:	80 91 d3 07 	lds	r24, 0x07D3
    60aa:	88 23       	and	r24, r24
    60ac:	31 f0       	breq	.+12     	; 0x60ba <xTaskResumeAll+0xe6>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    60ae:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    60b2:	81 e0       	ldi	r24, 0x01	; 1
    60b4:	03 c0       	rjmp	.+6      	; 0x60bc <xTaskResumeAll+0xe8>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    60b6:	80 e0       	ldi	r24, 0x00	; 0
    60b8:	01 c0       	rjmp	.+2      	; 0x60bc <xTaskResumeAll+0xe8>
    60ba:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    60bc:	0f 90       	pop	r0
    60be:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    60c0:	df 91       	pop	r29
    60c2:	cf 91       	pop	r28
    60c4:	1f 91       	pop	r17
    60c6:	0f 91       	pop	r16
    60c8:	ff 90       	pop	r15
    60ca:	ef 90       	pop	r14
    60cc:	df 90       	pop	r13
    60ce:	08 95       	ret

000060d0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    60d0:	cf 93       	push	r28
    60d2:	df 93       	push	r29
    60d4:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    60d6:	00 97       	sbiw	r24, 0x00	; 0
    60d8:	51 f0       	breq	.+20     	; 0x60ee <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    60da:	0e 94 27 2f 	call	0x5e4e	; 0x5e4e <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    60de:	60 e0       	ldi	r22, 0x00	; 0
    60e0:	ce 01       	movw	r24, r28
    60e2:	0e 94 ae 2d 	call	0x5b5c	; 0x5b5c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    60e6:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    60ea:	81 11       	cpse	r24, r1
    60ec:	02 c0       	rjmp	.+4      	; 0x60f2 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    60ee:	0e 94 35 29 	call	0x526a	; 0x526a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    60f2:	df 91       	pop	r29
    60f4:	cf 91       	pop	r28
    60f6:	08 95       	ret

000060f8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    60f8:	80 91 cf 07 	lds	r24, 0x07CF
    60fc:	88 23       	and	r24, r24
    60fe:	21 f0       	breq	.+8      	; 0x6108 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    6100:	81 e0       	ldi	r24, 0x01	; 1
    6102:	80 93 d3 07 	sts	0x07D3, r24
    6106:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    6108:	10 92 d3 07 	sts	0x07D3, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    610c:	20 91 d6 07 	lds	r18, 0x07D6
    6110:	82 2f       	mov	r24, r18
    6112:	90 e0       	ldi	r25, 0x00	; 0
    6114:	fc 01       	movw	r30, r24
    6116:	ee 0f       	add	r30, r30
    6118:	ff 1f       	adc	r31, r31
    611a:	ee 0f       	add	r30, r30
    611c:	ff 1f       	adc	r31, r31
    611e:	ee 0f       	add	r30, r30
    6120:	ff 1f       	adc	r31, r31
    6122:	e8 0f       	add	r30, r24
    6124:	f9 1f       	adc	r31, r25
    6126:	e1 52       	subi	r30, 0x21	; 33
    6128:	f8 4f       	sbci	r31, 0xF8	; 248
    612a:	30 81       	ld	r19, Z
    612c:	31 11       	cpse	r19, r1
    612e:	11 c0       	rjmp	.+34     	; 0x6152 <vTaskSwitchContext+0x5a>
    6130:	21 50       	subi	r18, 0x01	; 1
    6132:	82 2f       	mov	r24, r18
    6134:	90 e0       	ldi	r25, 0x00	; 0
    6136:	fc 01       	movw	r30, r24
    6138:	ee 0f       	add	r30, r30
    613a:	ff 1f       	adc	r31, r31
    613c:	ee 0f       	add	r30, r30
    613e:	ff 1f       	adc	r31, r31
    6140:	ee 0f       	add	r30, r30
    6142:	ff 1f       	adc	r31, r31
    6144:	e8 0f       	add	r30, r24
    6146:	f9 1f       	adc	r31, r25
    6148:	e1 52       	subi	r30, 0x21	; 33
    614a:	f8 4f       	sbci	r31, 0xF8	; 248
    614c:	30 81       	ld	r19, Z
    614e:	33 23       	and	r19, r19
    6150:	79 f3       	breq	.-34     	; 0x6130 <vTaskSwitchContext+0x38>
    6152:	fc 01       	movw	r30, r24
    6154:	ee 0f       	add	r30, r30
    6156:	ff 1f       	adc	r31, r31
    6158:	ee 0f       	add	r30, r30
    615a:	ff 1f       	adc	r31, r31
    615c:	ee 0f       	add	r30, r30
    615e:	ff 1f       	adc	r31, r31
    6160:	8e 0f       	add	r24, r30
    6162:	9f 1f       	adc	r25, r31
    6164:	fc 01       	movw	r30, r24
    6166:	e1 52       	subi	r30, 0x21	; 33
    6168:	f8 4f       	sbci	r31, 0xF8	; 248
    616a:	a1 81       	ldd	r26, Z+1	; 0x01
    616c:	b2 81       	ldd	r27, Z+2	; 0x02
    616e:	12 96       	adiw	r26, 0x02	; 2
    6170:	0d 90       	ld	r0, X+
    6172:	bc 91       	ld	r27, X
    6174:	a0 2d       	mov	r26, r0
    6176:	b2 83       	std	Z+2, r27	; 0x02
    6178:	a1 83       	std	Z+1, r26	; 0x01
    617a:	cf 01       	movw	r24, r30
    617c:	03 96       	adiw	r24, 0x03	; 3
    617e:	a8 17       	cp	r26, r24
    6180:	b9 07       	cpc	r27, r25
    6182:	31 f4       	brne	.+12     	; 0x6190 <vTaskSwitchContext+0x98>
    6184:	12 96       	adiw	r26, 0x02	; 2
    6186:	8d 91       	ld	r24, X+
    6188:	9c 91       	ld	r25, X
    618a:	13 97       	sbiw	r26, 0x03	; 3
    618c:	92 83       	std	Z+2, r25	; 0x02
    618e:	81 83       	std	Z+1, r24	; 0x01
    6190:	01 80       	ldd	r0, Z+1	; 0x01
    6192:	f2 81       	ldd	r31, Z+2	; 0x02
    6194:	e0 2d       	mov	r30, r0
    6196:	86 81       	ldd	r24, Z+6	; 0x06
    6198:	97 81       	ldd	r25, Z+7	; 0x07
    619a:	90 93 ce 07 	sts	0x07CE, r25
    619e:	80 93 cd 07 	sts	0x07CD, r24
    61a2:	20 93 d6 07 	sts	0x07D6, r18
    61a6:	08 95       	ret

000061a8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    61a8:	cf 93       	push	r28
    61aa:	df 93       	push	r29
    61ac:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    61ae:	60 91 cd 07 	lds	r22, 0x07CD
    61b2:	70 91 ce 07 	lds	r23, 0x07CE
    61b6:	64 5f       	subi	r22, 0xF4	; 244
    61b8:	7f 4f       	sbci	r23, 0xFF	; 255
    61ba:	0e 94 14 28 	call	0x5028	; 0x5028 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    61be:	61 e0       	ldi	r22, 0x01	; 1
    61c0:	ce 01       	movw	r24, r28
    61c2:	0e 94 ae 2d 	call	0x5b5c	; 0x5b5c <prvAddCurrentTaskToDelayedList>
}
    61c6:	df 91       	pop	r29
    61c8:	cf 91       	pop	r28
    61ca:	08 95       	ret

000061cc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    61cc:	0f 93       	push	r16
    61ce:	1f 93       	push	r17
    61d0:	cf 93       	push	r28
    61d2:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    61d4:	dc 01       	movw	r26, r24
    61d6:	15 96       	adiw	r26, 0x05	; 5
    61d8:	ed 91       	ld	r30, X+
    61da:	fc 91       	ld	r31, X
    61dc:	16 97       	sbiw	r26, 0x06	; 6
    61de:	c6 81       	ldd	r28, Z+6	; 0x06
    61e0:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    61e2:	8e 01       	movw	r16, r28
    61e4:	04 5f       	subi	r16, 0xF4	; 244
    61e6:	1f 4f       	sbci	r17, 0xFF	; 255
    61e8:	c8 01       	movw	r24, r16
    61ea:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    61ee:	80 91 cf 07 	lds	r24, 0x07CF
    61f2:	81 11       	cpse	r24, r1
    61f4:	1d c0       	rjmp	.+58     	; 0x6230 <xTaskRemoveFromEventList+0x64>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    61f6:	8e 01       	movw	r16, r28
    61f8:	0e 5f       	subi	r16, 0xFE	; 254
    61fa:	1f 4f       	sbci	r17, 0xFF	; 255
    61fc:	c8 01       	movw	r24, r16
    61fe:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    6202:	8e 89       	ldd	r24, Y+22	; 0x16
    6204:	90 91 d6 07 	lds	r25, 0x07D6
    6208:	98 17       	cp	r25, r24
    620a:	10 f4       	brcc	.+4      	; 0x6210 <xTaskRemoveFromEventList+0x44>
    620c:	80 93 d6 07 	sts	0x07D6, r24
    6210:	90 e0       	ldi	r25, 0x00	; 0
    6212:	9c 01       	movw	r18, r24
    6214:	22 0f       	add	r18, r18
    6216:	33 1f       	adc	r19, r19
    6218:	22 0f       	add	r18, r18
    621a:	33 1f       	adc	r19, r19
    621c:	22 0f       	add	r18, r18
    621e:	33 1f       	adc	r19, r19
    6220:	82 0f       	add	r24, r18
    6222:	93 1f       	adc	r25, r19
    6224:	b8 01       	movw	r22, r16
    6226:	81 52       	subi	r24, 0x21	; 33
    6228:	98 4f       	sbci	r25, 0xF8	; 248
    622a:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>
    622e:	05 c0       	rjmp	.+10     	; 0x623a <xTaskRemoveFromEventList+0x6e>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    6230:	b8 01       	movw	r22, r16
    6232:	8e e1       	ldi	r24, 0x1E	; 30
    6234:	98 e0       	ldi	r25, 0x08	; 8
    6236:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    623a:	e0 91 cd 07 	lds	r30, 0x07CD
    623e:	f0 91 ce 07 	lds	r31, 0x07CE
    6242:	9e 89       	ldd	r25, Y+22	; 0x16
    6244:	86 89       	ldd	r24, Z+22	; 0x16
    6246:	89 17       	cp	r24, r25
    6248:	20 f4       	brcc	.+8      	; 0x6252 <xTaskRemoveFromEventList+0x86>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    624a:	81 e0       	ldi	r24, 0x01	; 1
    624c:	80 93 d3 07 	sts	0x07D3, r24
    6250:	01 c0       	rjmp	.+2      	; 0x6254 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		xReturn = pdFALSE;
    6252:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    6254:	df 91       	pop	r29
    6256:	cf 91       	pop	r28
    6258:	1f 91       	pop	r17
    625a:	0f 91       	pop	r16
    625c:	08 95       	ret

0000625e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    625e:	20 91 d2 07 	lds	r18, 0x07D2
    6262:	fc 01       	movw	r30, r24
    6264:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    6266:	20 91 d7 07 	lds	r18, 0x07D7
    626a:	30 91 d8 07 	lds	r19, 0x07D8
    626e:	32 83       	std	Z+2, r19	; 0x02
    6270:	21 83       	std	Z+1, r18	; 0x01
    6272:	08 95       	ret

00006274 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    6274:	0f b6       	in	r0, 0x3f	; 63
    6276:	f8 94       	cli
    6278:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    627a:	40 91 d7 07 	lds	r20, 0x07D7
    627e:	50 91 d8 07 	lds	r21, 0x07D8
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    6282:	dc 01       	movw	r26, r24
    6284:	11 96       	adiw	r26, 0x01	; 1
    6286:	2d 91       	ld	r18, X+
    6288:	3c 91       	ld	r19, X
    628a:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    628c:	e0 91 d2 07 	lds	r30, 0x07D2
    6290:	fc 91       	ld	r31, X
    6292:	fe 17       	cp	r31, r30
    6294:	19 f0       	breq	.+6      	; 0x629c <xTaskCheckForTimeOut+0x28>
    6296:	42 17       	cp	r20, r18
    6298:	53 07       	cpc	r21, r19
    629a:	a0 f4       	brcc	.+40     	; 0x62c4 <xTaskCheckForTimeOut+0x50>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    629c:	42 1b       	sub	r20, r18
    629e:	53 0b       	sbc	r21, r19
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    62a0:	fb 01       	movw	r30, r22
    62a2:	20 81       	ld	r18, Z
    62a4:	31 81       	ldd	r19, Z+1	; 0x01
    62a6:	42 17       	cp	r20, r18
    62a8:	53 07       	cpc	r21, r19
    62aa:	40 f4       	brcc	.+16     	; 0x62bc <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    62ac:	24 1b       	sub	r18, r20
    62ae:	35 0b       	sbc	r19, r21
    62b0:	31 83       	std	Z+1, r19	; 0x01
    62b2:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    62b4:	0e 94 2f 31 	call	0x625e	; 0x625e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    62b8:	80 e0       	ldi	r24, 0x00	; 0
    62ba:	05 c0       	rjmp	.+10     	; 0x62c6 <xTaskCheckForTimeOut+0x52>
		}
		else
		{
			*pxTicksToWait = 0;
    62bc:	11 82       	std	Z+1, r1	; 0x01
    62be:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    62c0:	81 e0       	ldi	r24, 0x01	; 1
    62c2:	01 c0       	rjmp	.+2      	; 0x62c6 <xTaskCheckForTimeOut+0x52>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    62c4:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    62c6:	0f 90       	pop	r0
    62c8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    62ca:	08 95       	ret

000062cc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    62cc:	81 e0       	ldi	r24, 0x01	; 1
    62ce:	80 93 d3 07 	sts	0x07D3, r24
    62d2:	08 95       	ret

000062d4 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    62d4:	0f 93       	push	r16
    62d6:	1f 93       	push	r17
    62d8:	cf 93       	push	r28
    62da:	df 93       	push	r29
    62dc:	ec 01       	movw	r28, r24
	BaseType_t xReturn = pdFALSE;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    62de:	00 97       	sbiw	r24, 0x00	; 0
    62e0:	09 f4       	brne	.+2      	; 0x62e4 <xTaskPriorityInherit+0x10>
    62e2:	5f c0       	rjmp	.+190    	; 0x63a2 <xTaskPriorityInherit+0xce>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    62e4:	8e 89       	ldd	r24, Y+22	; 0x16
    62e6:	e0 91 cd 07 	lds	r30, 0x07CD
    62ea:	f0 91 ce 07 	lds	r31, 0x07CE
    62ee:	96 89       	ldd	r25, Z+22	; 0x16
    62f0:	89 17       	cp	r24, r25
    62f2:	08 f0       	brcs	.+2      	; 0x62f6 <xTaskPriorityInherit+0x22>
    62f4:	4b c0       	rjmp	.+150    	; 0x638c <xTaskPriorityInherit+0xb8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    62f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    62f8:	3d 85       	ldd	r19, Y+13	; 0x0d
    62fa:	33 23       	and	r19, r19
    62fc:	5c f0       	brlt	.+22     	; 0x6314 <xTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    62fe:	e0 91 cd 07 	lds	r30, 0x07CD
    6302:	f0 91 ce 07 	lds	r31, 0x07CE
    6306:	96 89       	ldd	r25, Z+22	; 0x16
    6308:	25 e0       	ldi	r18, 0x05	; 5
    630a:	30 e0       	ldi	r19, 0x00	; 0
    630c:	29 1b       	sub	r18, r25
    630e:	31 09       	sbc	r19, r1
    6310:	3d 87       	std	Y+13, r19	; 0x0d
    6312:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    6314:	90 e0       	ldi	r25, 0x00	; 0
    6316:	9c 01       	movw	r18, r24
    6318:	22 0f       	add	r18, r18
    631a:	33 1f       	adc	r19, r19
    631c:	22 0f       	add	r18, r18
    631e:	33 1f       	adc	r19, r19
    6320:	22 0f       	add	r18, r18
    6322:	33 1f       	adc	r19, r19
    6324:	82 0f       	add	r24, r18
    6326:	93 1f       	adc	r25, r19
    6328:	81 52       	subi	r24, 0x21	; 33
    632a:	98 4f       	sbci	r25, 0xF8	; 248
    632c:	2a 85       	ldd	r18, Y+10	; 0x0a
    632e:	3b 85       	ldd	r19, Y+11	; 0x0b
    6330:	28 17       	cp	r18, r24
    6332:	39 07       	cpc	r19, r25
    6334:	19 f5       	brne	.+70     	; 0x637c <xTaskPriorityInherit+0xa8>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6336:	8e 01       	movw	r16, r28
    6338:	0e 5f       	subi	r16, 0xFE	; 254
    633a:	1f 4f       	sbci	r17, 0xFF	; 255
    633c:	c8 01       	movw	r24, r16
    633e:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    6342:	e0 91 cd 07 	lds	r30, 0x07CD
    6346:	f0 91 ce 07 	lds	r31, 0x07CE
    634a:	86 89       	ldd	r24, Z+22	; 0x16
    634c:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    634e:	90 91 d6 07 	lds	r25, 0x07D6
    6352:	98 17       	cp	r25, r24
    6354:	10 f4       	brcc	.+4      	; 0x635a <xTaskPriorityInherit+0x86>
    6356:	80 93 d6 07 	sts	0x07D6, r24
    635a:	90 e0       	ldi	r25, 0x00	; 0
    635c:	9c 01       	movw	r18, r24
    635e:	22 0f       	add	r18, r18
    6360:	33 1f       	adc	r19, r19
    6362:	22 0f       	add	r18, r18
    6364:	33 1f       	adc	r19, r19
    6366:	22 0f       	add	r18, r18
    6368:	33 1f       	adc	r19, r19
    636a:	82 0f       	add	r24, r18
    636c:	93 1f       	adc	r25, r19
    636e:	b8 01       	movw	r22, r16
    6370:	81 52       	subi	r24, 0x21	; 33
    6372:	98 4f       	sbci	r25, 0xF8	; 248
    6374:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    6378:	81 e0       	ldi	r24, 0x01	; 1
    637a:	14 c0       	rjmp	.+40     	; 0x63a4 <xTaskPriorityInherit+0xd0>
					prvAddTaskToReadyList( pxMutexHolderTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    637c:	e0 91 cd 07 	lds	r30, 0x07CD
    6380:	f0 91 ce 07 	lds	r31, 0x07CE
    6384:	86 89       	ldd	r24, Z+22	; 0x16
    6386:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    6388:	81 e0       	ldi	r24, 0x01	; 1
    638a:	0c c0       	rjmp	.+24     	; 0x63a4 <xTaskPriorityInherit+0xd0>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    638c:	e0 91 cd 07 	lds	r30, 0x07CD
    6390:	f0 91 ce 07 	lds	r31, 0x07CE
    6394:	81 e0       	ldi	r24, 0x01	; 1
    6396:	2b a1       	ldd	r18, Y+35	; 0x23
    6398:	96 89       	ldd	r25, Z+22	; 0x16
    639a:	29 17       	cp	r18, r25
    639c:	18 f0       	brcs	.+6      	; 0x63a4 <xTaskPriorityInherit+0xd0>
    639e:	80 e0       	ldi	r24, 0x00	; 0
    63a0:	01 c0       	rjmp	.+2      	; 0x63a4 <xTaskPriorityInherit+0xd0>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    63a2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    63a4:	df 91       	pop	r29
    63a6:	cf 91       	pop	r28
    63a8:	1f 91       	pop	r17
    63aa:	0f 91       	pop	r16
    63ac:	08 95       	ret

000063ae <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    63ae:	0f 93       	push	r16
    63b0:	1f 93       	push	r17
    63b2:	cf 93       	push	r28
    63b4:	df 93       	push	r29
    63b6:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    63b8:	00 97       	sbiw	r24, 0x00	; 0
    63ba:	71 f1       	breq	.+92     	; 0x6418 <xTaskPriorityDisinherit+0x6a>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    63bc:	8c a1       	ldd	r24, Y+36	; 0x24
    63be:	81 50       	subi	r24, 0x01	; 1
    63c0:	8c a3       	std	Y+36, r24	; 0x24

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    63c2:	2e 89       	ldd	r18, Y+22	; 0x16
    63c4:	9b a1       	ldd	r25, Y+35	; 0x23
    63c6:	29 17       	cp	r18, r25
    63c8:	49 f1       	breq	.+82     	; 0x641c <xTaskPriorityDisinherit+0x6e>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    63ca:	81 11       	cpse	r24, r1
    63cc:	29 c0       	rjmp	.+82     	; 0x6420 <xTaskPriorityDisinherit+0x72>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    63ce:	8e 01       	movw	r16, r28
    63d0:	0e 5f       	subi	r16, 0xFE	; 254
    63d2:	1f 4f       	sbci	r17, 0xFF	; 255
    63d4:	c8 01       	movw	r24, r16
    63d6:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    63da:	8b a1       	ldd	r24, Y+35	; 0x23
    63dc:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    63de:	25 e0       	ldi	r18, 0x05	; 5
    63e0:	30 e0       	ldi	r19, 0x00	; 0
    63e2:	28 1b       	sub	r18, r24
    63e4:	31 09       	sbc	r19, r1
    63e6:	3d 87       	std	Y+13, r19	; 0x0d
    63e8:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    63ea:	90 91 d6 07 	lds	r25, 0x07D6
    63ee:	98 17       	cp	r25, r24
    63f0:	10 f4       	brcc	.+4      	; 0x63f6 <xTaskPriorityDisinherit+0x48>
    63f2:	80 93 d6 07 	sts	0x07D6, r24
    63f6:	90 e0       	ldi	r25, 0x00	; 0
    63f8:	9c 01       	movw	r18, r24
    63fa:	22 0f       	add	r18, r18
    63fc:	33 1f       	adc	r19, r19
    63fe:	22 0f       	add	r18, r18
    6400:	33 1f       	adc	r19, r19
    6402:	22 0f       	add	r18, r18
    6404:	33 1f       	adc	r19, r19
    6406:	82 0f       	add	r24, r18
    6408:	93 1f       	adc	r25, r19
    640a:	b8 01       	movw	r22, r16
    640c:	81 52       	subi	r24, 0x21	; 33
    640e:	98 4f       	sbci	r25, 0xF8	; 248
    6410:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    6414:	81 e0       	ldi	r24, 0x01	; 1
    6416:	05 c0       	rjmp	.+10     	; 0x6422 <xTaskPriorityDisinherit+0x74>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    6418:	80 e0       	ldi	r24, 0x00	; 0
    641a:	03 c0       	rjmp	.+6      	; 0x6422 <xTaskPriorityDisinherit+0x74>
    641c:	80 e0       	ldi	r24, 0x00	; 0
    641e:	01 c0       	rjmp	.+2      	; 0x6422 <xTaskPriorityDisinherit+0x74>
    6420:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    6422:	df 91       	pop	r29
    6424:	cf 91       	pop	r28
    6426:	1f 91       	pop	r17
    6428:	0f 91       	pop	r16
    642a:	08 95       	ret

0000642c <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    642c:	0f 93       	push	r16
    642e:	1f 93       	push	r17
    6430:	cf 93       	push	r28
    6432:	df 93       	push	r29
    6434:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;

		if( pxMutexHolder != NULL )
    6436:	00 97       	sbiw	r24, 0x00	; 0
    6438:	09 f4       	brne	.+2      	; 0x643c <vTaskPriorityDisinheritAfterTimeout+0x10>
    643a:	42 c0       	rjmp	.+132    	; 0x64c0 <vTaskPriorityDisinheritAfterTimeout+0x94>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    643c:	8b a1       	ldd	r24, Y+35	; 0x23
    643e:	68 17       	cp	r22, r24
    6440:	08 f4       	brcc	.+2      	; 0x6444 <vTaskPriorityDisinheritAfterTimeout+0x18>
    6442:	68 2f       	mov	r22, r24
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    6444:	8e 89       	ldd	r24, Y+22	; 0x16
    6446:	86 17       	cp	r24, r22
    6448:	d9 f1       	breq	.+118    	; 0x64c0 <vTaskPriorityDisinheritAfterTimeout+0x94>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    644a:	9c a1       	ldd	r25, Y+36	; 0x24
    644c:	91 30       	cpi	r25, 0x01	; 1
    644e:	c1 f5       	brne	.+112    	; 0x64c0 <vTaskPriorityDisinheritAfterTimeout+0x94>
					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
					pxTCB->uxPriority = uxPriorityToUse;
    6450:	6e 8b       	std	Y+22, r22	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    6452:	2c 85       	ldd	r18, Y+12	; 0x0c
    6454:	3d 85       	ldd	r19, Y+13	; 0x0d
    6456:	33 23       	and	r19, r19
    6458:	34 f0       	brlt	.+12     	; 0x6466 <vTaskPriorityDisinheritAfterTimeout+0x3a>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    645a:	25 e0       	ldi	r18, 0x05	; 5
    645c:	30 e0       	ldi	r19, 0x00	; 0
    645e:	26 1b       	sub	r18, r22
    6460:	31 09       	sbc	r19, r1
    6462:	3d 87       	std	Y+13, r19	; 0x0d
    6464:	2c 87       	std	Y+12, r18	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    6466:	90 e0       	ldi	r25, 0x00	; 0
    6468:	9c 01       	movw	r18, r24
    646a:	22 0f       	add	r18, r18
    646c:	33 1f       	adc	r19, r19
    646e:	22 0f       	add	r18, r18
    6470:	33 1f       	adc	r19, r19
    6472:	22 0f       	add	r18, r18
    6474:	33 1f       	adc	r19, r19
    6476:	82 0f       	add	r24, r18
    6478:	93 1f       	adc	r25, r19
    647a:	81 52       	subi	r24, 0x21	; 33
    647c:	98 4f       	sbci	r25, 0xF8	; 248
    647e:	2a 85       	ldd	r18, Y+10	; 0x0a
    6480:	3b 85       	ldd	r19, Y+11	; 0x0b
    6482:	28 17       	cp	r18, r24
    6484:	39 07       	cpc	r19, r25
    6486:	e1 f4       	brne	.+56     	; 0x64c0 <vTaskPriorityDisinheritAfterTimeout+0x94>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    6488:	8e 01       	movw	r16, r28
    648a:	0e 5f       	subi	r16, 0xFE	; 254
    648c:	1f 4f       	sbci	r17, 0xFF	; 255
    648e:	c8 01       	movw	r24, r16
    6490:	0e 94 45 28 	call	0x508a	; 0x508a <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    6494:	8e 89       	ldd	r24, Y+22	; 0x16
    6496:	90 91 d6 07 	lds	r25, 0x07D6
    649a:	98 17       	cp	r25, r24
    649c:	10 f4       	brcc	.+4      	; 0x64a2 <vTaskPriorityDisinheritAfterTimeout+0x76>
    649e:	80 93 d6 07 	sts	0x07D6, r24
    64a2:	90 e0       	ldi	r25, 0x00	; 0
    64a4:	9c 01       	movw	r18, r24
    64a6:	22 0f       	add	r18, r18
    64a8:	33 1f       	adc	r19, r19
    64aa:	22 0f       	add	r18, r18
    64ac:	33 1f       	adc	r19, r19
    64ae:	22 0f       	add	r18, r18
    64b0:	33 1f       	adc	r19, r19
    64b2:	82 0f       	add	r24, r18
    64b4:	93 1f       	adc	r25, r19
    64b6:	b8 01       	movw	r22, r16
    64b8:	81 52       	subi	r24, 0x21	; 33
    64ba:	98 4f       	sbci	r25, 0xF8	; 248
    64bc:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    64c0:	df 91       	pop	r29
    64c2:	cf 91       	pop	r28
    64c4:	1f 91       	pop	r17
    64c6:	0f 91       	pop	r16
    64c8:	08 95       	ret

000064ca <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    64ca:	80 91 cd 07 	lds	r24, 0x07CD
    64ce:	90 91 ce 07 	lds	r25, 0x07CE
    64d2:	89 2b       	or	r24, r25
    64d4:	39 f0       	breq	.+14     	; 0x64e4 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    64d6:	e0 91 cd 07 	lds	r30, 0x07CD
    64da:	f0 91 ce 07 	lds	r31, 0x07CE
    64de:	84 a1       	ldd	r24, Z+36	; 0x24
    64e0:	8f 5f       	subi	r24, 0xFF	; 255
    64e2:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    64e4:	20 91 cd 07 	lds	r18, 0x07CD
    64e8:	30 91 ce 07 	lds	r19, 0x07CE
	}
    64ec:	82 2f       	mov	r24, r18
    64ee:	93 2f       	mov	r25, r19
    64f0:	08 95       	ret

000064f2 <__subsf3>:
    64f2:	50 58       	subi	r21, 0x80	; 128

000064f4 <__addsf3>:
    64f4:	bb 27       	eor	r27, r27
    64f6:	aa 27       	eor	r26, r26
    64f8:	0e d0       	rcall	.+28     	; 0x6516 <__addsf3x>
    64fa:	48 c1       	rjmp	.+656    	; 0x678c <__fp_round>
    64fc:	39 d1       	rcall	.+626    	; 0x6770 <__fp_pscA>
    64fe:	30 f0       	brcs	.+12     	; 0x650c <__addsf3+0x18>
    6500:	3e d1       	rcall	.+636    	; 0x677e <__fp_pscB>
    6502:	20 f0       	brcs	.+8      	; 0x650c <__addsf3+0x18>
    6504:	31 f4       	brne	.+12     	; 0x6512 <__addsf3+0x1e>
    6506:	9f 3f       	cpi	r25, 0xFF	; 255
    6508:	11 f4       	brne	.+4      	; 0x650e <__addsf3+0x1a>
    650a:	1e f4       	brtc	.+6      	; 0x6512 <__addsf3+0x1e>
    650c:	2e c1       	rjmp	.+604    	; 0x676a <__fp_nan>
    650e:	0e f4       	brtc	.+2      	; 0x6512 <__addsf3+0x1e>
    6510:	e0 95       	com	r30
    6512:	e7 fb       	bst	r30, 7
    6514:	24 c1       	rjmp	.+584    	; 0x675e <__fp_inf>

00006516 <__addsf3x>:
    6516:	e9 2f       	mov	r30, r25
    6518:	4a d1       	rcall	.+660    	; 0x67ae <__fp_split3>
    651a:	80 f3       	brcs	.-32     	; 0x64fc <__addsf3+0x8>
    651c:	ba 17       	cp	r27, r26
    651e:	62 07       	cpc	r22, r18
    6520:	73 07       	cpc	r23, r19
    6522:	84 07       	cpc	r24, r20
    6524:	95 07       	cpc	r25, r21
    6526:	18 f0       	brcs	.+6      	; 0x652e <__addsf3x+0x18>
    6528:	71 f4       	brne	.+28     	; 0x6546 <__addsf3x+0x30>
    652a:	9e f5       	brtc	.+102    	; 0x6592 <__addsf3x+0x7c>
    652c:	62 c1       	rjmp	.+708    	; 0x67f2 <__fp_zero>
    652e:	0e f4       	brtc	.+2      	; 0x6532 <__addsf3x+0x1c>
    6530:	e0 95       	com	r30
    6532:	0b 2e       	mov	r0, r27
    6534:	ba 2f       	mov	r27, r26
    6536:	a0 2d       	mov	r26, r0
    6538:	0b 01       	movw	r0, r22
    653a:	b9 01       	movw	r22, r18
    653c:	90 01       	movw	r18, r0
    653e:	0c 01       	movw	r0, r24
    6540:	ca 01       	movw	r24, r20
    6542:	a0 01       	movw	r20, r0
    6544:	11 24       	eor	r1, r1
    6546:	ff 27       	eor	r31, r31
    6548:	59 1b       	sub	r21, r25
    654a:	99 f0       	breq	.+38     	; 0x6572 <__addsf3x+0x5c>
    654c:	59 3f       	cpi	r21, 0xF9	; 249
    654e:	50 f4       	brcc	.+20     	; 0x6564 <__addsf3x+0x4e>
    6550:	50 3e       	cpi	r21, 0xE0	; 224
    6552:	68 f1       	brcs	.+90     	; 0x65ae <__addsf3x+0x98>
    6554:	1a 16       	cp	r1, r26
    6556:	f0 40       	sbci	r31, 0x00	; 0
    6558:	a2 2f       	mov	r26, r18
    655a:	23 2f       	mov	r18, r19
    655c:	34 2f       	mov	r19, r20
    655e:	44 27       	eor	r20, r20
    6560:	58 5f       	subi	r21, 0xF8	; 248
    6562:	f3 cf       	rjmp	.-26     	; 0x654a <__addsf3x+0x34>
    6564:	46 95       	lsr	r20
    6566:	37 95       	ror	r19
    6568:	27 95       	ror	r18
    656a:	a7 95       	ror	r26
    656c:	f0 40       	sbci	r31, 0x00	; 0
    656e:	53 95       	inc	r21
    6570:	c9 f7       	brne	.-14     	; 0x6564 <__addsf3x+0x4e>
    6572:	7e f4       	brtc	.+30     	; 0x6592 <__addsf3x+0x7c>
    6574:	1f 16       	cp	r1, r31
    6576:	ba 0b       	sbc	r27, r26
    6578:	62 0b       	sbc	r22, r18
    657a:	73 0b       	sbc	r23, r19
    657c:	84 0b       	sbc	r24, r20
    657e:	ba f0       	brmi	.+46     	; 0x65ae <__addsf3x+0x98>
    6580:	91 50       	subi	r25, 0x01	; 1
    6582:	a1 f0       	breq	.+40     	; 0x65ac <__addsf3x+0x96>
    6584:	ff 0f       	add	r31, r31
    6586:	bb 1f       	adc	r27, r27
    6588:	66 1f       	adc	r22, r22
    658a:	77 1f       	adc	r23, r23
    658c:	88 1f       	adc	r24, r24
    658e:	c2 f7       	brpl	.-16     	; 0x6580 <__addsf3x+0x6a>
    6590:	0e c0       	rjmp	.+28     	; 0x65ae <__addsf3x+0x98>
    6592:	ba 0f       	add	r27, r26
    6594:	62 1f       	adc	r22, r18
    6596:	73 1f       	adc	r23, r19
    6598:	84 1f       	adc	r24, r20
    659a:	48 f4       	brcc	.+18     	; 0x65ae <__addsf3x+0x98>
    659c:	87 95       	ror	r24
    659e:	77 95       	ror	r23
    65a0:	67 95       	ror	r22
    65a2:	b7 95       	ror	r27
    65a4:	f7 95       	ror	r31
    65a6:	9e 3f       	cpi	r25, 0xFE	; 254
    65a8:	08 f0       	brcs	.+2      	; 0x65ac <__addsf3x+0x96>
    65aa:	b3 cf       	rjmp	.-154    	; 0x6512 <__addsf3+0x1e>
    65ac:	93 95       	inc	r25
    65ae:	88 0f       	add	r24, r24
    65b0:	08 f0       	brcs	.+2      	; 0x65b4 <__addsf3x+0x9e>
    65b2:	99 27       	eor	r25, r25
    65b4:	ee 0f       	add	r30, r30
    65b6:	97 95       	ror	r25
    65b8:	87 95       	ror	r24
    65ba:	08 95       	ret

000065bc <__divsf3>:
    65bc:	0c d0       	rcall	.+24     	; 0x65d6 <__divsf3x>
    65be:	e6 c0       	rjmp	.+460    	; 0x678c <__fp_round>
    65c0:	de d0       	rcall	.+444    	; 0x677e <__fp_pscB>
    65c2:	40 f0       	brcs	.+16     	; 0x65d4 <__divsf3+0x18>
    65c4:	d5 d0       	rcall	.+426    	; 0x6770 <__fp_pscA>
    65c6:	30 f0       	brcs	.+12     	; 0x65d4 <__divsf3+0x18>
    65c8:	21 f4       	brne	.+8      	; 0x65d2 <__divsf3+0x16>
    65ca:	5f 3f       	cpi	r21, 0xFF	; 255
    65cc:	19 f0       	breq	.+6      	; 0x65d4 <__divsf3+0x18>
    65ce:	c7 c0       	rjmp	.+398    	; 0x675e <__fp_inf>
    65d0:	51 11       	cpse	r21, r1
    65d2:	10 c1       	rjmp	.+544    	; 0x67f4 <__fp_szero>
    65d4:	ca c0       	rjmp	.+404    	; 0x676a <__fp_nan>

000065d6 <__divsf3x>:
    65d6:	eb d0       	rcall	.+470    	; 0x67ae <__fp_split3>
    65d8:	98 f3       	brcs	.-26     	; 0x65c0 <__divsf3+0x4>

000065da <__divsf3_pse>:
    65da:	99 23       	and	r25, r25
    65dc:	c9 f3       	breq	.-14     	; 0x65d0 <__divsf3+0x14>
    65de:	55 23       	and	r21, r21
    65e0:	b1 f3       	breq	.-20     	; 0x65ce <__divsf3+0x12>
    65e2:	95 1b       	sub	r25, r21
    65e4:	55 0b       	sbc	r21, r21
    65e6:	bb 27       	eor	r27, r27
    65e8:	aa 27       	eor	r26, r26
    65ea:	62 17       	cp	r22, r18
    65ec:	73 07       	cpc	r23, r19
    65ee:	84 07       	cpc	r24, r20
    65f0:	38 f0       	brcs	.+14     	; 0x6600 <__divsf3_pse+0x26>
    65f2:	9f 5f       	subi	r25, 0xFF	; 255
    65f4:	5f 4f       	sbci	r21, 0xFF	; 255
    65f6:	22 0f       	add	r18, r18
    65f8:	33 1f       	adc	r19, r19
    65fa:	44 1f       	adc	r20, r20
    65fc:	aa 1f       	adc	r26, r26
    65fe:	a9 f3       	breq	.-22     	; 0x65ea <__divsf3_pse+0x10>
    6600:	33 d0       	rcall	.+102    	; 0x6668 <__divsf3_pse+0x8e>
    6602:	0e 2e       	mov	r0, r30
    6604:	3a f0       	brmi	.+14     	; 0x6614 <__divsf3_pse+0x3a>
    6606:	e0 e8       	ldi	r30, 0x80	; 128
    6608:	30 d0       	rcall	.+96     	; 0x666a <__divsf3_pse+0x90>
    660a:	91 50       	subi	r25, 0x01	; 1
    660c:	50 40       	sbci	r21, 0x00	; 0
    660e:	e6 95       	lsr	r30
    6610:	00 1c       	adc	r0, r0
    6612:	ca f7       	brpl	.-14     	; 0x6606 <__divsf3_pse+0x2c>
    6614:	29 d0       	rcall	.+82     	; 0x6668 <__divsf3_pse+0x8e>
    6616:	fe 2f       	mov	r31, r30
    6618:	27 d0       	rcall	.+78     	; 0x6668 <__divsf3_pse+0x8e>
    661a:	66 0f       	add	r22, r22
    661c:	77 1f       	adc	r23, r23
    661e:	88 1f       	adc	r24, r24
    6620:	bb 1f       	adc	r27, r27
    6622:	26 17       	cp	r18, r22
    6624:	37 07       	cpc	r19, r23
    6626:	48 07       	cpc	r20, r24
    6628:	ab 07       	cpc	r26, r27
    662a:	b0 e8       	ldi	r27, 0x80	; 128
    662c:	09 f0       	breq	.+2      	; 0x6630 <__divsf3_pse+0x56>
    662e:	bb 0b       	sbc	r27, r27
    6630:	80 2d       	mov	r24, r0
    6632:	bf 01       	movw	r22, r30
    6634:	ff 27       	eor	r31, r31
    6636:	93 58       	subi	r25, 0x83	; 131
    6638:	5f 4f       	sbci	r21, 0xFF	; 255
    663a:	2a f0       	brmi	.+10     	; 0x6646 <__divsf3_pse+0x6c>
    663c:	9e 3f       	cpi	r25, 0xFE	; 254
    663e:	51 05       	cpc	r21, r1
    6640:	68 f0       	brcs	.+26     	; 0x665c <__divsf3_pse+0x82>
    6642:	8d c0       	rjmp	.+282    	; 0x675e <__fp_inf>
    6644:	d7 c0       	rjmp	.+430    	; 0x67f4 <__fp_szero>
    6646:	5f 3f       	cpi	r21, 0xFF	; 255
    6648:	ec f3       	brlt	.-6      	; 0x6644 <__divsf3_pse+0x6a>
    664a:	98 3e       	cpi	r25, 0xE8	; 232
    664c:	dc f3       	brlt	.-10     	; 0x6644 <__divsf3_pse+0x6a>
    664e:	86 95       	lsr	r24
    6650:	77 95       	ror	r23
    6652:	67 95       	ror	r22
    6654:	b7 95       	ror	r27
    6656:	f7 95       	ror	r31
    6658:	9f 5f       	subi	r25, 0xFF	; 255
    665a:	c9 f7       	brne	.-14     	; 0x664e <__divsf3_pse+0x74>
    665c:	88 0f       	add	r24, r24
    665e:	91 1d       	adc	r25, r1
    6660:	96 95       	lsr	r25
    6662:	87 95       	ror	r24
    6664:	97 f9       	bld	r25, 7
    6666:	08 95       	ret
    6668:	e1 e0       	ldi	r30, 0x01	; 1
    666a:	66 0f       	add	r22, r22
    666c:	77 1f       	adc	r23, r23
    666e:	88 1f       	adc	r24, r24
    6670:	bb 1f       	adc	r27, r27
    6672:	62 17       	cp	r22, r18
    6674:	73 07       	cpc	r23, r19
    6676:	84 07       	cpc	r24, r20
    6678:	ba 07       	cpc	r27, r26
    667a:	20 f0       	brcs	.+8      	; 0x6684 <__divsf3_pse+0xaa>
    667c:	62 1b       	sub	r22, r18
    667e:	73 0b       	sbc	r23, r19
    6680:	84 0b       	sbc	r24, r20
    6682:	ba 0b       	sbc	r27, r26
    6684:	ee 1f       	adc	r30, r30
    6686:	88 f7       	brcc	.-30     	; 0x666a <__divsf3_pse+0x90>
    6688:	e0 95       	com	r30
    668a:	08 95       	ret

0000668c <__fixunssfsi>:
    668c:	98 d0       	rcall	.+304    	; 0x67be <__fp_splitA>
    668e:	88 f0       	brcs	.+34     	; 0x66b2 <__fixunssfsi+0x26>
    6690:	9f 57       	subi	r25, 0x7F	; 127
    6692:	90 f0       	brcs	.+36     	; 0x66b8 <__fixunssfsi+0x2c>
    6694:	b9 2f       	mov	r27, r25
    6696:	99 27       	eor	r25, r25
    6698:	b7 51       	subi	r27, 0x17	; 23
    669a:	a0 f0       	brcs	.+40     	; 0x66c4 <__fixunssfsi+0x38>
    669c:	d1 f0       	breq	.+52     	; 0x66d2 <__fixunssfsi+0x46>
    669e:	66 0f       	add	r22, r22
    66a0:	77 1f       	adc	r23, r23
    66a2:	88 1f       	adc	r24, r24
    66a4:	99 1f       	adc	r25, r25
    66a6:	1a f0       	brmi	.+6      	; 0x66ae <__fixunssfsi+0x22>
    66a8:	ba 95       	dec	r27
    66aa:	c9 f7       	brne	.-14     	; 0x669e <__fixunssfsi+0x12>
    66ac:	12 c0       	rjmp	.+36     	; 0x66d2 <__fixunssfsi+0x46>
    66ae:	b1 30       	cpi	r27, 0x01	; 1
    66b0:	81 f0       	breq	.+32     	; 0x66d2 <__fixunssfsi+0x46>
    66b2:	9f d0       	rcall	.+318    	; 0x67f2 <__fp_zero>
    66b4:	b1 e0       	ldi	r27, 0x01	; 1
    66b6:	08 95       	ret
    66b8:	9c c0       	rjmp	.+312    	; 0x67f2 <__fp_zero>
    66ba:	67 2f       	mov	r22, r23
    66bc:	78 2f       	mov	r23, r24
    66be:	88 27       	eor	r24, r24
    66c0:	b8 5f       	subi	r27, 0xF8	; 248
    66c2:	39 f0       	breq	.+14     	; 0x66d2 <__fixunssfsi+0x46>
    66c4:	b9 3f       	cpi	r27, 0xF9	; 249
    66c6:	cc f3       	brlt	.-14     	; 0x66ba <__fixunssfsi+0x2e>
    66c8:	86 95       	lsr	r24
    66ca:	77 95       	ror	r23
    66cc:	67 95       	ror	r22
    66ce:	b3 95       	inc	r27
    66d0:	d9 f7       	brne	.-10     	; 0x66c8 <__fixunssfsi+0x3c>
    66d2:	3e f4       	brtc	.+14     	; 0x66e2 <__fixunssfsi+0x56>
    66d4:	90 95       	com	r25
    66d6:	80 95       	com	r24
    66d8:	70 95       	com	r23
    66da:	61 95       	neg	r22
    66dc:	7f 4f       	sbci	r23, 0xFF	; 255
    66de:	8f 4f       	sbci	r24, 0xFF	; 255
    66e0:	9f 4f       	sbci	r25, 0xFF	; 255
    66e2:	08 95       	ret

000066e4 <__floatunsisf>:
    66e4:	e8 94       	clt
    66e6:	09 c0       	rjmp	.+18     	; 0x66fa <__floatsisf+0x12>

000066e8 <__floatsisf>:
    66e8:	97 fb       	bst	r25, 7
    66ea:	3e f4       	brtc	.+14     	; 0x66fa <__floatsisf+0x12>
    66ec:	90 95       	com	r25
    66ee:	80 95       	com	r24
    66f0:	70 95       	com	r23
    66f2:	61 95       	neg	r22
    66f4:	7f 4f       	sbci	r23, 0xFF	; 255
    66f6:	8f 4f       	sbci	r24, 0xFF	; 255
    66f8:	9f 4f       	sbci	r25, 0xFF	; 255
    66fa:	99 23       	and	r25, r25
    66fc:	a9 f0       	breq	.+42     	; 0x6728 <__floatsisf+0x40>
    66fe:	f9 2f       	mov	r31, r25
    6700:	96 e9       	ldi	r25, 0x96	; 150
    6702:	bb 27       	eor	r27, r27
    6704:	93 95       	inc	r25
    6706:	f6 95       	lsr	r31
    6708:	87 95       	ror	r24
    670a:	77 95       	ror	r23
    670c:	67 95       	ror	r22
    670e:	b7 95       	ror	r27
    6710:	f1 11       	cpse	r31, r1
    6712:	f8 cf       	rjmp	.-16     	; 0x6704 <__floatsisf+0x1c>
    6714:	fa f4       	brpl	.+62     	; 0x6754 <__floatsisf+0x6c>
    6716:	bb 0f       	add	r27, r27
    6718:	11 f4       	brne	.+4      	; 0x671e <__floatsisf+0x36>
    671a:	60 ff       	sbrs	r22, 0
    671c:	1b c0       	rjmp	.+54     	; 0x6754 <__floatsisf+0x6c>
    671e:	6f 5f       	subi	r22, 0xFF	; 255
    6720:	7f 4f       	sbci	r23, 0xFF	; 255
    6722:	8f 4f       	sbci	r24, 0xFF	; 255
    6724:	9f 4f       	sbci	r25, 0xFF	; 255
    6726:	16 c0       	rjmp	.+44     	; 0x6754 <__floatsisf+0x6c>
    6728:	88 23       	and	r24, r24
    672a:	11 f0       	breq	.+4      	; 0x6730 <__floatsisf+0x48>
    672c:	96 e9       	ldi	r25, 0x96	; 150
    672e:	11 c0       	rjmp	.+34     	; 0x6752 <__floatsisf+0x6a>
    6730:	77 23       	and	r23, r23
    6732:	21 f0       	breq	.+8      	; 0x673c <__floatsisf+0x54>
    6734:	9e e8       	ldi	r25, 0x8E	; 142
    6736:	87 2f       	mov	r24, r23
    6738:	76 2f       	mov	r23, r22
    673a:	05 c0       	rjmp	.+10     	; 0x6746 <__floatsisf+0x5e>
    673c:	66 23       	and	r22, r22
    673e:	71 f0       	breq	.+28     	; 0x675c <__floatsisf+0x74>
    6740:	96 e8       	ldi	r25, 0x86	; 134
    6742:	86 2f       	mov	r24, r22
    6744:	70 e0       	ldi	r23, 0x00	; 0
    6746:	60 e0       	ldi	r22, 0x00	; 0
    6748:	2a f0       	brmi	.+10     	; 0x6754 <__floatsisf+0x6c>
    674a:	9a 95       	dec	r25
    674c:	66 0f       	add	r22, r22
    674e:	77 1f       	adc	r23, r23
    6750:	88 1f       	adc	r24, r24
    6752:	da f7       	brpl	.-10     	; 0x674a <__floatsisf+0x62>
    6754:	88 0f       	add	r24, r24
    6756:	96 95       	lsr	r25
    6758:	87 95       	ror	r24
    675a:	97 f9       	bld	r25, 7
    675c:	08 95       	ret

0000675e <__fp_inf>:
    675e:	97 f9       	bld	r25, 7
    6760:	9f 67       	ori	r25, 0x7F	; 127
    6762:	80 e8       	ldi	r24, 0x80	; 128
    6764:	70 e0       	ldi	r23, 0x00	; 0
    6766:	60 e0       	ldi	r22, 0x00	; 0
    6768:	08 95       	ret

0000676a <__fp_nan>:
    676a:	9f ef       	ldi	r25, 0xFF	; 255
    676c:	80 ec       	ldi	r24, 0xC0	; 192
    676e:	08 95       	ret

00006770 <__fp_pscA>:
    6770:	00 24       	eor	r0, r0
    6772:	0a 94       	dec	r0
    6774:	16 16       	cp	r1, r22
    6776:	17 06       	cpc	r1, r23
    6778:	18 06       	cpc	r1, r24
    677a:	09 06       	cpc	r0, r25
    677c:	08 95       	ret

0000677e <__fp_pscB>:
    677e:	00 24       	eor	r0, r0
    6780:	0a 94       	dec	r0
    6782:	12 16       	cp	r1, r18
    6784:	13 06       	cpc	r1, r19
    6786:	14 06       	cpc	r1, r20
    6788:	05 06       	cpc	r0, r21
    678a:	08 95       	ret

0000678c <__fp_round>:
    678c:	09 2e       	mov	r0, r25
    678e:	03 94       	inc	r0
    6790:	00 0c       	add	r0, r0
    6792:	11 f4       	brne	.+4      	; 0x6798 <__fp_round+0xc>
    6794:	88 23       	and	r24, r24
    6796:	52 f0       	brmi	.+20     	; 0x67ac <__fp_round+0x20>
    6798:	bb 0f       	add	r27, r27
    679a:	40 f4       	brcc	.+16     	; 0x67ac <__fp_round+0x20>
    679c:	bf 2b       	or	r27, r31
    679e:	11 f4       	brne	.+4      	; 0x67a4 <__fp_round+0x18>
    67a0:	60 ff       	sbrs	r22, 0
    67a2:	04 c0       	rjmp	.+8      	; 0x67ac <__fp_round+0x20>
    67a4:	6f 5f       	subi	r22, 0xFF	; 255
    67a6:	7f 4f       	sbci	r23, 0xFF	; 255
    67a8:	8f 4f       	sbci	r24, 0xFF	; 255
    67aa:	9f 4f       	sbci	r25, 0xFF	; 255
    67ac:	08 95       	ret

000067ae <__fp_split3>:
    67ae:	57 fd       	sbrc	r21, 7
    67b0:	90 58       	subi	r25, 0x80	; 128
    67b2:	44 0f       	add	r20, r20
    67b4:	55 1f       	adc	r21, r21
    67b6:	59 f0       	breq	.+22     	; 0x67ce <__fp_splitA+0x10>
    67b8:	5f 3f       	cpi	r21, 0xFF	; 255
    67ba:	71 f0       	breq	.+28     	; 0x67d8 <__fp_splitA+0x1a>
    67bc:	47 95       	ror	r20

000067be <__fp_splitA>:
    67be:	88 0f       	add	r24, r24
    67c0:	97 fb       	bst	r25, 7
    67c2:	99 1f       	adc	r25, r25
    67c4:	61 f0       	breq	.+24     	; 0x67de <__fp_splitA+0x20>
    67c6:	9f 3f       	cpi	r25, 0xFF	; 255
    67c8:	79 f0       	breq	.+30     	; 0x67e8 <__fp_splitA+0x2a>
    67ca:	87 95       	ror	r24
    67cc:	08 95       	ret
    67ce:	12 16       	cp	r1, r18
    67d0:	13 06       	cpc	r1, r19
    67d2:	14 06       	cpc	r1, r20
    67d4:	55 1f       	adc	r21, r21
    67d6:	f2 cf       	rjmp	.-28     	; 0x67bc <__fp_split3+0xe>
    67d8:	46 95       	lsr	r20
    67da:	f1 df       	rcall	.-30     	; 0x67be <__fp_splitA>
    67dc:	08 c0       	rjmp	.+16     	; 0x67ee <__fp_splitA+0x30>
    67de:	16 16       	cp	r1, r22
    67e0:	17 06       	cpc	r1, r23
    67e2:	18 06       	cpc	r1, r24
    67e4:	99 1f       	adc	r25, r25
    67e6:	f1 cf       	rjmp	.-30     	; 0x67ca <__fp_splitA+0xc>
    67e8:	86 95       	lsr	r24
    67ea:	71 05       	cpc	r23, r1
    67ec:	61 05       	cpc	r22, r1
    67ee:	08 94       	sec
    67f0:	08 95       	ret

000067f2 <__fp_zero>:
    67f2:	e8 94       	clt

000067f4 <__fp_szero>:
    67f4:	bb 27       	eor	r27, r27
    67f6:	66 27       	eor	r22, r22
    67f8:	77 27       	eor	r23, r23
    67fa:	cb 01       	movw	r24, r22
    67fc:	97 f9       	bld	r25, 7
    67fe:	08 95       	ret

00006800 <pow>:
    6800:	fa 01       	movw	r30, r20
    6802:	ee 0f       	add	r30, r30
    6804:	ff 1f       	adc	r31, r31
    6806:	30 96       	adiw	r30, 0x00	; 0
    6808:	21 05       	cpc	r18, r1
    680a:	31 05       	cpc	r19, r1
    680c:	99 f1       	breq	.+102    	; 0x6874 <pow+0x74>
    680e:	61 15       	cp	r22, r1
    6810:	71 05       	cpc	r23, r1
    6812:	61 f4       	brne	.+24     	; 0x682c <pow+0x2c>
    6814:	80 38       	cpi	r24, 0x80	; 128
    6816:	bf e3       	ldi	r27, 0x3F	; 63
    6818:	9b 07       	cpc	r25, r27
    681a:	49 f1       	breq	.+82     	; 0x686e <pow+0x6e>
    681c:	68 94       	set
    681e:	90 38       	cpi	r25, 0x80	; 128
    6820:	81 05       	cpc	r24, r1
    6822:	61 f0       	breq	.+24     	; 0x683c <pow+0x3c>
    6824:	80 38       	cpi	r24, 0x80	; 128
    6826:	bf ef       	ldi	r27, 0xFF	; 255
    6828:	9b 07       	cpc	r25, r27
    682a:	41 f0       	breq	.+16     	; 0x683c <pow+0x3c>
    682c:	99 23       	and	r25, r25
    682e:	42 f5       	brpl	.+80     	; 0x6880 <pow+0x80>
    6830:	ff 3f       	cpi	r31, 0xFF	; 255
    6832:	e1 05       	cpc	r30, r1
    6834:	31 05       	cpc	r19, r1
    6836:	21 05       	cpc	r18, r1
    6838:	11 f1       	breq	.+68     	; 0x687e <pow+0x7e>
    683a:	e8 94       	clt
    683c:	08 94       	sec
    683e:	e7 95       	ror	r30
    6840:	d9 01       	movw	r26, r18
    6842:	aa 23       	and	r26, r26
    6844:	29 f4       	brne	.+10     	; 0x6850 <pow+0x50>
    6846:	ab 2f       	mov	r26, r27
    6848:	be 2f       	mov	r27, r30
    684a:	f8 5f       	subi	r31, 0xF8	; 248
    684c:	d0 f3       	brcs	.-12     	; 0x6842 <pow+0x42>
    684e:	10 c0       	rjmp	.+32     	; 0x6870 <pow+0x70>
    6850:	ff 5f       	subi	r31, 0xFF	; 255
    6852:	70 f4       	brcc	.+28     	; 0x6870 <pow+0x70>
    6854:	a6 95       	lsr	r26
    6856:	e0 f7       	brcc	.-8      	; 0x6850 <pow+0x50>
    6858:	f7 39       	cpi	r31, 0x97	; 151
    685a:	50 f0       	brcs	.+20     	; 0x6870 <pow+0x70>
    685c:	19 f0       	breq	.+6      	; 0x6864 <pow+0x64>
    685e:	ff 3a       	cpi	r31, 0xAF	; 175
    6860:	38 f4       	brcc	.+14     	; 0x6870 <pow+0x70>
    6862:	9f 77       	andi	r25, 0x7F	; 127
    6864:	9f 93       	push	r25
    6866:	0c d0       	rcall	.+24     	; 0x6880 <pow+0x80>
    6868:	0f 90       	pop	r0
    686a:	07 fc       	sbrc	r0, 7
    686c:	90 58       	subi	r25, 0x80	; 128
    686e:	08 95       	ret
    6870:	3e f0       	brts	.+14     	; 0x6880 <pow+0x80>
    6872:	7b cf       	rjmp	.-266    	; 0x676a <__fp_nan>
    6874:	60 e0       	ldi	r22, 0x00	; 0
    6876:	70 e0       	ldi	r23, 0x00	; 0
    6878:	80 e8       	ldi	r24, 0x80	; 128
    687a:	9f e3       	ldi	r25, 0x3F	; 63
    687c:	08 95       	ret
    687e:	4f e7       	ldi	r20, 0x7F	; 127
    6880:	9f 77       	andi	r25, 0x7F	; 127
    6882:	5f 93       	push	r21
    6884:	4f 93       	push	r20
    6886:	3f 93       	push	r19
    6888:	2f 93       	push	r18
    688a:	9e d0       	rcall	.+316    	; 0x69c8 <log>
    688c:	2f 91       	pop	r18
    688e:	3f 91       	pop	r19
    6890:	4f 91       	pop	r20
    6892:	5f 91       	pop	r21
    6894:	0c d1       	rcall	.+536    	; 0x6aae <__mulsf3>
    6896:	05 c0       	rjmp	.+10     	; 0x68a2 <exp>
    6898:	19 f4       	brne	.+6      	; 0x68a0 <pow+0xa0>
    689a:	0e f0       	brts	.+2      	; 0x689e <pow+0x9e>
    689c:	60 cf       	rjmp	.-320    	; 0x675e <__fp_inf>
    689e:	a9 cf       	rjmp	.-174    	; 0x67f2 <__fp_zero>
    68a0:	64 cf       	rjmp	.-312    	; 0x676a <__fp_nan>

000068a2 <exp>:
    68a2:	8d df       	rcall	.-230    	; 0x67be <__fp_splitA>
    68a4:	c8 f3       	brcs	.-14     	; 0x6898 <pow+0x98>
    68a6:	96 38       	cpi	r25, 0x86	; 134
    68a8:	c0 f7       	brcc	.-16     	; 0x689a <pow+0x9a>
    68aa:	07 f8       	bld	r0, 7
    68ac:	0f 92       	push	r0
    68ae:	e8 94       	clt
    68b0:	2b e3       	ldi	r18, 0x3B	; 59
    68b2:	3a ea       	ldi	r19, 0xAA	; 170
    68b4:	48 eb       	ldi	r20, 0xB8	; 184
    68b6:	5f e7       	ldi	r21, 0x7F	; 127
    68b8:	08 d1       	rcall	.+528    	; 0x6aca <__mulsf3_pse>
    68ba:	0f 92       	push	r0
    68bc:	0f 92       	push	r0
    68be:	0f 92       	push	r0
    68c0:	4d b7       	in	r20, 0x3d	; 61
    68c2:	5e b7       	in	r21, 0x3e	; 62
    68c4:	0f 92       	push	r0
    68c6:	c0 d0       	rcall	.+384    	; 0x6a48 <modf>
    68c8:	e4 e5       	ldi	r30, 0x54	; 84
    68ca:	f0 e0       	ldi	r31, 0x00	; 0
    68cc:	16 d0       	rcall	.+44     	; 0x68fa <__fp_powser>
    68ce:	4f 91       	pop	r20
    68d0:	5f 91       	pop	r21
    68d2:	ef 91       	pop	r30
    68d4:	ff 91       	pop	r31
    68d6:	e5 95       	asr	r30
    68d8:	ee 1f       	adc	r30, r30
    68da:	ff 1f       	adc	r31, r31
    68dc:	49 f0       	breq	.+18     	; 0x68f0 <exp+0x4e>
    68de:	fe 57       	subi	r31, 0x7E	; 126
    68e0:	e0 68       	ori	r30, 0x80	; 128
    68e2:	44 27       	eor	r20, r20
    68e4:	ee 0f       	add	r30, r30
    68e6:	44 1f       	adc	r20, r20
    68e8:	fa 95       	dec	r31
    68ea:	e1 f7       	brne	.-8      	; 0x68e4 <exp+0x42>
    68ec:	41 95       	neg	r20
    68ee:	55 0b       	sbc	r21, r21
    68f0:	32 d0       	rcall	.+100    	; 0x6956 <ldexp>
    68f2:	0f 90       	pop	r0
    68f4:	07 fe       	sbrs	r0, 7
    68f6:	26 c0       	rjmp	.+76     	; 0x6944 <inverse>
    68f8:	08 95       	ret

000068fa <__fp_powser>:
    68fa:	df 93       	push	r29
    68fc:	cf 93       	push	r28
    68fe:	1f 93       	push	r17
    6900:	0f 93       	push	r16
    6902:	ff 92       	push	r15
    6904:	ef 92       	push	r14
    6906:	df 92       	push	r13
    6908:	7b 01       	movw	r14, r22
    690a:	8c 01       	movw	r16, r24
    690c:	68 94       	set
    690e:	05 c0       	rjmp	.+10     	; 0x691a <__fp_powser+0x20>
    6910:	da 2e       	mov	r13, r26
    6912:	ef 01       	movw	r28, r30
    6914:	d8 d0       	rcall	.+432    	; 0x6ac6 <__mulsf3x>
    6916:	fe 01       	movw	r30, r28
    6918:	e8 94       	clt
    691a:	a5 91       	lpm	r26, Z+
    691c:	25 91       	lpm	r18, Z+
    691e:	35 91       	lpm	r19, Z+
    6920:	45 91       	lpm	r20, Z+
    6922:	55 91       	lpm	r21, Z+
    6924:	ae f3       	brts	.-22     	; 0x6910 <__fp_powser+0x16>
    6926:	ef 01       	movw	r28, r30
    6928:	f6 dd       	rcall	.-1044   	; 0x6516 <__addsf3x>
    692a:	fe 01       	movw	r30, r28
    692c:	97 01       	movw	r18, r14
    692e:	a8 01       	movw	r20, r16
    6930:	da 94       	dec	r13
    6932:	79 f7       	brne	.-34     	; 0x6912 <__fp_powser+0x18>
    6934:	df 90       	pop	r13
    6936:	ef 90       	pop	r14
    6938:	ff 90       	pop	r15
    693a:	0f 91       	pop	r16
    693c:	1f 91       	pop	r17
    693e:	cf 91       	pop	r28
    6940:	df 91       	pop	r29
    6942:	08 95       	ret

00006944 <inverse>:
    6944:	9b 01       	movw	r18, r22
    6946:	ac 01       	movw	r20, r24
    6948:	60 e0       	ldi	r22, 0x00	; 0
    694a:	70 e0       	ldi	r23, 0x00	; 0
    694c:	80 e8       	ldi	r24, 0x80	; 128
    694e:	9f e3       	ldi	r25, 0x3F	; 63
    6950:	35 ce       	rjmp	.-918    	; 0x65bc <__divsf3>
    6952:	05 cf       	rjmp	.-502    	; 0x675e <__fp_inf>
    6954:	0f c1       	rjmp	.+542    	; 0x6b74 <__fp_mpack>

00006956 <ldexp>:
    6956:	33 df       	rcall	.-410    	; 0x67be <__fp_splitA>
    6958:	e8 f3       	brcs	.-6      	; 0x6954 <inverse+0x10>
    695a:	99 23       	and	r25, r25
    695c:	d9 f3       	breq	.-10     	; 0x6954 <inverse+0x10>
    695e:	94 0f       	add	r25, r20
    6960:	51 1d       	adc	r21, r1
    6962:	bb f3       	brvs	.-18     	; 0x6952 <inverse+0xe>
    6964:	91 50       	subi	r25, 0x01	; 1
    6966:	50 40       	sbci	r21, 0x00	; 0
    6968:	94 f0       	brlt	.+36     	; 0x698e <ldexp+0x38>
    696a:	59 f0       	breq	.+22     	; 0x6982 <ldexp+0x2c>
    696c:	88 23       	and	r24, r24
    696e:	32 f0       	brmi	.+12     	; 0x697c <ldexp+0x26>
    6970:	66 0f       	add	r22, r22
    6972:	77 1f       	adc	r23, r23
    6974:	88 1f       	adc	r24, r24
    6976:	91 50       	subi	r25, 0x01	; 1
    6978:	50 40       	sbci	r21, 0x00	; 0
    697a:	c1 f7       	brne	.-16     	; 0x696c <ldexp+0x16>
    697c:	9e 3f       	cpi	r25, 0xFE	; 254
    697e:	51 05       	cpc	r21, r1
    6980:	44 f7       	brge	.-48     	; 0x6952 <inverse+0xe>
    6982:	88 0f       	add	r24, r24
    6984:	91 1d       	adc	r25, r1
    6986:	96 95       	lsr	r25
    6988:	87 95       	ror	r24
    698a:	97 f9       	bld	r25, 7
    698c:	08 95       	ret
    698e:	5f 3f       	cpi	r21, 0xFF	; 255
    6990:	ac f0       	brlt	.+42     	; 0x69bc <ldexp+0x66>
    6992:	98 3e       	cpi	r25, 0xE8	; 232
    6994:	9c f0       	brlt	.+38     	; 0x69bc <ldexp+0x66>
    6996:	bb 27       	eor	r27, r27
    6998:	86 95       	lsr	r24
    699a:	77 95       	ror	r23
    699c:	67 95       	ror	r22
    699e:	b7 95       	ror	r27
    69a0:	08 f4       	brcc	.+2      	; 0x69a4 <ldexp+0x4e>
    69a2:	b1 60       	ori	r27, 0x01	; 1
    69a4:	93 95       	inc	r25
    69a6:	c1 f7       	brne	.-16     	; 0x6998 <ldexp+0x42>
    69a8:	bb 0f       	add	r27, r27
    69aa:	58 f7       	brcc	.-42     	; 0x6982 <ldexp+0x2c>
    69ac:	11 f4       	brne	.+4      	; 0x69b2 <ldexp+0x5c>
    69ae:	60 ff       	sbrs	r22, 0
    69b0:	e8 cf       	rjmp	.-48     	; 0x6982 <ldexp+0x2c>
    69b2:	6f 5f       	subi	r22, 0xFF	; 255
    69b4:	7f 4f       	sbci	r23, 0xFF	; 255
    69b6:	8f 4f       	sbci	r24, 0xFF	; 255
    69b8:	9f 4f       	sbci	r25, 0xFF	; 255
    69ba:	e3 cf       	rjmp	.-58     	; 0x6982 <ldexp+0x2c>
    69bc:	1b cf       	rjmp	.-458    	; 0x67f4 <__fp_szero>
    69be:	0e f0       	brts	.+2      	; 0x69c2 <ldexp+0x6c>
    69c0:	d9 c0       	rjmp	.+434    	; 0x6b74 <__fp_mpack>
    69c2:	d3 ce       	rjmp	.-602    	; 0x676a <__fp_nan>
    69c4:	68 94       	set
    69c6:	cb ce       	rjmp	.-618    	; 0x675e <__fp_inf>

000069c8 <log>:
    69c8:	fa de       	rcall	.-524    	; 0x67be <__fp_splitA>
    69ca:	c8 f3       	brcs	.-14     	; 0x69be <ldexp+0x68>
    69cc:	99 23       	and	r25, r25
    69ce:	d1 f3       	breq	.-12     	; 0x69c4 <ldexp+0x6e>
    69d0:	c6 f3       	brts	.-16     	; 0x69c2 <ldexp+0x6c>
    69d2:	df 93       	push	r29
    69d4:	cf 93       	push	r28
    69d6:	1f 93       	push	r17
    69d8:	0f 93       	push	r16
    69da:	ff 92       	push	r15
    69dc:	c9 2f       	mov	r28, r25
    69de:	dd 27       	eor	r29, r29
    69e0:	88 23       	and	r24, r24
    69e2:	2a f0       	brmi	.+10     	; 0x69ee <log+0x26>
    69e4:	21 97       	sbiw	r28, 0x01	; 1
    69e6:	66 0f       	add	r22, r22
    69e8:	77 1f       	adc	r23, r23
    69ea:	88 1f       	adc	r24, r24
    69ec:	da f7       	brpl	.-10     	; 0x69e4 <log+0x1c>
    69ee:	20 e0       	ldi	r18, 0x00	; 0
    69f0:	30 e0       	ldi	r19, 0x00	; 0
    69f2:	40 e8       	ldi	r20, 0x80	; 128
    69f4:	5f eb       	ldi	r21, 0xBF	; 191
    69f6:	9f e3       	ldi	r25, 0x3F	; 63
    69f8:	88 39       	cpi	r24, 0x98	; 152
    69fa:	20 f0       	brcs	.+8      	; 0x6a04 <log+0x3c>
    69fc:	80 3e       	cpi	r24, 0xE0	; 224
    69fe:	30 f0       	brcs	.+12     	; 0x6a0c <log+0x44>
    6a00:	21 96       	adiw	r28, 0x01	; 1
    6a02:	8f 77       	andi	r24, 0x7F	; 127
    6a04:	77 dd       	rcall	.-1298   	; 0x64f4 <__addsf3>
    6a06:	ec e7       	ldi	r30, 0x7C	; 124
    6a08:	f0 e0       	ldi	r31, 0x00	; 0
    6a0a:	03 c0       	rjmp	.+6      	; 0x6a12 <log+0x4a>
    6a0c:	73 dd       	rcall	.-1306   	; 0x64f4 <__addsf3>
    6a0e:	e9 ea       	ldi	r30, 0xA9	; 169
    6a10:	f0 e0       	ldi	r31, 0x00	; 0
    6a12:	73 df       	rcall	.-282    	; 0x68fa <__fp_powser>
    6a14:	8b 01       	movw	r16, r22
    6a16:	be 01       	movw	r22, r28
    6a18:	ec 01       	movw	r28, r24
    6a1a:	fb 2e       	mov	r15, r27
    6a1c:	6f 57       	subi	r22, 0x7F	; 127
    6a1e:	71 09       	sbc	r23, r1
    6a20:	75 95       	asr	r23
    6a22:	77 1f       	adc	r23, r23
    6a24:	88 0b       	sbc	r24, r24
    6a26:	99 0b       	sbc	r25, r25
    6a28:	5f de       	rcall	.-834    	; 0x66e8 <__floatsisf>
    6a2a:	28 e1       	ldi	r18, 0x18	; 24
    6a2c:	32 e7       	ldi	r19, 0x72	; 114
    6a2e:	41 e3       	ldi	r20, 0x31	; 49
    6a30:	5f e3       	ldi	r21, 0x3F	; 63
    6a32:	49 d0       	rcall	.+146    	; 0x6ac6 <__mulsf3x>
    6a34:	af 2d       	mov	r26, r15
    6a36:	98 01       	movw	r18, r16
    6a38:	ae 01       	movw	r20, r28
    6a3a:	ff 90       	pop	r15
    6a3c:	0f 91       	pop	r16
    6a3e:	1f 91       	pop	r17
    6a40:	cf 91       	pop	r28
    6a42:	df 91       	pop	r29
    6a44:	68 dd       	rcall	.-1328   	; 0x6516 <__addsf3x>
    6a46:	a2 ce       	rjmp	.-700    	; 0x678c <__fp_round>

00006a48 <modf>:
    6a48:	fa 01       	movw	r30, r20
    6a4a:	dc 01       	movw	r26, r24
    6a4c:	aa 0f       	add	r26, r26
    6a4e:	bb 1f       	adc	r27, r27
    6a50:	9b 01       	movw	r18, r22
    6a52:	ac 01       	movw	r20, r24
    6a54:	bf 57       	subi	r27, 0x7F	; 127
    6a56:	28 f4       	brcc	.+10     	; 0x6a62 <modf+0x1a>
    6a58:	22 27       	eor	r18, r18
    6a5a:	33 27       	eor	r19, r19
    6a5c:	44 27       	eor	r20, r20
    6a5e:	50 78       	andi	r21, 0x80	; 128
    6a60:	1f c0       	rjmp	.+62     	; 0x6aa0 <modf+0x58>
    6a62:	b7 51       	subi	r27, 0x17	; 23
    6a64:	88 f4       	brcc	.+34     	; 0x6a88 <modf+0x40>
    6a66:	ab 2f       	mov	r26, r27
    6a68:	00 24       	eor	r0, r0
    6a6a:	46 95       	lsr	r20
    6a6c:	37 95       	ror	r19
    6a6e:	27 95       	ror	r18
    6a70:	01 1c       	adc	r0, r1
    6a72:	a3 95       	inc	r26
    6a74:	d2 f3       	brmi	.-12     	; 0x6a6a <modf+0x22>
    6a76:	00 20       	and	r0, r0
    6a78:	69 f0       	breq	.+26     	; 0x6a94 <modf+0x4c>
    6a7a:	22 0f       	add	r18, r18
    6a7c:	33 1f       	adc	r19, r19
    6a7e:	44 1f       	adc	r20, r20
    6a80:	b3 95       	inc	r27
    6a82:	da f3       	brmi	.-10     	; 0x6a7a <modf+0x32>
    6a84:	0d d0       	rcall	.+26     	; 0x6aa0 <modf+0x58>
    6a86:	35 cd       	rjmp	.-1430   	; 0x64f2 <__subsf3>
    6a88:	61 30       	cpi	r22, 0x01	; 1
    6a8a:	71 05       	cpc	r23, r1
    6a8c:	a0 e8       	ldi	r26, 0x80	; 128
    6a8e:	8a 07       	cpc	r24, r26
    6a90:	b9 46       	sbci	r27, 0x69	; 105
    6a92:	30 f4       	brcc	.+12     	; 0x6aa0 <modf+0x58>
    6a94:	9b 01       	movw	r18, r22
    6a96:	ac 01       	movw	r20, r24
    6a98:	66 27       	eor	r22, r22
    6a9a:	77 27       	eor	r23, r23
    6a9c:	88 27       	eor	r24, r24
    6a9e:	90 78       	andi	r25, 0x80	; 128
    6aa0:	30 96       	adiw	r30, 0x00	; 0
    6aa2:	21 f0       	breq	.+8      	; 0x6aac <modf+0x64>
    6aa4:	20 83       	st	Z, r18
    6aa6:	31 83       	std	Z+1, r19	; 0x01
    6aa8:	42 83       	std	Z+2, r20	; 0x02
    6aaa:	53 83       	std	Z+3, r21	; 0x03
    6aac:	08 95       	ret

00006aae <__mulsf3>:
    6aae:	0b d0       	rcall	.+22     	; 0x6ac6 <__mulsf3x>
    6ab0:	6d ce       	rjmp	.-806    	; 0x678c <__fp_round>
    6ab2:	5e de       	rcall	.-836    	; 0x6770 <__fp_pscA>
    6ab4:	28 f0       	brcs	.+10     	; 0x6ac0 <__mulsf3+0x12>
    6ab6:	63 de       	rcall	.-826    	; 0x677e <__fp_pscB>
    6ab8:	18 f0       	brcs	.+6      	; 0x6ac0 <__mulsf3+0x12>
    6aba:	95 23       	and	r25, r21
    6abc:	09 f0       	breq	.+2      	; 0x6ac0 <__mulsf3+0x12>
    6abe:	4f ce       	rjmp	.-866    	; 0x675e <__fp_inf>
    6ac0:	54 ce       	rjmp	.-856    	; 0x676a <__fp_nan>
    6ac2:	11 24       	eor	r1, r1
    6ac4:	97 ce       	rjmp	.-722    	; 0x67f4 <__fp_szero>

00006ac6 <__mulsf3x>:
    6ac6:	73 de       	rcall	.-794    	; 0x67ae <__fp_split3>
    6ac8:	a0 f3       	brcs	.-24     	; 0x6ab2 <__mulsf3+0x4>

00006aca <__mulsf3_pse>:
    6aca:	95 9f       	mul	r25, r21
    6acc:	d1 f3       	breq	.-12     	; 0x6ac2 <__mulsf3+0x14>
    6ace:	95 0f       	add	r25, r21
    6ad0:	50 e0       	ldi	r21, 0x00	; 0
    6ad2:	55 1f       	adc	r21, r21
    6ad4:	62 9f       	mul	r22, r18
    6ad6:	f0 01       	movw	r30, r0
    6ad8:	72 9f       	mul	r23, r18
    6ada:	bb 27       	eor	r27, r27
    6adc:	f0 0d       	add	r31, r0
    6ade:	b1 1d       	adc	r27, r1
    6ae0:	63 9f       	mul	r22, r19
    6ae2:	aa 27       	eor	r26, r26
    6ae4:	f0 0d       	add	r31, r0
    6ae6:	b1 1d       	adc	r27, r1
    6ae8:	aa 1f       	adc	r26, r26
    6aea:	64 9f       	mul	r22, r20
    6aec:	66 27       	eor	r22, r22
    6aee:	b0 0d       	add	r27, r0
    6af0:	a1 1d       	adc	r26, r1
    6af2:	66 1f       	adc	r22, r22
    6af4:	82 9f       	mul	r24, r18
    6af6:	22 27       	eor	r18, r18
    6af8:	b0 0d       	add	r27, r0
    6afa:	a1 1d       	adc	r26, r1
    6afc:	62 1f       	adc	r22, r18
    6afe:	73 9f       	mul	r23, r19
    6b00:	b0 0d       	add	r27, r0
    6b02:	a1 1d       	adc	r26, r1
    6b04:	62 1f       	adc	r22, r18
    6b06:	83 9f       	mul	r24, r19
    6b08:	a0 0d       	add	r26, r0
    6b0a:	61 1d       	adc	r22, r1
    6b0c:	22 1f       	adc	r18, r18
    6b0e:	74 9f       	mul	r23, r20
    6b10:	33 27       	eor	r19, r19
    6b12:	a0 0d       	add	r26, r0
    6b14:	61 1d       	adc	r22, r1
    6b16:	23 1f       	adc	r18, r19
    6b18:	84 9f       	mul	r24, r20
    6b1a:	60 0d       	add	r22, r0
    6b1c:	21 1d       	adc	r18, r1
    6b1e:	82 2f       	mov	r24, r18
    6b20:	76 2f       	mov	r23, r22
    6b22:	6a 2f       	mov	r22, r26
    6b24:	11 24       	eor	r1, r1
    6b26:	9f 57       	subi	r25, 0x7F	; 127
    6b28:	50 40       	sbci	r21, 0x00	; 0
    6b2a:	8a f0       	brmi	.+34     	; 0x6b4e <__mulsf3_pse+0x84>
    6b2c:	e1 f0       	breq	.+56     	; 0x6b66 <__mulsf3_pse+0x9c>
    6b2e:	88 23       	and	r24, r24
    6b30:	4a f0       	brmi	.+18     	; 0x6b44 <__mulsf3_pse+0x7a>
    6b32:	ee 0f       	add	r30, r30
    6b34:	ff 1f       	adc	r31, r31
    6b36:	bb 1f       	adc	r27, r27
    6b38:	66 1f       	adc	r22, r22
    6b3a:	77 1f       	adc	r23, r23
    6b3c:	88 1f       	adc	r24, r24
    6b3e:	91 50       	subi	r25, 0x01	; 1
    6b40:	50 40       	sbci	r21, 0x00	; 0
    6b42:	a9 f7       	brne	.-22     	; 0x6b2e <__mulsf3_pse+0x64>
    6b44:	9e 3f       	cpi	r25, 0xFE	; 254
    6b46:	51 05       	cpc	r21, r1
    6b48:	70 f0       	brcs	.+28     	; 0x6b66 <__mulsf3_pse+0x9c>
    6b4a:	09 ce       	rjmp	.-1006   	; 0x675e <__fp_inf>
    6b4c:	53 ce       	rjmp	.-858    	; 0x67f4 <__fp_szero>
    6b4e:	5f 3f       	cpi	r21, 0xFF	; 255
    6b50:	ec f3       	brlt	.-6      	; 0x6b4c <__mulsf3_pse+0x82>
    6b52:	98 3e       	cpi	r25, 0xE8	; 232
    6b54:	dc f3       	brlt	.-10     	; 0x6b4c <__mulsf3_pse+0x82>
    6b56:	86 95       	lsr	r24
    6b58:	77 95       	ror	r23
    6b5a:	67 95       	ror	r22
    6b5c:	b7 95       	ror	r27
    6b5e:	f7 95       	ror	r31
    6b60:	e7 95       	ror	r30
    6b62:	9f 5f       	subi	r25, 0xFF	; 255
    6b64:	c1 f7       	brne	.-16     	; 0x6b56 <__mulsf3_pse+0x8c>
    6b66:	fe 2b       	or	r31, r30
    6b68:	88 0f       	add	r24, r24
    6b6a:	91 1d       	adc	r25, r1
    6b6c:	96 95       	lsr	r25
    6b6e:	87 95       	ror	r24
    6b70:	97 f9       	bld	r25, 7
    6b72:	08 95       	ret

00006b74 <__fp_mpack>:
    6b74:	9f 3f       	cpi	r25, 0xFF	; 255
    6b76:	31 f0       	breq	.+12     	; 0x6b84 <__fp_mpack_finite+0xc>

00006b78 <__fp_mpack_finite>:
    6b78:	91 50       	subi	r25, 0x01	; 1
    6b7a:	20 f4       	brcc	.+8      	; 0x6b84 <__fp_mpack_finite+0xc>
    6b7c:	87 95       	ror	r24
    6b7e:	77 95       	ror	r23
    6b80:	67 95       	ror	r22
    6b82:	b7 95       	ror	r27
    6b84:	88 0f       	add	r24, r24
    6b86:	91 1d       	adc	r25, r1
    6b88:	96 95       	lsr	r25
    6b8a:	87 95       	ror	r24
    6b8c:	97 f9       	bld	r25, 7
    6b8e:	08 95       	ret

00006b90 <__udivmodsi4>:
    6b90:	a1 e2       	ldi	r26, 0x21	; 33
    6b92:	1a 2e       	mov	r1, r26
    6b94:	aa 1b       	sub	r26, r26
    6b96:	bb 1b       	sub	r27, r27
    6b98:	fd 01       	movw	r30, r26
    6b9a:	0d c0       	rjmp	.+26     	; 0x6bb6 <__udivmodsi4_ep>

00006b9c <__udivmodsi4_loop>:
    6b9c:	aa 1f       	adc	r26, r26
    6b9e:	bb 1f       	adc	r27, r27
    6ba0:	ee 1f       	adc	r30, r30
    6ba2:	ff 1f       	adc	r31, r31
    6ba4:	a2 17       	cp	r26, r18
    6ba6:	b3 07       	cpc	r27, r19
    6ba8:	e4 07       	cpc	r30, r20
    6baa:	f5 07       	cpc	r31, r21
    6bac:	20 f0       	brcs	.+8      	; 0x6bb6 <__udivmodsi4_ep>
    6bae:	a2 1b       	sub	r26, r18
    6bb0:	b3 0b       	sbc	r27, r19
    6bb2:	e4 0b       	sbc	r30, r20
    6bb4:	f5 0b       	sbc	r31, r21

00006bb6 <__udivmodsi4_ep>:
    6bb6:	66 1f       	adc	r22, r22
    6bb8:	77 1f       	adc	r23, r23
    6bba:	88 1f       	adc	r24, r24
    6bbc:	99 1f       	adc	r25, r25
    6bbe:	1a 94       	dec	r1
    6bc0:	69 f7       	brne	.-38     	; 0x6b9c <__udivmodsi4_loop>
    6bc2:	60 95       	com	r22
    6bc4:	70 95       	com	r23
    6bc6:	80 95       	com	r24
    6bc8:	90 95       	com	r25
    6bca:	9b 01       	movw	r18, r22
    6bcc:	ac 01       	movw	r20, r24
    6bce:	bd 01       	movw	r22, r26
    6bd0:	cf 01       	movw	r24, r30
    6bd2:	08 95       	ret

00006bd4 <__umulhisi3>:
    6bd4:	a2 9f       	mul	r26, r18
    6bd6:	b0 01       	movw	r22, r0
    6bd8:	b3 9f       	mul	r27, r19
    6bda:	c0 01       	movw	r24, r0
    6bdc:	a3 9f       	mul	r26, r19
    6bde:	01 d0       	rcall	.+2      	; 0x6be2 <__umulhisi3+0xe>
    6be0:	b2 9f       	mul	r27, r18
    6be2:	70 0d       	add	r23, r0
    6be4:	81 1d       	adc	r24, r1
    6be6:	11 24       	eor	r1, r1
    6be8:	91 1d       	adc	r25, r1
    6bea:	08 95       	ret

00006bec <memcpy>:
    6bec:	fb 01       	movw	r30, r22
    6bee:	dc 01       	movw	r26, r24
    6bf0:	02 c0       	rjmp	.+4      	; 0x6bf6 <memcpy+0xa>
    6bf2:	01 90       	ld	r0, Z+
    6bf4:	0d 92       	st	X+, r0
    6bf6:	41 50       	subi	r20, 0x01	; 1
    6bf8:	50 40       	sbci	r21, 0x00	; 0
    6bfa:	d8 f7       	brcc	.-10     	; 0x6bf2 <memcpy+0x6>
    6bfc:	08 95       	ret

00006bfe <strcmp>:
    6bfe:	fb 01       	movw	r30, r22
    6c00:	dc 01       	movw	r26, r24
    6c02:	8d 91       	ld	r24, X+
    6c04:	01 90       	ld	r0, Z+
    6c06:	80 19       	sub	r24, r0
    6c08:	01 10       	cpse	r0, r1
    6c0a:	d9 f3       	breq	.-10     	; 0x6c02 <strcmp+0x4>
    6c0c:	99 0b       	sbc	r25, r25
    6c0e:	08 95       	ret

00006c10 <_exit>:
    6c10:	f8 94       	cli

00006c12 <__stop_program>:
    6c12:	ff cf       	rjmp	.-2      	; 0x6c12 <__stop_program>
